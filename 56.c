/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn __mingw_CRTStartup();
signed int __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo);
void __noreturn mainCRTStartup();
void __noreturn WinMainCRTStartup();
int __cdecl atexit(void (__cdecl *)());
_onexit_t __cdecl _onexit(_onexit_t);
int (__cdecl *__gcc_register_frame())(void *, void *);
void __cdecl __gcc_deregister_frame(); // idb
int __cdecl getfa(int x); // idb
int __cdecl comp(const edge *const a, const edge *const b); // idb
int main(); // idb
// int __usercall d_make_comp@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// int __usercall d_substitution@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall d_append_char@<eax>(int result@<eax>, char a2@<dl>);
// int __usercall d_lookup_template_argument_isra_5@<eax>(int a1@<eax>, int *a2@<edx>);
// int __usercall d_make_comp_constprop_21@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// char __usercall d_print_expr_op_part_12@<al>(int a1@<eax>, int a2@<edx>);
// char __usercall d_append_string@<al>(int a1@<eax>, const char *a2@<edx>);
// char __usercall d_append_num@<al>(int a1@<eax>, int a2@<edx>);
// int __usercall d_clone_suffix@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall d_source_name@<eax>(int a1@<eax>);
// int __usercall d_template_param@<eax>(int a1@<eax>);
// char __usercall d_print_java_identifier@<al>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
void __cdecl d_growable_string_callback_adapter(const void *a1, unsigned int a2, int a3);
// _DWORD *__usercall d_find_pack@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// char __usercall d_print_mod_list@<al>(unsigned int result@<eax>, int a2@<edx>, int *a3@<ecx>, int a4);
// char __usercall d_print_function_type_isra_9@<al>(unsigned int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4);
// char __usercall d_print_comp_part_8@<al>(unsigned int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// char __usercall d_print_comp@<al>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall d_print_cast_isra_10_part_11@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>);
// char __usercall d_print_subexpr@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall d_print_array_type_isra_7@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4);
// char __usercall d_print_expr_op@<al>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// char __usercall d_print_mod@<al>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall d_special_name@<eax>(int a1@<eax>);
// int __usercall d_expr_primary@<eax>(int a1@<eax>);
// int __usercall d_template_args@<eax>(int a1@<eax>);
// int __usercall d_name@<eax>(int a1@<eax>);
// int __usercall d_type@<eax>(int a1@<eax>);
// int __usercall d_operator_name@<eax>(int a1@<eax>);
// int __usercall d_unqualified_name@<eax>(int a1@<eax>);
// int __usercall d_expression@<eax>(int a1@<eax>);
// int __usercall d_bare_function_type@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall d_encoding_part_6@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall d_encoding_constprop_18@<eax>(int a1@<eax>);
// int __usercall d_demangle_callback_constprop_15@<eax>(int a1@<eax>, void (__cdecl *a2)(char *, int, int)@<edx>, int a3@<ecx>);
void *__cdecl __cxa_demangle(int a1, void *a2, int a3, int a4);
int __cdecl __gcclibcxx_demangle_callback(int a1, void (__cdecl *a2)(char *, int, int), int a3);
signed int __stdcall __dyn_tls_dtor(int a1, unsigned int a2, int a3);
signed int __stdcall __dyn_tls_init(int a1, int a2, int a3);
int __tlregdtor();
unsigned int __cpu_features_init();
void __cdecl fpreset();
void __noreturn __report_error(char *arg0, ...);
// void *__usercall __write_memory_part_0@<eax>(size_t a1@<ecx>, void *a2@<edx>, void *a3@<eax>);
int _pei386_runtime_relocator();
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int __main();
void __mingwthr_run_key_dtors_part_0();
signed int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2);
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1);
signed int __cdecl __mingw_TLScallback(int a1, unsigned int a2);
void init_dwarf_reg_size_table();
// int __usercall uw_install_context_1@<eax>(int a1@<eax>, int a2@<edx>);
// char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, _DWORD **a2@<edx>, _DWORD **a3@<ecx>, char **a4);
// int __usercall execute_stack_op@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4);
// unsigned int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>);
int __fastcall execute_cfa_program(_DWORD, _DWORD); // weak
// char __usercall uw_frame_state_for@<al>(int a1@<eax>, void *a2@<edx>);
// unsigned int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// signed int __usercall _Unwind_ForcedUnwind_Phase2@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall _Unwind_RaiseException_Phase2@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl _Unwind_GetGR(int a1, signed int a2);
int __cdecl _Unwind_GetCFA(int a1);
_DWORD *__cdecl _Unwind_SetGR(int a1, signed int a2, int a3);
int __cdecl _Unwind_GetIP(int a1);
int __cdecl _Unwind_GetIPInfo(int a1, _DWORD *a2);
int __cdecl _Unwind_SetIP(int a1, int a2);
int __cdecl _Unwind_GetLanguageSpecificData(int a1);
int __cdecl _Unwind_GetRegionStart(int a1);
int __cdecl _Unwind_FindEnclosingFunction(int a1);
int __cdecl _Unwind_GetDataRelBase(int a1);
int __cdecl _Unwind_GetTextRelBase(int a1);
int __cdecl __frame_state_for(int a1, int a2);
int __cdecl _Unwind_DebugHook(_DWORD, _DWORD); // weak
// char __usercall __noreturn _Unwind_RaiseException@<al>(int a1@<ebp>);
// signed int __usercall _Unwind_ForcedUnwind@<eax>(int a1@<ebp>);
// int __usercall __noreturn _Unwind_Resume@<eax>(int a1@<ebp>);
// int __usercall __noreturn _Unwind_Resume_or_Rethrow@<eax>(int a1@<ebp>);
int (__cdecl *__cdecl _Unwind_DeleteException(int a1))(signed int, int);
signed int __cdecl _Unwind_Backtrace(int (__cdecl *a1)(int *, int), int a2);
void __cdecl emutls_destroy(void *a1);
DWORD emutls_init();
_DWORD *__cdecl __emutls_get_address(int a1);
int __cdecl __emutls_register_common(int a1, unsigned int a2, unsigned int a3, int a4);
int __cdecl fde_unencoded_compare(int a1, int a2, int a3);
// int __usercall read_encoded_value_with_base_0@<eax>(char a1@<al>, int a2@<ecx>, _DWORD *a3);
// int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>);
HANDLE __gthread_mutex_init_function_constprop_9();
HANDLE init_object_mutex();
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3);
// signed int __usercall get_cie_encoding@<eax>(int a1@<eax>);
// signed int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, char *a2@<edx>);
// int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, char *a3@<ecx>);
// int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>);
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3);
int __cdecl __register_frame_info_bases(_DWORD *a1, int a2, int a3, int a4);
int __cdecl __register_frame_info(_DWORD *a1, int a2);
int __cdecl __register_frame(int *a1);
int __cdecl __register_frame_info_table_bases(int a1, int a2, int a3, int a4);
int __cdecl __register_frame_info_table(int a1, int a2);
int __cdecl __register_frame_table(int a1);
int __cdecl __deregister_frame_info_bases(_DWORD *a1);
int __deregister_frame_info(); // weak
void __cdecl __deregister_frame(void *a1);
int __cdecl _Unwind_Find_FDE(unsigned int a1, int a2);
signed int __cdecl __gthr_win32_once(int a1, void (__cdecl *a2)(int));
DWORD __cdecl __gthr_win32_key_create(int *a1, int a2);
DWORD __cdecl __gthr_win32_key_delete(DWORD a1);
int __cdecl __gthr_win32_getspecific(DWORD); // idb
DWORD __cdecl __gthr_win32_setspecific(DWORD a1, LPVOID a2);
HANDLE __cdecl __gthr_win32_mutex_init_function(int a1);
int __cdecl __gthr_win32_mutex_destroy(int a1);
int __cdecl __gthr_win32_mutex_lock(LPLONG); // idb
unsigned int __cdecl __gthr_win32_mutex_trylock(volatile signed __int32 *a1);
int __cdecl __gthr_win32_mutex_unlock(LPLONG); // idb
HANDLE __cdecl __gthr_win32_recursive_mutex_init_function(int a1);
int __cdecl __gthr_win32_recursive_mutex_lock(LPLONG); // idb
signed int __cdecl __gthr_win32_recursive_mutex_trylock(int a1);
int __cdecl __gthr_win32_recursive_mutex_unlock(LPLONG); // idb
// int __cdecl write(int, const void *, unsigned int);
// int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _setmode(int, int);
// int __p__fmode(void); weak
// int __p__environ(void); weak
// void __cdecl _cexit();
// void (__cdecl *__cdecl signal(int, void (__cdecl *)(int)))(int);
// int __cdecl putchar(int);
// int scanf(const char *, ...);
// int printf(const char *, ...);
// void *__cdecl memmove(void *, const void *, size_t);
// void __cdecl __noreturn abort();
// void *__cdecl malloc(size_t);
// void __cdecl free(void *);
// int __cdecl strcmp(const char *, const char *);
// size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
// int __cdecl fputs(const char *, FILE *);
// int sprintf(char *, const char *, ...);
// int __cdecl memcmp(const void *, const void *, size_t);
// void *__cdecl realloc(void *, size_t);
// int __cdecl vfprintf(FILE *, const char *, va_list);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl calloc(size_t, size_t);
int moncontrol_part_0();
int __cdecl monstartup(int a1, int a2);
int __cdecl moncontrol(int a1);
void __cdecl _mcleanup(); // idb
void __spoils<ecx> mcount();
// DWORD __usercall get_thrpc@<eax>(void *a1@<eax>);
void __stdcall __noreturn profthr_func(LPVOID lpThreadParameter);
int __cdecl profile_ctl(LPHANDLE, void *, size_t, int, int); // idb
int __cdecl profil(void *, size_t, int, int); // idb
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __stdcall ExitProcess(UINT uExitCode);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// DWORD __stdcall GetLastError();
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// LONG __stdcall InterlockedIncrement(LPLONG lpAddend);
// void __stdcall Sleep(DWORD dwMilliseconds);
// HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// DWORD __stdcall TlsAlloc();
// void __stdcall SetLastError(DWORD dwErrCode);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// LONG __stdcall InterlockedDecrement(LPLONG lpAddend);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall SuspendThread(HANDLE hThread);
// BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall GetCurrentProcess();
// HANDLE __stdcall GetCurrentThread();
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
signed int __cdecl __mingwthr_key_dtor(int a1, int a2);
// int open(const char *, int, ...);
// int __cdecl close(int);
// void *__cdecl memset(void *, int, size_t);
// void __cdecl perror(const char *);
// int _errno(void); weak
// char *__usercall parse_lsda_header@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// char __usercall check_exception_spec@<al>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4);
// void __usercall __gxx_exception_cleanup(int ebp0@<ebp>, void *a1, int a2);
// char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, _DWORD **a2@<edx>, _DWORD **a3@<ecx>, int a4);
void __cdecl __noreturn __cxxabiv1::__terminate(void (*a1)(void));
void __cdecl __noreturn __cxxabiv1::__unexpected(void (*a1)(void));
void __fastcall __cxxabiv1::__forced_unwind::~__forced_unwind(void *a1);
void __fastcall __cxxabiv1::__forced_unwind::~__forced_unwind(_DWORD *a1);
void __fastcall __cxxabiv1::__class_type_info::~__class_type_info(_DWORD *a1);
void __fastcall __cxxabiv1::__class_type_info::~__class_type_info(_DWORD *a1);
void __fastcall __cxxabiv1::__foreign_exception::~__foreign_exception(void *a1);
void __fastcall __cxxabiv1::__foreign_exception::~__foreign_exception(_DWORD *a1);
void __fastcall __cxxabiv1::__si_class_type_info::~__si_class_type_info(_DWORD *a1);
void __fastcall __cxxabiv1::__si_class_type_info::~__si_class_type_info(_DWORD *a1);
void __fastcall __gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error(_DWORD *a1);
void __fastcall __gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error(_DWORD *a1);
void __fastcall __gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error(_DWORD *a1);
void __fastcall __gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error(_DWORD *a1);
void __noreturn __gnu_cxx::__verbose_terminate_handler(void);
// void __usercall __noreturn __gnu_cxx::__throw_concurrence_lock_error(int a1@<ebp>);
// char __userpurge __cxxabiv1::__class_type_info::__do_catch@<al>(int a1@<edx>, int a2@<ecx>, __cxxabiv1::__class_type_info *this, const std::type_info *a4, void **a5, unsigned int a6);
char __fastcall __cxxabiv1::__class_type_info::__do_upcast(int a1, int a2, int a3, int a4, int a5);
// char __userpurge __cxxabiv1::__class_type_info::__do_upcast@<al>(int a1@<ecx>, __cxxabiv1::__class_type_info *this, const __cxxabiv1::__class_type_info *a3, void **a4);
int __fastcall __cxxabiv1::__class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall __cxxabiv1::__class_type_info::__do_find_public_src(__cxxabiv1::__class_type_info *this, int a2, const void *a3, const __cxxabiv1::__class_type_info *a4, const void *a5);
char __fastcall __cxxabiv1::__si_class_type_info::__do_upcast(int a1, int a2, int a3, int a4, int a5);
int __fastcall __cxxabiv1::__si_class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge __cxxabiv1::__si_class_type_info::__do_find_public_src@<eax>(int a1@<ecx>, __cxxabiv1::__si_class_type_info *this, int a3, const void *a4, const __cxxabiv1::__class_type_info *a5, const void *a6);
const char *__gnu_cxx::__concurrence_lock_error::what();
const char *__gnu_cxx::__concurrence_unlock_error::what();
const char *std::bad_exception::what();
const char *std::exception::what();
// char __userpurge std::type_info::__do_catch@<al>(int a1@<ecx>, std::type_info *this, const std::type_info *a3, void **a4, unsigned int a5);
int __stdcall std::type_info::__do_upcast(std::type_info *this, const __cxxabiv1::__class_type_info *a2, void **a3);
int std::type_info::__is_pointer_p();
int std::type_info::__is_function_p();
char __fastcall std::type_info::operator==(int a1, int a2, int a3);
std::_Iter_base<edge*,false>::iterator_type __cdecl std::_Iter_base<edge *,false>::_S_base(edge *__it); // idb
void __cdecl std::__iter_swap<true>::iter_swap<edge *,edge *>(edge *__a, edge *__b); // idb
void __fastcall std::bad_exception::~bad_exception(void *a1);
void __fastcall std::bad_exception::~bad_exception(_DWORD *a1);
edge *__cdecl std::__copy_move_backward<false,true,std::random_access_iterator_tag>::__copy_move_b<edge>(const edge *__first, const edge *__last, edge *__result); // idb
void __fastcall std::exception::~exception(void *a1);
void __fastcall std::exception::~exception(_DWORD *a1);
void __fastcall std::type_info::~type_info(void *a1);
void __fastcall std::type_info::~type_info(_DWORD *a1);
void __cdecl std::__pop_heap<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, edge *__result, int (*__comp)(const edge *, const edge *)); // idb
void __noreturn std::unexpected(void);
void __cdecl std::__push_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(edge *__first, int __holeIndex, int __topIndex, edge __value, int (*__comp)(const edge *, const edge *)); // idb
std::_Iter_base<edge*,false>::iterator_type __cdecl std::__miter_base<edge *>(edge *__it); // idb
std::_Iter_base<edge*,false>::iterator_type __cdecl std::__niter_base<edge *>(edge *__it); // idb
void __cdecl std::partial_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__middle, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
void __cdecl std::__adjust_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(edge *__first, int __holeIndex, int __len, edge __value, int (*__comp)(const edge *, const edge *)); // idb
void __cdecl std::__heap_select<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__middle, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
edge *__cdecl std::copy_backward<edge *,edge *>(edge *__first, edge *__last, edge *__result); // idb
void (*__cdecl std::set_terminate(void (*a1)(void)))(void);
void (*__cdecl std::set_unexpected(void (*a1)(void)))(void);
void __cdecl std::__insertion_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
void __cdecl std::__introsort_loop<edge *,int,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int __depth_limit, int (*__comp)(const edge *, const edge *)); // idb
bool std::uncaught_exception(void);
void __cdecl std::__move_median_first<edge *,int (*)(edge const&,edge const&)>(edge *__a, edge *__b, edge *__c, int (*__comp)(const edge *, const edge *)); // idb
edge *__cdecl std::__unguarded_partition<edge *,edge,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, const edge *const __pivot, int (*__comp)(const edge *, const edge *)); // idb
edge *__cdecl std::__copy_move_backward_a<false,edge *,edge *>(edge *__first, edge *__last, edge *__result); // idb
void __cdecl std::__final_insertion_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
edge *__cdecl std::__copy_move_backward_a2<false,edge *,edge *>(edge *__first, edge *__last, edge *__result); // idb
void __cdecl std::__unguarded_linear_insert<edge *,int (*)(edge const&,edge const&)>(edge *__last, int (*__comp)(const edge *, const edge *)); // idb
void __cdecl std::__unguarded_insertion_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
edge *__cdecl std::__unguarded_partition_pivot<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
// int __usercall std::__lg@<eax>(int a1@<eax>, int __n);
void __cdecl std::sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
void __cdecl std::swap<edge>(edge *const __a, edge *const __b); // idb
void __cdecl std::iter_swap<edge *,edge *>(edge *__a, edge *__b); // idb
void __cdecl std::make_heap<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
void __cdecl std::sort_heap<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *)); // idb
void __noreturn std::terminate(void);
void __cdecl operator delete(void *); // idb
// char *__usercall __cxa_allocate_dependent_exception@<eax>(int a1@<ebp>);
// char *__usercall __cxa_allocate_exception@<eax>(int a1@<ebp>, int a2);
int __cdecl __cxa_begin_catch(_QWORD *a1);
void __cdecl __noreturn __cxa_call_terminate(void (**a1)(void));
void __cdecl __noreturn __cxa_call_unexpected(_QWORD *a1);
int __cxa_current_exception_type();
void __noreturn __cxa_deleted_virtual();
int *__cxa_end_catch();
// void __usercall __cxa_free_dependent_exception(int a1@<ebp>, void *a2);
// void __usercall __cxa_free_exception(int ebp0@<ebp>, void *a1);
int __cdecl __cxa_get_exception_ptr(int a1);
_DWORD *__cxa_get_globals();
_DWORD *__cxa_get_globals_fast();
void __noreturn __cxa_pure_virtual();
// void __usercall __noreturn __cxa_rethrow(int a1@<ebp>);
// void __usercall __noreturn __cxa_throw(int a1@<ebp>, int a2, int a3, int a4);
signed int __cdecl __gxx_personality_v0(int a1, int a2, __int64 a3, void (**a4)(void), int a5);
void __cdecl __tcf_0(); // idb
int _monstartup();
int _GLOBAL__sub_I___cxa_allocate_exception();
// _DWORD *__usercall emutls_alloc@<eax>(int a1@<eax>);
int register_frame_ctor();
// int __cdecl ___set_app_type(_DWORD); weak
// _onexit_t __cdecl __onexit(_onexit_t);
// int __cdecl _atexit(void (__cdecl *)());

//-------------------------------------------------------------------------
// Data declarations

char algn_410C06[2] = { 'f', '' }; // weak
int __CTOR_LIST__[] = { 4294967295 }; // weak
int dword_416048[16] =
{
  235012095,
  565,
  28378476,
  604083456,
  4294901760,
  39717377,
  2197815680,
  1281,
  184680447,
  3489989056,
  30605313,
  4278190085,
  2668298751,
  27657473,
  83994880,
  0
}; // weak
int _CRT_glob = 4294967295; // weak
int _fmode = 16384;
int *p_1761 = &dword_416044; // weak
int once_regsizes_34688 = 0; // weak
__int32 Addend = 4294967295; // idb
int once_33252 = 0; // weak
__int32 dword_417018 = 4294967295; // idb
int once_34123 = 0; // weak
__int32 dword_417020 = 4294967295; // idb
int _gmonparam = 3; // weak
void *dword_417044 = NULL; // idb
size_t dword_417048 = 0u; // idb
int dword_41704C = 0; // weak
int dword_417050 = 0; // weak
int dword_417054 = 0; // weak
int dword_417058 = 0; // weak
int dword_41705C = 0; // weak
int dword_417060 = 0; // idb
int dword_417064 = 0; // weak
int dword_417068 = 0; // weak
int dword_41706C = 0; // weak
int data_1 = 0; // weak
_DWORD dependents_used = 0; // weak
_UNKNOWN emergency_buffer; // weak
_UNKNOWN dependents_buffer; // weak
void (*__cxxabiv1::__terminate_handler)(void) = &__gnu_cxx::__verbose_terminate_handler; // idb
void (*__cxxabiv1::__unexpected_handler)(void) = &std::terminate; // idb
__int32 `anonymous namespace'::emergency_mutex = 0; // idb
char __gnu_cxx::__verbose_terminate_handler(void)::terminating = '\0'; // weak
_UNKNOWN __emutls_v__ZZN12_GLOBAL__N_110get_globalEvE6global; // weak
int __JCR_END__ = 0; // weak
_UNKNOWN unk_41CD88; // weak
_UNKNOWN unk_41CD8B; // weak
_UNKNOWN unk_41CD8E; // weak
char *off_41D0E0 = "int"; // weak
char *off_41D248 = "decimal32"; // weak
char *off_41D25C = "decimal64"; // weak
char *off_41D270 = "decimal128"; // weak
char *off_41D284 = "half"; // weak
char *off_41D298 = "char16_t"; // weak
char *off_41D2AC = "char32_t"; // weak
char *off_41D2C0 = "decltype(nullptr)"; // weak
_UNKNOWN standard_subs; // weak
_UNKNOWN unk_41D47C; // weak
_UNKNOWN unk_41D498; // weak
_UNKNOWN unk_41D4B4; // weak
_UNKNOWN unk_41D4D0; // weak
_UNKNOWN unk_41D4EC; // weak
_UNKNOWN unk_41D508; // weak
void *cplus_demangle_operators = &unk_41D524; // weak
int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD) = &__dyn_tls_init; // weak
_UNKNOWN loc_41E048; // weak
_UNKNOWN loc_41E057; // weak
_UNKNOWN loc_41E06F; // weak
void *off_41E07C = &loc_41E2E8; // weak
_DWORD (__cdecl *off_41E260)(__cxxabiv1::__forced_unwind *__hidden this) = &__cxxabiv1::__forced_unwind::~__forced_unwind; // weak
_UNKNOWN loc_41E288; // weak
_DWORD (__cdecl *off_41E2C8)(__cxxabiv1::__foreign_exception *__hidden this) = &__cxxabiv1::__foreign_exception::~__foreign_exception; // weak
_UNKNOWN loc_41E2E8; // weak
_DWORD (__cdecl *off_41E328)(__gnu_cxx::__concurrence_lock_error *__hidden this) = &__gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error; // weak
_DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this) = &__gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error; // weak
int (*off_41E370)() = &std::exception::~exception; // weak
_DWORD (__cdecl *off_41E388)(std::type_info *__hidden this) = &std::type_info::~type_info; // weak
_UNKNOWN __EH_FRAME_BEGIN__; // weak
int _argv; // weak
int _argc; // weak
int called_1791; // weak
_UNKNOWN obj; // weak
int bcj[20010]; // idb
int n; // idb
int m; // idb
_DWORD edges[3]; // idb
edge _first; // idb
int _CRT_fmode; // idb
int __cpu_features; // weak
int was_init_31048; // weak
int initialized; // weak
int _CRT_MT; // weak
int __mingwthr_cs_init; // weak
struct _RTL_CRITICAL_SECTION __mingwthr_cs; // idb
int key_dtor_list; // weak
char dwarf_reg_size_table[]; // weak
char byte_55B949; // weak
char byte_55B94A; // weak
char byte_55B94B; // weak
char byte_55B94C; // weak
char byte_55B94D; // weak
char byte_55B94E; // weak
char byte_55B94F; // weak
char byte_55B950; // weak
char byte_55B951; // weak
char byte_55B952; // weak
char byte_55B953; // weak
char byte_55B954; // weak
char byte_55B955; // weak
char byte_55B956; // weak
char byte_55B957; // weak
char byte_55B958; // weak
__int32 emutls_mutex; // idb
HANDLE hHandle; // idb
int emutls_size; // weak
DWORD emutls_key; // idb
__int32 object_mutex; // idb
HANDLE hSemaphore; // idb
int unseen_objects; // weak
int seen_objects; // weak
_UNKNOWN terminator_34344; // weak
_UNKNOWN marker_34238; // weak
int bss_0; // idb
HANDLE prof; // idb
int dword_55B994; // weak
int dword_55B998; // weak
int dword_55B99C; // weak
int dword_55B9A0; // weak
// extern FILE __iob[];


//----- (00401000) --------------------------------------------------------
void __noreturn __mingw_CRTStartup()
{
  int v0; // ST08_4@5
  UINT v1; // ebx@5
  char v2; // [sp+28h] [bp-14h]@3
  int v3; // [sp+2Ch] [bp-10h]@3

  if ( __dyn_tls_init_callback )
    __dyn_tls_init_callback(0, 2, 0);
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)_gnu_exception_handler);
  __cpu_features_init();
  fpreset();
  v3 = 0;
  __getmainargs(&_argc, &_argv, &v2, _CRT_glob, &v3);
  if ( _CRT_fmode )
  {
    _fmode = _CRT_fmode;
    _setmode(__iob[0]._file, _CRT_fmode);
    _setmode(__iob[1]._file, _CRT_fmode);
    _setmode(__iob[2]._file, _CRT_fmode);
  }
  *(_DWORD *)__p__fmode() = _fmode;
  _pei386_runtime_relocator();
  __main();
  v0 = *(_DWORD *)__p__environ();
  v1 = main();
  _cexit();
  ExitProcess(v1);
}
// 412C74: using guessed type int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 412C84: using guessed type int __p__fmode(void);
// 412C8C: using guessed type int __p__environ(void);
// 417000: using guessed type int _CRT_glob;
// 41DA20: using guessed type int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD);
// 423000: using guessed type int _argv;
// 423004: using guessed type int _argc;

//----- (00401110) --------------------------------------------------------
signed int __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  DWORD v1; // eax@1
  signed int v2; // ebx@3
  void (__cdecl *v3)(int); // eax@4
  signed int result; // eax@6
  void (__cdecl *v5)(int); // eax@14
  void (__cdecl *v6)(int); // eax@18

  v1 = ExceptionInfo->ExceptionRecord->ExceptionCode;
  if ( v1 <= 0xC0000091 )
  {
    if ( v1 >= 0xC000008D )
    {
LABEL_3:
      v2 = 1;
      goto LABEL_4;
    }
    if ( v1 == -1073741819 )
    {
      v6 = signal(11, 0);
      if ( v6 == (void (__cdecl *)(int))1 )
      {
        signal(11, (void (__cdecl *)(int))1);
        result = -1;
      }
      else
      {
        if ( !v6 )
          return 0;
        v6(11);
        result = -1;
      }
      return result;
    }
    if ( v1 != -1073741795 )
      return 0;
    goto LABEL_14;
  }
  if ( v1 != -1073741676 )
  {
    if ( v1 != -1073741674 )
    {
      if ( v1 != -1073741677 )
        return 0;
      goto LABEL_3;
    }
LABEL_14:
    v5 = signal(4, 0);
    if ( v5 == (void (__cdecl *)(int))1 )
    {
      signal(4, (void (__cdecl *)(int))1);
      result = -1;
    }
    else
    {
      if ( !v5 )
        return 0;
      v5(4);
      result = -1;
    }
    return result;
  }
  v2 = 0;
LABEL_4:
  v3 = signal(8, 0);
  if ( v3 == (void (__cdecl *)(int))1 )
  {
    signal(8, (void (__cdecl *)(int))1);
    result = -1;
    if ( v2 )
    {
      fpreset();
      result = -1;
    }
  }
  else
  {
    if ( !v3 )
      return 0;
    v3(8);
    result = -1;
  }
  return result;
}

//----- (00401280) --------------------------------------------------------
void __noreturn mainCRTStartup()
{
  ___set_app_type(1);
  __mingw_CRTStartup();
}
// 55C208: using guessed type int __cdecl ___set_app_type(_DWORD);

//----- (004012A0) --------------------------------------------------------
void __noreturn WinMainCRTStartup()
{
  ___set_app_type(2);
  __mingw_CRTStartup();
}
// 55C208: using guessed type int __cdecl ___set_app_type(_DWORD);

//----- (004012C0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *a1)())
{
  return _atexit(a1);
}

//----- (004012D0) --------------------------------------------------------
_onexit_t __cdecl _onexit(_onexit_t a1)
{
  return __onexit(a1);
}

//----- (004012E0) --------------------------------------------------------
int (__cdecl *__gcc_register_frame())(void *, void *)
{
  HMODULE v0; // eax@1
  int (__cdecl *result)(void *, void *); // eax@2
  HMODULE v2; // eax@6

  v0 = GetModuleHandleA("libgcc_s_dw2-1.dll");
  if ( v0 )
    result = (int (__cdecl *)(void *, void *))GetProcAddress(v0, "__register_frame_info");
  else
    result = (int (__cdecl *)(void *, void *))__register_frame_info;
  if ( result )
    result = (int (__cdecl *)(void *, void *))result(&__EH_FRAME_BEGIN__, &obj);
  if ( __JCR_END__ )
  {
    v2 = GetModuleHandleA("libgcj-13.dll");
    if ( v2 )
      result = (int (__cdecl *)(void *, void *))GetProcAddress(v2, "_Jv_RegisterClasses");
    else
      result = 0;
    if ( result )
      result = (int (__cdecl *)(void *, void *))((int (__cdecl *)(_DWORD))result)(&__JCR_END__);
  }
  return result;
}
// 41BAC4: using guessed type int __JCR_END__;

//----- (0040136C) --------------------------------------------------------
void __cdecl __gcc_deregister_frame()
{
  HMODULE v0; // eax@1
  FARPROC v1; // eax@2

  v0 = GetModuleHandleA("libgcc_s_dw2-1.dll");
  if ( v0 )
    v1 = GetProcAddress(v0, "__deregister_frame_info");
  else
    v1 = (FARPROC)__deregister_frame_info;
  if ( v1 )
    ((void (__cdecl *)(_DWORD))v1)(&__EH_FRAME_BEGIN__);
}
// 41262C: using guessed type int __deregister_frame_info();

//----- (004013B0) --------------------------------------------------------
int __cdecl getfa(int x)
{
  int result; // eax@2

  mcount();
  if ( bcj[x] == x )
  {
    result = x;
  }
  else
  {
    bcj[x] = getfa(bcj[x]);
    result = bcj[x];
  }
  return result;
}

//----- (004013F9) --------------------------------------------------------
BOOL __cdecl comp(const edge *const a, const edge *const b)
{
  mcount();
  return a->w > b->w;
}

//----- (00401417) --------------------------------------------------------
int main()
{
  int v0; // ebx@8
  int v1; // ebx@9
  signed int k; // [sp+14h] [bp-10h]@7
  int j; // [sp+18h] [bp-Ch]@4
  signed int i; // [sp+1Ch] [bp-8h]@1

  mcount();
  _monstartup();
  __main();
  scanf("%d%d", &n, &m);
  for ( i = 1; i <= m; ++i )
    scanf("%d%d%d", &edges[3 * i], &edges[3 * i + 1], &edges[3 * i + 2]);
  std::sort<edge *,int (*)(edge const&,edge const&)>(
    &_first,
    (edge *)&edges[3 * (m + 1)],
    (int (*)(const edge *, const edge *))comp);
  for ( j = 1; j <= m; ++j )
    bcj[j] = j;
  for ( k = 1; k <= m; ++k )
  {
    v0 = getfa(edges[3 * k]);
    if ( v0 == getfa(edges[3 * k + 1]) )
    {
      printf("%d", edges[3 * k + 2]);
      return 0;
    }
    v1 = getfa(edges[3 * k]);
    bcj[v1] = getfa(edges[3 * k + 1]);
  }
  putchar(48);
  return 0;
}

//----- (00401608) --------------------------------------------------------
int __usercall d_make_comp@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@3
  int result; // eax@4
  int v6; // ebx@5

  switch ( a2 )
  {
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 36:
    case 47:
    case 48:
    case 54:
    case 57:
    case 61:
    case 62:
    case 63:
    case 67:
    case 68:
    case 69:
      if ( !a3 )
        goto LABEL_4;
      goto LABEL_3;
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 37:
    case 42:
    case 43:
LABEL_3:
      v4 = *(_DWORD *)(a1 + 20);
      if ( v4 >= *(_DWORD *)(a1 + 24) )
        goto LABEL_4;
      goto LABEL_5;
    default:
      goto LABEL_4;
    case 1:
    case 2:
    case 3:
    case 4:
    case 11:
    case 29:
    case 39:
    case 41:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 55:
    case 56:
    case 58:
    case 70:
      if ( a3 )
        goto LABEL_8;
      goto LABEL_4;
    case 38:
    case 44:
LABEL_8:
      if ( !a4 )
        goto LABEL_4;
      v4 = *(_DWORD *)(a1 + 20);
      if ( v4 >= *(_DWORD *)(a1 + 24) )
        goto LABEL_4;
LABEL_5:
      v6 = *(_DWORD *)(a1 + 16) + 12 * v4;
      *(_DWORD *)(a1 + 20) = v4 + 1;
      if ( v6 )
      {
        *(_DWORD *)v6 = a2;
        *(_DWORD *)(v6 + 4) = a3;
        *(_DWORD *)(v6 + 8) = a4;
        result = v6;
      }
      else
      {
LABEL_4:
        result = 0;
      }
      return result;
  }
}

//----- (00401668) --------------------------------------------------------
int __usercall d_substitution@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // eax@1
  int result; // eax@2
  _BYTE *v5; // esi@3
  int v6; // ebx@3
  unsigned int v7; // edx@5
  signed int v8; // eax@9
  unsigned int v9; // eax@23
  unsigned int i; // edx@24
  _BYTE *v11; // eax@26
  _DWORD *v12; // ebx@33
  int v13; // edx@35
  int v14; // edi@36
  int v15; // esi@40
  int v16; // ebx@40
  int v17; // [sp+0h] [bp-20h]@34
  int v18; // [sp+8h] [bp-18h]@35
  int v19; // [sp+Ch] [bp-14h]@35

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 12);
  if ( *(_BYTE *)v3 != 83 )
    return 0;
  v5 = (_BYTE *)(v3 + 1);
  *(_DWORD *)(v2 + 12) = v3 + 1;
  v6 = *(_BYTE *)(v3 + 1);
  if ( (_BYTE)v6 )
  {
    v5 = (_BYTE *)(v3 + 2);
    *(_DWORD *)(v2 + 12) = v3 + 2;
    if ( (_BYTE)v6 == 95 )
    {
      v7 = 0;
LABEL_6:
      if ( v7 < *(_DWORD *)(v2 + 32) )
      {
        ++*(_DWORD *)(v2 + 40);
        return *(_DWORD *)(*(_DWORD *)(v2 + 28) + 4 * v7);
      }
      return 0;
    }
    if ( (unsigned __int8)(v6 - 48) <= 9u || (unsigned __int8)(v6 - 65) <= 0x19u )
    {
      v9 = 0;
      if ( (unsigned __int8)(v6 - 48) > 9u )
        goto LABEL_29;
LABEL_24:
      for ( i = v6 + 36 * v9 - 48; v9 <= i; i = v6 + 36 * v9 - 55 )
      {
        v11 = *(_BYTE **)(v2 + 12);
        v6 = *v11;
        if ( (_BYTE)v6 )
        {
          *(_DWORD *)(v2 + 12) = v11 + 1;
          if ( (_BYTE)v6 == 95 )
          {
            v7 = i + 1;
            goto LABEL_6;
          }
        }
        v9 = i;
        if ( (unsigned __int8)(v6 - 48) <= 9u )
          goto LABEL_24;
LABEL_29:
        if ( (unsigned __int8)(v6 - 65) > 0x19u )
          return 0;
      }
      return 0;
    }
  }
  if ( *(_BYTE *)(v2 + 8) & 8 )
  {
    v8 = 1;
  }
  else if ( a2 )
  {
    v8 = (unsigned __int8)(*v5 - 67) <= 1u;
  }
  else
  {
    v8 = 0;
  }
  switch ( (_BYTE)v6 )
  {
    case 0x74:
      v12 = &standard_subs;
      break;
    case 0x61:
      v12 = &unk_41D47C;
      break;
    case 0x62:
      v12 = &unk_41D498;
      break;
    case 0x73:
      v12 = &unk_41D4B4;
      break;
    case 0x69:
      v12 = &unk_41D4D0;
      break;
    case 0x6F:
      v12 = &unk_41D4EC;
      break;
    default:
      if ( (_BYTE)v6 != 100 )
        return 0;
      v12 = &unk_41D508;
      break;
  }
  v17 = v12[5];
  if ( v17 )
  {
    v19 = v12[6];
    v13 = *(_DWORD *)(v2 + 20);
    v18 = *(_DWORD *)(v2 + 24);
    if ( v13 >= v18 )
    {
      v14 = 0;
    }
    else
    {
      v14 = *(_DWORD *)(v2 + 16) + 12 * v13++;
      *(_DWORD *)(v2 + 20) = v13;
      if ( v14 )
      {
        *(_DWORD *)v14 = 22;
        *(_DWORD *)(v14 + 4) = v17;
        *(_DWORD *)(v14 + 8) = v19;
      }
    }
    *(_DWORD *)(v2 + 44) = v14;
  }
  else
  {
    v18 = *(_DWORD *)(v2 + 24);
    v13 = *(_DWORD *)(v2 + 20);
  }
  if ( v8 )
  {
    v15 = v12[3];
    v16 = v12[4];
  }
  else
  {
    v15 = v12[1];
    v16 = v12[2];
  }
  *(_DWORD *)(v2 + 48) += v16;
  if ( v13 >= v18 )
    return 0;
  result = *(_DWORD *)(v2 + 16) + 12 * v13;
  *(_DWORD *)(v2 + 20) = v13 + 1;
  if ( !result )
    return 0;
  *(_DWORD *)result = 22;
  *(_DWORD *)(result + 4) = v15;
  *(_DWORD *)(result + 8) = v16;
  return result;
}

//----- (0040186C) --------------------------------------------------------
int __usercall d_append_char@<eax>(int result@<eax>, char a2@<dl>)
{
  char v2; // bl@1
  int v3; // ecx@1
  int v4; // edx@2
  int v5; // ST1C_4@4

  v2 = a2;
  v3 = *(_DWORD *)(result + 256);
  if ( v3 == 255 )
  {
    *(_BYTE *)(result + 255) = 0;
    v5 = result;
    (*(void (__cdecl **)(int, signed int, _DWORD))(result + 264))(result, 255, *(_DWORD *)(result + 268));
    result = v5;
    ++*(_DWORD *)(result + 288);
    v4 = 1;
    v3 = 0;
  }
  else
  {
    v4 = v3 + 1;
  }
  *(_BYTE *)(result + v3) = v2;
  *(_DWORD *)(result + 256) = v4;
  *(_BYTE *)(result + 260) = v2;
  return result;
}

//----- (004018D4) --------------------------------------------------------
int __usercall d_lookup_template_argument_isra_5@<eax>(int a1@<eax>, int *a2@<edx>)
{
  int v2; // ecx@1
  int v3; // edx@2
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 272);
  if ( v2 )
  {
    v3 = *a2;
    result = *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8);
    if ( !result || *(_DWORD *)result != 43 )
      return 0;
    if ( v3 > 0 )
    {
      while ( 1 )
      {
        --v3;
        result = *(_DWORD *)(result + 8);
        if ( !result )
          break;
        if ( *(_DWORD *)result != 43 )
          return 0;
        if ( !v3 )
          goto LABEL_12;
      }
    }
    else
    {
      if ( v3 )
        return 0;
LABEL_12:
      result = *(_DWORD *)(result + 4);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 280) = 1;
    result = 0;
  }
  return result;
}

//----- (00401924) --------------------------------------------------------
int __usercall d_make_comp_constprop_21@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@3
  int result; // eax@4
  int v5; // ebx@5

  switch ( a2 )
  {
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 36:
    case 47:
    case 48:
    case 54:
    case 57:
    case 61:
    case 62:
    case 63:
    case 67:
    case 68:
    case 69:
      if ( !a3 )
        goto LABEL_4;
      goto LABEL_3;
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 37:
    case 42:
    case 43:
LABEL_3:
      v3 = *(_DWORD *)(a1 + 20);
      if ( v3 >= *(_DWORD *)(a1 + 24) )
        goto LABEL_4;
      v5 = *(_DWORD *)(a1 + 16) + 12 * v3;
      *(_DWORD *)(a1 + 20) = v3 + 1;
      if ( !v5 )
        goto LABEL_4;
      *(_DWORD *)v5 = a2;
      *(_DWORD *)(v5 + 4) = a3;
      *(_DWORD *)(v5 + 8) = 0;
      result = v5;
      break;
    default:
LABEL_4:
      result = 0;
      break;
  }
  return result;
}

//----- (00401970) --------------------------------------------------------
char __usercall d_print_expr_op_part_12@<al>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // eax@1
  int v4; // edi@1
  int v5; // ebp@1
  signed int v6; // edx@2
  int v7; // esi@2
  signed int v8; // ecx@3
  char v9; // ST1C_1@6

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(v3 + 8);
  v5 = *(_DWORD *)(v3 + 4);
  if ( v4 )
  {
    v6 = *(_DWORD *)(v2 + 256);
    v7 = 0;
    do
    {
      LOBYTE(v3) = *(_BYTE *)(v5 + v7);
      if ( v6 == 255 )
      {
        *(_BYTE *)(v2 + 255) = 0;
        v9 = v3;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v2 + 264))(v2, 255, *(_DWORD *)(v2 + 268));
        ++*(_DWORD *)(v2 + 288);
        v6 = 1;
        v8 = 0;
        LOBYTE(v3) = v9;
      }
      else
      {
        v8 = v6++;
      }
      *(_BYTE *)(v2 + v8) = v3;
      *(_DWORD *)(v2 + 256) = v6;
      *(_BYTE *)(v2 + 260) = v3;
      ++v7;
    }
    while ( v4 != v7 );
  }
  return v3;
}

//----- (004019F4) --------------------------------------------------------
char __usercall d_append_string@<al>(int a1@<eax>, const char *a2@<edx>)
{
  int v2; // esi@1
  char result; // al@1
  unsigned int v4; // kr04_4@1
  signed int v5; // ebx@2
  const char *v6; // edi@2
  int v7; // ebp@2
  signed int v8; // edx@3
  char v9; // ST1C_1@6

  v2 = a1;
  result = 0;
  v4 = strlen(a2) + 1;
  if ( v4 != 1 )
  {
    v5 = *(_DWORD *)(v2 + 256);
    v6 = a2;
    v7 = (int)&a2[v4 - 1];
    do
    {
      result = *v6;
      if ( v5 == 255 )
      {
        *(_BYTE *)(v2 + 255) = 0;
        v9 = result;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v2 + 264))(v2, 255, *(_DWORD *)(v2 + 268));
        ++*(_DWORD *)(v2 + 288);
        v5 = 1;
        v8 = 0;
        result = v9;
      }
      else
      {
        v8 = v5++;
      }
      *(_BYTE *)(v2 + v8) = result;
      *(_DWORD *)(v2 + 256) = v5;
      *(_BYTE *)(v2 + 260) = result;
      ++v6;
    }
    while ( v6 != (const char *)v7 );
  }
  return result;
}

//----- (00401A80) --------------------------------------------------------
char __usercall d_append_num@<al>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  char result; // al@1
  unsigned int v4; // kr04_4@1
  signed int v5; // edx@2
  char *v6; // edi@2
  signed int v7; // ecx@3
  char v8; // ST1C_1@6
  char v9[52]; // [sp+24h] [bp+0h]@1

  v2 = a1;
  sprintf(v9, "%ld", a2);
  result = 0;
  v4 = strlen(v9) + 1;
  if ( v4 != 1 )
  {
    v5 = *(_DWORD *)(v2 + 256);
    v6 = v9;
    do
    {
      result = *v6;
      if ( v5 == 255 )
      {
        *(_BYTE *)(v2 + 255) = 0;
        v8 = result;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v2 + 264))(v2, 255, *(_DWORD *)(v2 + 268));
        ++*(_DWORD *)(v2 + 288);
        v5 = 1;
        v7 = 0;
        result = v8;
      }
      else
      {
        v7 = v5++;
      }
      *(_BYTE *)(v2 + v7) = result;
      *(_DWORD *)(v2 + 256) = v5;
      *(_BYTE *)(v2 + 260) = result;
      ++v6;
    }
    while ( v6 != &v9[v4 - 1] );
  }
  return result;
}
// 401A80: using guessed type char var_34[52];

//----- (00401B24) --------------------------------------------------------
int __usercall d_clone_suffix@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // edi@1
  char v3; // cl@1
  int i; // ebx@2
  _BYTE *v5; // esi@5
  char v6; // cl@5
  int v7; // esi@8
  int v8; // ebx@8
  int v9; // ecx@9
  char v11; // bl@16

  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_BYTE *)v2;
  if ( *(_BYTE *)v2 != 46 || (v11 = *(_BYTE *)(v2 + 1), (unsigned __int8)(v11 - 97) > 0x19u) && v11 != 95 )
  {
    i = *(_DWORD *)(a1 + 12);
  }
  else
  {
    for ( i = v2 + 2; ; ++i )
    {
      v3 = *(_BYTE *)i;
      if ( (unsigned __int8)(*(_BYTE *)i - 97) > 0x19u && v3 != 95 )
        break;
    }
  }
  if ( v3 == 46 )
  {
    do
    {
      if ( (unsigned __int8)(*(_BYTE *)(i + 1) - 48) > 9u )
        break;
      v5 = (_BYTE *)(i + 2);
      v6 = *(_BYTE *)(i + 2);
      if ( (unsigned __int8)(v6 - 48) <= 9u )
      {
        do
          v6 = *++v5;
        while ( (unsigned __int8)(*v5 - 48) <= 9u );
        i = (int)v5;
      }
      else
      {
        i += 2;
      }
    }
    while ( v6 == 46 );
  }
  v7 = i - v2;
  *(_DWORD *)(a1 + 12) = i;
  v8 = *(_DWORD *)(a1 + 20);
  if ( v8 < *(_DWORD *)(a1 + 24) && (v9 = *(_DWORD *)(a1 + 16) + 12 * v8, *(_DWORD *)(a1 + 20) = v8 + 1, v9) && v7 )
  {
    *(_DWORD *)v9 = 0;
    *(_DWORD *)(v9 + 4) = v2;
    *(_DWORD *)(v9 + 8) = v7;
  }
  else
  {
    v9 = 0;
  }
  return d_make_comp(a1, 70, a2, v9);
}

//----- (00401BF8) --------------------------------------------------------
int __usercall d_source_name@<eax>(int a1@<eax>)
{
  int v1; // ebp@1
  int *v2; // eax@1
  _BYTE *v3; // ebx@1
  int v4; // edx@1
  int v5; // ebx@4
  int v6; // esi@4
  int result; // eax@8
  _BYTE *v8; // eax@11
  char v9; // al@16
  int v10; // edx@19
  int v11; // edx@27
  signed int v12; // [sp+1Ch] [bp-20h]@2

  v1 = a1;
  v2 = (int *)(a1 + 12);
  v3 = *(_BYTE **)(v1 + 12);
  v4 = *v3;
  if ( (_BYTE)v4 == 110 )
  {
    *(_DWORD *)(v1 + 12) = v3 + 1;
    v4 = (v3++)[1];
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  if ( (unsigned __int8)(v4 - 48) > 9u )
    return 0;
  v5 = (int)(v3 + 1);
  v6 = 0;
  while ( 1 )
  {
    v6 = v4 + 10 * v6 - 48;
    *v2 = v5;
    v4 = *(_BYTE *)v5;
    if ( (unsigned __int8)(v4 - 48) > 9u )
      break;
    ++v5;
  }
  if ( v12 || v6 <= 0 )
    return 0;
  if ( v6 > *(_DWORD *)(v1 + 4) - v5 )
    goto LABEL_24;
  v8 = (_BYTE *)(v5 + v6);
  *(_DWORD *)(v1 + 12) = v5 + v6;
  if ( *(_BYTE *)(v1 + 8) & 4 && *v8 == 36 )
    *(_DWORD *)(v1 + 12) = v8 + 1;
  if ( v6 > 9 && !memcmp((const void *)v5, "_GLOBAL_", 8u) )
  {
    v9 = *(_BYTE *)(v5 + 8);
    if ( (v9 == 46 || v9 == 95 || v9 == 36) && *(_BYTE *)(v5 + 9) == 78 )
    {
      *(_DWORD *)(v1 + 48) = *(_DWORD *)(v1 + 48) + 22 - v6;
      v11 = *(_DWORD *)(v1 + 20);
      if ( v11 < *(_DWORD *)(v1 + 24) )
      {
        result = *(_DWORD *)(v1 + 16) + 12 * v11;
        *(_DWORD *)(v1 + 20) = v11 + 1;
        if ( result )
        {
          *(_DWORD *)result = 0;
          *(_DWORD *)(result + 4) = "(anonymous namespace)";
          *(_DWORD *)(result + 8) = 21;
          goto LABEL_23;
        }
      }
      goto LABEL_24;
    }
  }
  v10 = *(_DWORD *)(v1 + 20);
  if ( v10 >= *(_DWORD *)(v1 + 24)
    || (result = *(_DWORD *)(v1 + 16) + 12 * v10, *(_DWORD *)(v1 + 20) = v10 + 1, !result)
    || !v5 )
  {
LABEL_24:
    result = 0;
    goto LABEL_23;
  }
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = v5;
  *(_DWORD *)(result + 8) = v6;
LABEL_23:
  *(_DWORD *)(v1 + 44) = result;
  return result;
}

//----- (00401D48) --------------------------------------------------------
int __usercall d_template_param@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // edx@3
  int v4; // ecx@3
  _BYTE *v5; // edi@6
  int v6; // ebx@6
  int v7; // esi@7
  int v8; // esi@8
  int v9; // edx@9
  int v10; // [sp+0h] [bp-14h]@1

  v10 = a1;
  v1 = *(_DWORD *)(a1 + 12);
  if ( *(_BYTE *)v1 != 84 )
    return 0;
  v3 = v1 + 1;
  *(_DWORD *)(a1 + 12) = v1 + 1;
  v4 = *(_BYTE *)(v1 + 1);
  if ( (_BYTE)v4 == 95 )
  {
    v8 = 0;
  }
  else
  {
    if ( (_BYTE)v4 == 110 )
      return 0;
    if ( (unsigned __int8)(v4 - 48) > 9u )
      return 0;
    v5 = (_BYTE *)(v1 + 2);
    v6 = 0;
    do
    {
      v7 = v4 + 10 * v6;
      v6 = v7 - 48;
      v3 = (int)v5;
      *(_DWORD *)(a1 + 12) = v5;
      v4 = *v5++;
    }
    while ( (unsigned __int8)(v4 - 48) <= 9u );
    v8 = v7 - 47;
    if ( (_BYTE)v4 != 95 )
      return 0;
  }
  *(_DWORD *)(a1 + 12) = v3 + 1;
  ++*(_DWORD *)(a1 + 40);
  v9 = *(_DWORD *)(a1 + 20);
  if ( v9 >= *(_DWORD *)(a1 + 24) )
    return 0;
  result = *(_DWORD *)(a1 + 16) + 12 * v9;
  *(_DWORD *)(v10 + 20) = v9 + 1;
  if ( !result )
    return 0;
  *(_DWORD *)result = 5;
  *(_DWORD *)(result + 4) = v8;
  return result;
}

//----- (00401DE4) --------------------------------------------------------
char __usercall d_print_java_identifier@<al>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // edi@1
  int v4; // ebx@2
  signed int v5; // ecx@2
  unsigned int v6; // ebp@2
  signed int v7; // edx@3
  char v8; // ST10_1@9
  unsigned int v9; // esi@13
  int v10; // edx@14
  int v11; // edx@16
  signed int v12; // edx@27
  unsigned int v14; // [sp+14h] [bp-28h]@23

  v3 = a2 + a3;
  if ( a2 < a2 + a3 )
  {
    v4 = a1;
    v5 = *(_DWORD *)(a1 + 256);
    v6 = a2;
    do
    {
      LOBYTE(a1) = *(_BYTE *)v6;
      if ( (signed int)(v3 - v6) <= 3
        || (_BYTE)a1 != 95
        || *(_BYTE *)(v6 + 1) != 95
        || *(_BYTE *)(v6 + 2) != 85
        || v3 <= v6 + 3 )
      {
LABEL_8:
        if ( v5 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v8 = a1;
          (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          ++*(_DWORD *)(v4 + 288);
          v5 = 1;
          v7 = 0;
          LOBYTE(a1) = v8;
        }
        else
        {
          v7 = v5++;
        }
        *(_BYTE *)(v4 + v7) = a1;
        *(_DWORD *)(v4 + 256) = v5;
        *(_BYTE *)(v4 + 260) = a1;
        goto LABEL_5;
      }
      v9 = 0;
      a1 = v6 + 3;
      while ( 1 )
      {
        while ( 1 )
        {
          v11 = *(_BYTE *)a1;
          if ( (unsigned __int8)(v11 - 48) > 9u )
            break;
          v10 = v11 - 48;
LABEL_15:
          v9 = v10 + 16 * v9;
          if ( ++a1 == v3 )
            goto LABEL_19;
        }
        if ( (unsigned __int8)(v11 - 65) > 5u )
          break;
        v9 = v11 - 55 + 16 * v9;
        if ( ++a1 == v3 )
        {
LABEL_19:
          LOBYTE(a1) = 95;
          goto LABEL_8;
        }
      }
      if ( (unsigned __int8)(v11 - 97) <= 5u )
      {
        v10 = v11 - 87;
        goto LABEL_15;
      }
      v14 = a1;
      LOBYTE(a1) = 95;
      if ( v3 <= v14 || (_BYTE)v11 != 95 || v9 > 0xFF )
        goto LABEL_8;
      LOBYTE(a1) = v9;
      if ( v5 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        ++*(_DWORD *)(v4 + 288);
        v5 = 1;
        v12 = 0;
        LOBYTE(a1) = v9;
      }
      else
      {
        v12 = v5++;
      }
      *(_BYTE *)(v4 + v12) = a1;
      *(_DWORD *)(v4 + 256) = v5;
      *(_BYTE *)(v4 + 260) = a1;
      v6 = v14;
LABEL_5:
      ++v6;
    }
    while ( v3 > v6 );
  }
  return a1;
}

//----- (00401F74) --------------------------------------------------------
void __cdecl d_growable_string_callback_adapter(const void *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@1
  size_t v4; // esi@1
  void *v5; // eax@9

  v3 = a2 + *(_DWORD *)(a3 + 4) + 1;
  v4 = *(_DWORD *)(a3 + 8);
  if ( v3 > v4 )
  {
    if ( *(_DWORD *)(a3 + 12) )
      return;
    if ( v4 || (v4 = 2, v3 > 2) )
    {
      do
        v4 *= 2;
      while ( v3 > v4 );
    }
    v5 = realloc(*(void **)a3, v4);
    if ( !v5 )
    {
      free(*(void **)a3);
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 0;
      *(_DWORD *)(a3 + 8) = 0;
      *(_DWORD *)(a3 + 12) = 1;
      return;
    }
    *(_DWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = v4;
  }
  if ( !*(_DWORD *)(a3 + 12) )
  {
    qmemcpy((void *)(*(_DWORD *)(a3 + 4) + *(_DWORD *)a3), a1, a2);
    *(_BYTE *)(*(_DWORD *)(a3 + 4) + a2 + *(_DWORD *)a3) = 0;
    *(_DWORD *)(a3 + 4) += a2;
  }
}

//----- (00402028) --------------------------------------------------------
_DWORD *__usercall d_find_pack@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  int v4; // ebx@1
  _DWORD *result; // eax@3
  int v6; // eax@8
  int v7; // edx@9
  int v8; // eax@9

  v3 = a1;
  v4 = a2;
  if ( a2 )
  {
    while ( *(_DWORD *)v4 > 0x45u )
    {
LABEL_3:
      result = (_DWORD *)d_find_pack(a3, *(_DWORD *)(v4 + 4));
      if ( result )
        return result;
LABEL_4:
      v4 = *(_DWORD *)(v4 + 8);
      if ( !v4 )
        goto LABEL_5;
    }
    switch ( *(_DWORD *)v4 )
    {
      default:
        goto LABEL_3;
      case 7:
      case 8:
      case 0x2E:
        goto LABEL_4;
      case 0:
      case 6:
      case 0x16:
      case 0x23:
      case 0x2D:
      case 0x3B:
      case 0x40:
      case 0x45:
        goto LABEL_5;
      case 5:
        v6 = *(_DWORD *)(v3 + 272);
        if ( !v6 )
        {
          *(_DWORD *)(v3 + 280) = 1;
          goto LABEL_5;
        }
        v7 = *(_DWORD *)(v4 + 4);
        v8 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 8);
        if ( !v8 || *(_DWORD *)v8 != 43 )
          goto LABEL_5;
        if ( v7 > 0 )
        {
          do
          {
            --v7;
            v8 = *(_DWORD *)(v8 + 8);
            if ( !v8 || *(_DWORD *)v8 != 43 )
              goto LABEL_5;
          }
          while ( v7 );
        }
        else if ( v7 )
        {
          goto LABEL_5;
        }
        result = *(_DWORD **)(v8 + 4);
        if ( !result || *result != 43 )
          goto LABEL_5;
        break;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (004020BC) --------------------------------------------------------
char __usercall d_print_mod_list@<al>(unsigned int result@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)
{
  int *v4; // ebp@1
  unsigned int v5; // ebx@2
  unsigned int *v6; // ecx@7
  int v7; // esi@8
  unsigned int *v8; // edx@8
  int v9; // edi@14
  int *v10; // ecx@17
  int v11; // eax@17
  int v12; // edi@28
  int v13; // ecx@28
  int v14; // edx@32
  int v15; // eax@33
  int v16; // edx@34
  int v17; // eax@36
  int v18; // ebp@39
  int v19; // eax@39
  int v20; // ecx@49
  int v21; // eax@50
  int v22; // edx@51
  int v23; // eax@52
  int v24; // edx@53
  int v25; // eax@54
  int v26; // edx@55
  int v27; // eax@56
  int v28; // edx@57
  int v29; // eax@58
  int v30; // edx@59
  int v31; // eax@60
  int v32; // edx@61
  signed int v33; // eax@62
  unsigned int v34; // kr04_4@62
  char *v35; // edi@63
  signed int v36; // ecx@64
  char v37; // dl@66
  char v38; // ST14_1@67
  int v39; // edx@69
  int v40; // eax@70
  int v41; // edx@71
  int v43; // [sp+18h] [bp-44h]@1
  char v44[56]; // [sp+24h] [bp-38h]@62

  v43 = a2;
  v4 = a3;
  if ( !a3 )
    return result;
  v5 = result;
  if ( *(_DWORD *)(result + 280) )
    return result;
  if ( !a4 )
  {
    while ( 1 )
    {
      result = v4[2];
      if ( !result )
      {
        v6 = (unsigned int *)v4[1];
        result = *v6;
        if ( *v6 - 26 > 2 )
        {
          v4[2] = 1;
          v7 = *(_DWORD *)(v5 + 272);
          *(_DWORD *)(v5 + 272) = v4[3];
          v8 = v6;
          if ( result == 37 )
            goto LABEL_24;
          if ( result == 38 )
            goto LABEL_26;
          if ( result == 2 )
            goto LABEL_28;
          LOBYTE(result) = d_print_mod(v5, v43, (int)v6);
          *(_DWORD *)(v5 + 272) = v7;
        }
      }
      v4 = (int *)*v4;
      if ( v4 )
      {
        result = *(_DWORD *)(v5 + 280);
        if ( !result )
          continue;
      }
      return result;
    }
  }
  v9 = a2;
  while ( 1 )
  {
    result = v4[2];
    if ( result )
      goto LABEL_21;
    v4[2] = 1;
    v7 = *(_DWORD *)(v5 + 272);
    *(_DWORD *)(v5 + 272) = v4[3];
    v10 = (int *)v4[1];
    v11 = *v10;
    if ( *v10 == 37 )
    {
      v8 = (unsigned int *)v4[1];
LABEL_24:
      LOBYTE(result) = d_print_function_type_isra_9(v5, v43, v8 + 2, *v4);
      *(_DWORD *)(v5 + 272) = v7;
      return result;
    }
    if ( v11 == 38 )
      break;
    if ( v11 == 2 )
    {
      v8 = (unsigned int *)v4[1];
LABEL_28:
      v12 = *(_DWORD *)(v5 + 276);
      *(_DWORD *)(v5 + 276) = 0;
      v13 = v8[1];
      if ( v13 )
      {
        if ( !*(_DWORD *)(v5 + 280) )
          d_print_comp_part_8(v5, v43, v13);
      }
      else
      {
        *(_DWORD *)(v5 + 280) = 1;
      }
      *(_DWORD *)(v5 + 276) = v12;
      if ( v43 & 4 )
      {
        v17 = *(_DWORD *)(v5 + 256);
        if ( v17 == 255 )
        {
          *(_BYTE *)(v5 + 255) = 0;
          (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
          ++*(_DWORD *)(v5 + 288);
          v16 = 1;
          v17 = 0;
        }
        else
        {
          v16 = v17 + 1;
        }
        *(_BYTE *)(v5 + v17) = 46;
        *(_DWORD *)(v5 + 256) = v16;
        *(_BYTE *)(v5 + 260) = 46;
      }
      else
      {
        v14 = *(_DWORD *)(v5 + 256);
        if ( v14 == 255 )
        {
          *(_BYTE *)(v5 + 255) = 0;
          (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
          ++*(_DWORD *)(v5 + 288);
          *(_BYTE *)v5 = 58;
          v15 = 1;
LABEL_34:
          v16 = v15 + 1;
        }
        else
        {
          v15 = v14 + 1;
          *(_BYTE *)(v5 + v14) = 58;
          *(_DWORD *)(v5 + 256) = v14 + 1;
          *(_BYTE *)(v5 + 260) = 58;
          if ( v14 != 254 )
            goto LABEL_34;
          *(_BYTE *)(v5 + 255) = 0;
          (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
          ++*(_DWORD *)(v5 + 288);
          v16 = 1;
          v15 = 0;
        }
        *(_BYTE *)(v5 + v15) = 58;
        *(_DWORD *)(v5 + 256) = v16;
        *(_BYTE *)(v5 + 260) = 58;
      }
      v18 = *(_DWORD *)(v4[1] + 8);
      v19 = *(_DWORD *)v18;
      if ( *(_DWORD *)v18 != 65 )
        goto LABEL_42;
      if ( v16 != 255 )
      {
        v20 = v16 + 1;
        *(_BYTE *)(v5 + v16) = 123;
        *(_DWORD *)(v5 + 256) = v16 + 1;
        *(_BYTE *)(v5 + 260) = 123;
        if ( v16 != 254 )
          goto LABEL_50;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 100;
        v21 = 1;
        goto LABEL_51;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 123;
      v20 = 1;
LABEL_50:
      v21 = v20 + 1;
      *(_BYTE *)(v5 + v20) = 100;
      *(_DWORD *)(v5 + 256) = v20 + 1;
      *(_BYTE *)(v5 + 260) = 100;
      if ( v20 != 254 )
      {
LABEL_51:
        v22 = v21 + 1;
        *(_BYTE *)(v5 + v21) = 101;
        *(_DWORD *)(v5 + 256) = v21 + 1;
        *(_BYTE *)(v5 + 260) = 101;
        if ( v21 != 254 )
          goto LABEL_52;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 102;
        v23 = 1;
        goto LABEL_53;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 101;
      v22 = 1;
LABEL_52:
      v23 = v22 + 1;
      *(_BYTE *)(v5 + v22) = 102;
      *(_DWORD *)(v5 + 256) = v22 + 1;
      *(_BYTE *)(v5 + 260) = 102;
      if ( v22 != 254 )
      {
LABEL_53:
        v24 = v23 + 1;
        *(_BYTE *)(v5 + v23) = 97;
        *(_DWORD *)(v5 + 256) = v23 + 1;
        *(_BYTE *)(v5 + 260) = 97;
        if ( v23 != 254 )
          goto LABEL_54;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 117;
        v25 = 1;
        goto LABEL_55;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 97;
      v24 = 1;
LABEL_54:
      v25 = v24 + 1;
      *(_BYTE *)(v5 + v24) = 117;
      *(_DWORD *)(v5 + 256) = v24 + 1;
      *(_BYTE *)(v5 + 260) = 117;
      if ( v24 != 254 )
      {
LABEL_55:
        v26 = v25 + 1;
        *(_BYTE *)(v5 + v25) = 108;
        *(_DWORD *)(v5 + 256) = v25 + 1;
        *(_BYTE *)(v5 + 260) = 108;
        if ( v25 != 254 )
          goto LABEL_56;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 116;
        v27 = 1;
        goto LABEL_57;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 108;
      v26 = 1;
LABEL_56:
      v27 = v26 + 1;
      *(_BYTE *)(v5 + v26) = 116;
      *(_DWORD *)(v5 + 256) = v26 + 1;
      *(_BYTE *)(v5 + 260) = 116;
      if ( v26 != 254 )
      {
LABEL_57:
        v28 = v27 + 1;
        *(_BYTE *)(v5 + v27) = 32;
        *(_DWORD *)(v5 + 256) = v27 + 1;
        *(_BYTE *)(v5 + 260) = 32;
        if ( v27 != 254 )
          goto LABEL_58;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 97;
        v29 = 1;
        goto LABEL_59;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 32;
      v28 = 1;
LABEL_58:
      v29 = v28 + 1;
      *(_BYTE *)(v5 + v28) = 97;
      *(_DWORD *)(v5 + 256) = v28 + 1;
      *(_BYTE *)(v5 + 260) = 97;
      if ( v28 != 254 )
      {
LABEL_59:
        v30 = v29 + 1;
        *(_BYTE *)(v5 + v29) = 114;
        *(_DWORD *)(v5 + 256) = v29 + 1;
        *(_BYTE *)(v5 + 260) = 114;
        if ( v29 != 254 )
          goto LABEL_60;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 103;
        v31 = 1;
        goto LABEL_61;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 114;
      v30 = 1;
LABEL_60:
      v31 = v30 + 1;
      *(_BYTE *)(v5 + v30) = 103;
      *(_DWORD *)(v5 + 256) = v30 + 1;
      *(_BYTE *)(v5 + 260) = 103;
      if ( v30 == 254 )
      {
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        v32 = 1;
        v31 = 0;
      }
      else
      {
LABEL_61:
        v32 = v31 + 1;
      }
      *(_BYTE *)(v5 + v31) = 35;
      *(_DWORD *)(v5 + 256) = v32;
      *(_BYTE *)(v5 + 260) = 35;
      sprintf(v44, "%ld", *(_DWORD *)(v18 + 8) + 1);
      v34 = strlen(v44) + 1;
      v33 = *(_DWORD *)(v5 + 256);
      if ( v34 != 1 )
      {
        v35 = v44;
        do
        {
          v37 = *v35;
          if ( v33 == 255 )
          {
            *(_BYTE *)(v5 + 255) = 0;
            v38 = v37;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
            ++*(_DWORD *)(v5 + 288);
            v33 = 1;
            v36 = 0;
            v37 = v38;
          }
          else
          {
            v36 = v33++;
          }
          *(_BYTE *)(v5 + v36) = v37;
          *(_DWORD *)(v5 + 256) = v33;
          *(_BYTE *)(v5 + 260) = v37;
          ++v35;
        }
        while ( v35 != &v44[v34 - 1] );
      }
      if ( v33 != 255 )
      {
        v39 = v33 + 1;
        *(_BYTE *)(v5 + v33) = 125;
        *(_DWORD *)(v5 + 256) = v33 + 1;
        *(_BYTE *)(v5 + 260) = 125;
        if ( v33 != 254 )
          goto LABEL_70;
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        *(_BYTE *)v5 = 58;
        v40 = 1;
        goto LABEL_71;
      }
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      *(_BYTE *)v5 = 125;
      v39 = 1;
LABEL_70:
      v40 = v39 + 1;
      *(_BYTE *)(v5 + v39) = 58;
      *(_DWORD *)(v5 + 256) = v39 + 1;
      *(_BYTE *)(v5 + 260) = 58;
      if ( v39 == 254 )
      {
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        v41 = 1;
        v40 = 0;
      }
      else
      {
LABEL_71:
        v41 = v40 + 1;
      }
      *(_BYTE *)(v5 + v40) = 58;
      *(_DWORD *)(v5 + 256) = v41;
      *(_BYTE *)(v5 + 260) = 58;
      do
      {
        v18 = *(_DWORD *)(v18 + 4);
        v19 = *(_DWORD *)v18;
LABEL_42:
        result = v19 - 26;
      }
      while ( result <= 2 );
      if ( !*(_DWORD *)(v5 + 280) )
        LOBYTE(result) = d_print_comp_part_8(v5, v43, v18);
      *(_DWORD *)(v5 + 272) = v7;
      return result;
    }
    LOBYTE(result) = d_print_mod(v5, v9, (int)v10);
    *(_DWORD *)(v5 + 272) = v7;
LABEL_21:
    v4 = (int *)*v4;
    if ( v4 )
    {
      result = *(_DWORD *)(v5 + 280);
      if ( !result )
        continue;
    }
    return result;
  }
  v8 = (unsigned int *)v4[1];
LABEL_26:
  LOBYTE(result) = d_print_array_type_isra_7(v5, v43, v8 + 1, *v4);
  *(_DWORD *)(v5 + 272) = v7;
  return result;
}
// 4020BC: using guessed type char var_38[56];

//----- (0040298C) --------------------------------------------------------
char __usercall d_print_function_type_isra_9@<al>(unsigned int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  unsigned int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@3
  int v7; // ebp@7
  int v8; // edx@7
  int v9; // eax@8
  int v10; // edx@13
  char result; // al@14
  char v12; // al@15
  int v13; // edx@17
  int v14; // eax@18
  int v15; // edx@20
  int v16; // eax@25
  int *v17; // [sp+1Ch] [bp-20h]@1

  v4 = a1;
  v5 = a2;
  v17 = a3;
  if ( !a4 || *(_DWORD *)(a4 + 8) )
  {
LABEL_7:
    v7 = *(_DWORD *)(v4 + 276);
    *(_DWORD *)(v4 + 276) = 0;
    d_print_mod_list(v4, a2, (int *)a4, 0);
    v8 = *(_DWORD *)(v4 + 256);
    if ( v8 == 255 )
    {
LABEL_28:
      *(_BYTE *)(v4 + 255) = 0;
      (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
      ++*(_DWORD *)(v4 + 288);
      v9 = 1;
      v8 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    v6 = a4;
    while ( 2 )
    {
      switch ( **(_DWORD **)(v6 + 4) )
      {
        default:
          v6 = *(_DWORD *)v6;
          if ( !v6 || *(_DWORD *)(v6 + 8) )
            goto LABEL_7;
          continue;
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x1D:
        case 0x21:
        case 0x22:
        case 0x27:
          v12 = *(_BYTE *)(v4 + 260);
          goto LABEL_16;
        case 0x1E:
        case 0x1F:
        case 0x20:
          v12 = *(_BYTE *)(v4 + 260);
          if ( v12 == 40 || v12 == 42 )
            goto LABEL_23;
LABEL_16:
          if ( v12 == 32 )
          {
LABEL_23:
            v14 = *(_DWORD *)(v4 + 256);
            if ( v14 == 255 )
            {
LABEL_20:
              *(_BYTE *)(v4 + 255) = 0;
              (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
              ++*(_DWORD *)(v4 + 288);
              v15 = 1;
              v14 = 0;
              goto LABEL_25;
            }
          }
          else
          {
            v13 = *(_DWORD *)(v4 + 256);
            if ( v13 == 255 )
            {
              *(_BYTE *)(v4 + 255) = 0;
              (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
              ++*(_DWORD *)(v4 + 288);
              v14 = 1;
              v13 = 0;
            }
            else
            {
              v14 = v13 + 1;
            }
            *(_BYTE *)(v4 + v13) = 32;
            *(_DWORD *)(v4 + 256) = v14;
            *(_BYTE *)(v4 + 260) = 32;
            if ( v14 == 255 )
              goto LABEL_20;
          }
          v15 = v14 + 1;
LABEL_25:
          *(_BYTE *)(v4 + v14) = 40;
          *(_DWORD *)(v4 + 256) = v15;
          *(_BYTE *)(v4 + 260) = 40;
          v7 = *(_DWORD *)(v4 + 276);
          *(_DWORD *)(v4 + 276) = 0;
          d_print_mod_list(v4, v5, (int *)a4, 0);
          v16 = *(_DWORD *)(v4 + 256);
          if ( v16 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v8 = 1;
            v16 = 0;
          }
          else
          {
            v8 = v16 + 1;
          }
          *(_BYTE *)(v4 + v16) = 41;
          *(_DWORD *)(v4 + 256) = v8;
          *(_BYTE *)(v4 + 260) = 41;
          if ( v8 == 255 )
            goto LABEL_28;
          break;
      }
      break;
    }
  }
  v9 = v8 + 1;
LABEL_9:
  *(_BYTE *)(v4 + v8) = 40;
  *(_DWORD *)(v4 + 256) = v9;
  *(_BYTE *)(v4 + 260) = 40;
  if ( *v17 && !*(_DWORD *)(v4 + 280) )
  {
    d_print_comp_part_8(v4, v5, *v17);
    v9 = *(_DWORD *)(v4 + 256);
  }
  if ( v9 == 255 )
  {
    *(_BYTE *)(v4 + 255) = 0;
    (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
    ++*(_DWORD *)(v4 + 288);
    v10 = 1;
    v9 = 0;
  }
  else
  {
    v10 = v9 + 1;
  }
  *(_BYTE *)(v4 + v9) = 41;
  *(_DWORD *)(v4 + 256) = v10;
  *(_BYTE *)(v4 + 260) = 41;
  result = d_print_mod_list(v4, v5, (int *)a4, 1);
  *(_DWORD *)(v4 + 276) = v7;
  return result;
}

//----- (00402C34) --------------------------------------------------------
char __usercall d_print_comp_part_8@<al>(unsigned int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ebp@1
  int *v4; // eax@1
  int v5; // ecx@5
  int v6; // eax@8
  int v7; // edx@9
  int v8; // eax@10
  int v9; // edx@11
  int v10; // eax@12
  int v11; // edx@13
  int v12; // eax@14
  int v13; // edx@15
  int v14; // ecx@17
  int v15; // edx@21
  int v16; // esi@23
  int v17; // edi@28
  int v18; // ebx@28
  int v19; // edx@34
  int v20; // edx@36
  int v21; // ecx@38
  unsigned int v22; // ebx@42
  int v23; // edi@44
  int v24; // ecx@44
  int v25; // ecx@49
  int v26; // ebx@55
  int *v27; // edx@55
  int v28; // ecx@61
  int v29; // esi@66
  int *v30; // ebx@66
  int v31; // eax@69
  int v32; // edx@70
  int v33; // eax@71
  int v34; // edx@72
  int v35; // eax@73
  int v36; // edx@74
  int v37; // eax@75
  int v38; // edx@76
  int v39; // eax@77
  int v40; // edx@78
  int v41; // ecx@80
  int v42; // edx@84
  int v43; // eax@86
  int v44; // edx@87
  int v45; // eax@88
  int v46; // edx@89
  int v47; // eax@90
  int v48; // edx@91
  int v49; // eax@92
  int v50; // edx@93
  int v51; // eax@94
  int v52; // edx@95
  int v53; // eax@96
  int v54; // edx@97
  int v55; // eax@98
  int v56; // edx@99
  int v57; // eax@100
  int v58; // edx@101
  int v59; // edx@103
  int v60; // ecx@104
  int v61; // edx@108
  int v62; // ecx@110
  int v63; // edx@114
  int v64; // edx@117
  int v65; // eax@118
  int v66; // edx@119
  int v67; // eax@120
  int v68; // edx@121
  int v69; // eax@122
  int v70; // edx@123
  int v71; // eax@124
  int v72; // edx@125
  int v73; // eax@126
  int v74; // edx@127
  int v75; // eax@128
  int v76; // edx@129
  int v77; // edx@131
  int v78; // ecx@132
  int v79; // edx@135
  unsigned int v80; // ebx@136
  int v81; // edx@139
  int v82; // eax@140
  int v83; // ecx@141
  int v84; // edx@145
  int v85; // ecx@147
  int v86; // eax@151
  char v87; // bl@157
  int v88; // edx@158
  int v89; // eax@160
  int v90; // edx@161
  int v91; // eax@162
  int v92; // edx@163
  int v93; // eax@164
  int v94; // edx@165
  int v95; // eax@166
  int v96; // edx@167
  int v97; // eax@168
  int v98; // edx@169
  _DWORD *v99; // ecx@170
  int v100; // ebx@174
  bool v101; // zf@174
  int v102; // ecx@179
  int v103; // ebx@184
  int v104; // esi@184
  int v105; // eax@184
  int v106; // edx@185
  int v107; // eax@186
  int v108; // edx@187
  int v109; // eax@188
  int v110; // edx@189
  int v111; // eax@190
  int v112; // edx@191
  _BYTE *v113; // edi@192
  int v114; // ebx@196
  int *v115; // ecx@197
  char v116; // dl@199
  char v117; // ST18_1@200
  int v118; // esi@201
  int v119; // ebx@202
  int v120; // ecx@202
  int v121; // ecx@204
  int v122; // eax@205
  int v123; // edx@208
  int *v124; // ecx@212
  int v125; // ecx@214
  int v126; // esi@217
  int v127; // edi@217
  int v128; // ebx@218
  int *v129; // ecx@219
  char v130; // dl@221
  char v131; // ST18_1@222
  int v132; // eax@223
  int v133; // edx@224
  int v134; // eax@225
  int v135; // edx@226
  int v136; // eax@227
  int v137; // edx@228
  int v138; // eax@229
  int v139; // edx@230
  int v140; // eax@231
  int v141; // edx@232
  int v142; // eax@233
  int v143; // edx@234
  int v144; // eax@235
  int v145; // edx@236
  int v146; // eax@237
  int v147; // edx@238
  int v148; // edx@240
  int v149; // ecx@241
  signed int v150; // eax@244
  const char *v151; // ebx@244
  signed int v152; // ecx@245
  char v153; // dl@247
  char v154; // ST18_1@248
  const char *v155; // ebx@249
  int *v156; // ecx@250
  char v157; // dl@252
  char v158; // ST18_1@253
  int v159; // edx@255
  int v160; // ecx@256
  int v161; // ecx@259
  int v162; // ecx@262
  int v163; // ebx@265
  int v164; // eax@265
  bool v165; // zf@267
  int v166; // edx@270
  int v167; // ecx@273
  int v168; // edx@277
  int v169; // ecx@280
  int v170; // edx@283
  int v171; // edx@284
  int v172; // eax@285
  int v173; // edx@286
  int v174; // edx@288
  int v175; // edx@290
  int v176; // eax@291
  int v177; // edx@292
  int v178; // eax@293
  int v179; // edx@294
  int v180; // eax@295
  int v181; // edx@296
  int v182; // edx@298
  int v183; // ecx@299
  const char *v184; // ebx@302
  int *v185; // ecx@303
  char v186; // dl@305
  char v187; // ST18_1@306
  const char *v188; // ebx@307
  int *v189; // ecx@308
  char v190; // dl@310
  char v191; // ST18_1@311
  int v192; // ecx@312
  int v193; // edx@316
  int v194; // eax@317
  int v195; // edx@318
  int v196; // ecx@320
  int v197; // esi@324
  int v198; // edi@324
  int v199; // ebx@325
  int *v200; // ecx@326
  char v201; // dl@328
  char v202; // ST18_1@329
  int v203; // ebx@330
  signed int v204; // eax@340
  const char *v205; // ebx@340
  signed int v206; // ecx@341
  char v207; // dl@343
  char v208; // ST18_1@344
  _DWORD *v209; // ebx@347
  int v210; // eax@350
  int v211; // edx@351
  int v212; // eax@352
  int v213; // edx@353
  int v214; // eax@354
  int v215; // edx@355
  int v216; // eax@356
  int v217; // edx@357
  int v218; // eax@358
  int v219; // edx@359
  int v220; // edx@361
  int v221; // ecx@362
  int v222; // ecx@365
  int v223; // ecx@368
  const char *v224; // ebx@371
  int *v225; // ecx@372
  char v226; // dl@374
  char v227; // ST18_1@375
  int v228; // eax@376
  int v229; // edx@377
  int v230; // eax@378
  int v231; // edx@379
  int v232; // eax@380
  int v233; // edx@381
  int v234; // eax@382
  int v235; // edx@383
  int v236; // edx@385
  int v237; // ecx@386
  int v238; // ecx@389
  int v239; // ebx@389
  int v240; // edx@392
  int v241; // edx@398
  const char *v242; // ebx@404
  int *v243; // ecx@405
  char v244; // dl@407
  char v245; // ST18_1@408
  signed int v246; // eax@409
  const char *v247; // ebx@409
  signed int v248; // ecx@410
  char v249; // dl@412
  char v250; // ST18_1@413
  int v251; // ecx@414
  int v252; // ecx@417
  int v253; // ecx@421
  int v254; // edx@424
  int v255; // eax@425
  int v256; // ecx@429
  int v257; // edx@430
  int v258; // eax@431
  int v259; // edx@432
  int v260; // edx@434
  const char *v261; // ebx@436
  int *v262; // ecx@437
  char v263; // dl@439
  char v264; // ST18_1@440
  int v265; // esi@442
  int v266; // edi@442
  int v267; // ebx@443
  int *v268; // ecx@444
  char v269; // dl@446
  char v270; // ST18_1@447
  int v271; // edx@448
  int *v272; // ecx@448
  int v273; // ecx@453
  int v274; // edx@456
  int v275; // edx@458
  int v276; // ecx@467
  int v277; // ecx@470
  int v278; // edx@474
  int v279; // eax@475
  int v280; // edx@476
  int v281; // edx@478
  int v282; // ecx@479
  int v283; // ecx@482
  int v284; // ecx@485
  int v285; // ecx@488
  int v286; // ecx@491
  int v287; // ecx@494
  int v288; // ecx@497
  int v289; // ecx@500
  int v290; // ecx@503
  int v291; // ecx@511
  int v292; // eax@512
  int v293; // ecx@513
  int v294; // eax@514
  int v295; // ecx@515
  int v296; // eax@516
  int v297; // ecx@517
  int v298; // edx@519
  int v299; // ecx@522
  int v300; // edx@523
  int v301; // eax@524
  int v302; // edx@525
  int v303; // edx@527
  int v304; // eax@529
  int v305; // edx@530
  int v306; // esi@533
  int v307; // edi@533
  int v308; // ebx@534
  int *v309; // ecx@535
  char v310; // dl@537
  char v311; // ST18_1@538
  int v312; // edx@544
  bool v313; // zf@544
  int v314; // ebx@545
  _BYTE *v315; // esi@545
  const char *v316; // edi@545
  signed int v317; // ecx@545
  int v318; // edx@554
  bool v319; // zf@554
  int v320; // edx@554
  _BYTE *v321; // esi@555
  signed int v322; // ecx@555
  const char *v323; // edi@555
  int v324; // ecx@558
  bool v325; // zf@560
  int v326; // eax@561
  const char *v327; // edi@561
  signed int v328; // ecx@561
  _BYTE *v329; // esi@561
  signed int v330; // ecx@565
  _BYTE *v331; // esi@565
  const char *v332; // edi@565
  int v333; // edx@575
  int v334; // eax@580
  int v335; // edx@581
  int v336; // eax@582
  int v337; // edx@583
  int v338; // eax@584
  int v339; // edx@585
  int *v340; // edx@588
  int v341; // ebx@592
  int v342; // ecx@592
  const char *v343; // edi@595
  signed int v344; // ecx@595
  _BYTE *v345; // esi@595
  bool v346; // zf@601
  const char *v347; // edi@602
  signed int v348; // ecx@602
  _BYTE *v349; // esi@602
  const char *v350; // edi@606
  signed int v351; // ecx@606
  _BYTE *v352; // esi@606
  int v353; // eax@610
  int v354; // eax@612
  int v355; // edx@618
  int v356; // eax@619
  int *v357; // ecx@620
  int v358; // edx@624
  unsigned __int8 v359; // al@632
  bool v360; // cf@632
  int v361; // esi@661
  int v362; // edi@661
  int v363; // ebx@662
  int *v364; // ecx@663
  char v365; // dl@665
  char v366; // ST18_1@666
  int v367; // eax@760
  int v368; // ecx@760
  int v369; // edx@772
  char v370; // al@775
  _DWORD *v371; // ecx@778
  int v372; // ecx@789
  int v373; // edx@789
  _BYTE *v374; // ecx@810
  int v375; // ST18_4@854
  int v376; // ST18_4@855
  int v377; // ST18_4@856
  int v378; // ST18_4@857
  int v379; // ST18_4@858
  int v380; // ST18_4@859
  _BYTE *v381; // esi@866
  const char *v382; // edi@866
  signed int v383; // ecx@866
  int v384; // ST08_4@893
  int v385; // ecx@903
  int v386; // edx@918
  int *v387; // edx@922
  int *v388; // ebx@922
  unsigned int v389; // ebp@922
  int i; // eax@922
  int v391; // ecx@927
  char *v392; // esi@933
  int v393; // ebx@933
  int v394; // eax@936
  int v396; // [sp+1Ch] [bp-90h]@1
  int v397; // [sp+1Ch] [bp-90h]@27
  int v398; // [sp+1Ch] [bp-90h]@174
  int v399; // [sp+1Ch] [bp-90h]@545
  int v400; // [sp+20h] [bp-8Ch]@1
  unsigned int v401; // [sp+24h] [bp-88h]@54
  int v402; // [sp+24h] [bp-88h]@331
  _DWORD *v403; // [sp+24h] [bp-88h]@545
  _BYTE *v404; // [sp+24h] [bp-88h]@595
  _DWORD *v405; // [sp+28h] [bp-84h]@545
  unsigned int v406; // [sp+28h] [bp-84h]@915
  int v407; // [sp+34h] [bp-78h]@53
  int v408; // [sp+34h] [bp-78h]@330
  unsigned int v409; // [sp+38h] [bp-74h]@922
  int v410; // [sp+3Ch] [bp-70h]@922
  int v411; // [sp+48h] [bp-64h]@931
  int v412; // [sp+4Ch] [bp-60h]@940
  int v413; // [sp+50h] [bp-5Ch]@49
  int v414; // [sp+54h] [bp-58h]@49
  int v415; // [sp+58h] [bp-54h]@49
  int v416; // [sp+5Ch] [bp-50h]@49
  int *v417; // [sp+60h] [bp-4Ch]@333
  int v418; // [sp+64h] [bp-48h]@333
  int v419; // [sp+68h] [bp-44h]@333
  int v420; // [sp+6Ch] [bp-40h]@333
  int *v421; // [sp+70h] [bp-3Ch]@335
  int v422; // [sp+74h] [bp-38h]@335
  int v423; // [sp+78h] [bp-34h]@335
  int v424; // [sp+7Ch] [bp-30h]@335
  int *v425; // [sp+80h] [bp-2Ch]@337
  int v426; // [sp+84h] [bp-28h]@337
  int v427; // [sp+88h] [bp-24h]@337
  int v428; // [sp+8Ch] [bp-20h]@337
  char v429[28]; // [sp+90h] [bp-1Ch]@59

  v3 = a1;
  v400 = a2;
  v396 = a3;
  v4 = *(int **)a3;
  if ( *(_DWORD *)a3 > 0x46u )
  {
LABEL_2:
    *(_DWORD *)(v3 + 280) = 1;
    return (unsigned int)v4;
  }
  switch ( v4 )
  {
    default:
      goto LABEL_2;
    case 0x46u:
      v5 = *(_DWORD *)(a3 + 4);
      if ( v5 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, a2, v5);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      v6 = *(_DWORD *)(v3 + 256);
      if ( v6 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v7 = 1;
      }
      else
      {
        v7 = v6 + 1;
        *(_BYTE *)(v3 + v6) = 32;
        *(_DWORD *)(v3 + 256) = v6 + 1;
        *(_BYTE *)(v3 + 260) = 32;
        if ( v6 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 91;
          v8 = 1;
          goto LABEL_11;
        }
      }
      v8 = v7 + 1;
      *(_BYTE *)(v3 + v7) = 91;
      *(_DWORD *)(v3 + 256) = v7 + 1;
      *(_BYTE *)(v3 + 260) = 91;
      if ( v7 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v9 = 1;
        goto LABEL_12;
      }
LABEL_11:
      v9 = v8 + 1;
      *(_BYTE *)(v3 + v8) = 99;
      *(_DWORD *)(v3 + 256) = v8 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v8 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v10 = 1;
        goto LABEL_13;
      }
LABEL_12:
      v10 = v9 + 1;
      *(_BYTE *)(v3 + v9) = 108;
      *(_DWORD *)(v3 + 256) = v9 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v9 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v11 = 1;
        goto LABEL_14;
      }
LABEL_13:
      v11 = v10 + 1;
      *(_BYTE *)(v3 + v10) = 111;
      *(_DWORD *)(v3 + 256) = v10 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v10 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 110;
        v12 = 1;
        goto LABEL_15;
      }
LABEL_14:
      v12 = v11 + 1;
      *(_BYTE *)(v3 + v11) = 110;
      *(_DWORD *)(v3 + 256) = v11 + 1;
      *(_BYTE *)(v3 + 260) = 110;
      if ( v11 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v13 = 1;
        goto LABEL_16;
      }
LABEL_15:
      v13 = v12 + 1;
      *(_BYTE *)(v3 + v12) = 101;
      *(_DWORD *)(v3 + 256) = v12 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v12 != 254 )
      {
LABEL_16:
        v4 = (int *)(v13 + 1);
        goto LABEL_17;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(unsigned int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v4 = (int *)1;
      v13 = 0;
LABEL_17:
      *(_BYTE *)(v3 + v13) = 32;
      *(_DWORD *)(v3 + 256) = v4;
      *(_BYTE *)(v3 + 260) = 32;
      v14 = *(_DWORD *)(v396 + 8);
      if ( v14 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, v400, v14);
          v4 = *(int **)(v3 + 256);
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v15 = 1;
        v4 = 0;
      }
      else
      {
        v15 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 93;
      *(_DWORD *)(v3 + 256) = v15;
      *(_BYTE *)(v3 + 260) = 93;
      return (unsigned int)v4;
    case 0x45u:
      v4 = d_find_pack(v3, *(_DWORD *)(a3 + 4), a3);
      v16 = 0;
      if ( !v4 )
      {
        d_print_subexpr(v3, v400, *(_DWORD **)(v396 + 4));
        LOBYTE(v4) = d_append_string(v3, "...");
        return (unsigned int)v4;
      }
      while ( *v4 == 43 && v4[1] )
      {
        ++v16;
        v4 = (int *)v4[2];
        if ( !v4 )
        {
          v397 = *(_DWORD *)(v396 + 4);
          goto LABEL_28;
        }
      }
      v397 = *(_DWORD *)(v396 + 4);
      if ( !v16 )
        return (unsigned int)v4;
LABEL_28:
      v17 = v16 - 1;
      v18 = 0;
      LOBYTE(v4) = v397;
      if ( !v397 )
      {
        while ( 1 )
        {
          *(_DWORD *)(v3 + 284) = v18;
          *(_DWORD *)(v3 + 280) = 1;
          if ( v17 <= v18 )
            goto LABEL_460;
          v274 = *(_DWORD *)(v3 + 256);
          if ( v274 == 255 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            *(_BYTE *)v3 = 44;
            v4 = (int *)1;
          }
          else
          {
            v4 = (int *)(v274 + 1);
            *(_BYTE *)(v3 + v274) = 44;
            *(_DWORD *)(v3 + 256) = v274 + 1;
            *(_BYTE *)(v3 + 260) = 44;
            if ( v274 == 254 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v275 = 1;
              v4 = 0;
              goto LABEL_459;
            }
          }
          v275 = (int)v4 + 1;
LABEL_459:
          *((_BYTE *)v4 + v3) = 32;
          *(_DWORD *)(v3 + 256) = v275;
          *(_BYTE *)(v3 + 260) = 32;
LABEL_460:
          if ( ++v18 == v16 )
            return (unsigned int)v4;
        }
      }
      while ( 1 )
      {
        *(_DWORD *)(v3 + 284) = v18;
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v397);
        if ( v17 <= v18 )
          goto LABEL_30;
        v19 = *(_DWORD *)(v3 + 256);
        if ( v19 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 44;
          v4 = (int *)1;
        }
        else
        {
          v4 = (int *)(v19 + 1);
          *(_BYTE *)(v3 + v19) = 44;
          *(_DWORD *)(v3 + 256) = v19 + 1;
          *(_BYTE *)(v3 + 260) = 44;
          if ( v19 == 254 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            v20 = 1;
            v4 = 0;
            goto LABEL_37;
          }
        }
        v20 = (int)v4 + 1;
LABEL_37:
        *((_BYTE *)v4 + v3) = 32;
        *(_DWORD *)(v3 + 256) = v20;
        *(_BYTE *)(v3 + 260) = 32;
LABEL_30:
        if ( ++v18 == v16 )
          return (unsigned int)v4;
      }
    case 0x2Au:
    case 0x2Bu:
      v21 = *(_DWORD *)(a3 + 4);
      if ( v21 && !*(_DWORD *)(v3 + 280) )
        d_print_comp_part_8(v3, a2, v21);
      v4 = *(int **)(v396 + 8);
      if ( !v4 )
        return (unsigned int)v4;
      v22 = *(_DWORD *)(v3 + 256);
      if ( v22 > 0xFD )
      {
        *(_BYTE *)(v3 + v22) = 0;
        (*(void (__cdecl **)(unsigned int, unsigned int, _DWORD))(v3 + 264))(v3, v22, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v22 = 0;
      }
      *(_BYTE *)(v3 + v22) = 44;
      *(_BYTE *)(v3 + v22 + 1) = 32;
      *(_DWORD *)(v3 + 256) = v22 + 2;
      *(_BYTE *)(v3 + 260) = 32;
      v23 = *(_DWORD *)(v3 + 288);
      LOBYTE(v4) = v396;
      v24 = *(_DWORD *)(v396 + 8);
      if ( v24 )
      {
        v4 = *(int **)(v3 + 280);
        if ( v4 )
          goto LABEL_48;
        LOBYTE(v4) = d_print_comp_part_8(v3, v400, v24);
        if ( v23 != *(_DWORD *)(v3 + 288) )
          return (unsigned int)v4;
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( *(_DWORD *)(v3 + 256) != v22 + 2 )
        return (unsigned int)v4;
LABEL_48:
      *(_DWORD *)(v3 + 256) = v22;
      return (unsigned int)v4;
    case 0x27u:
    case 0x29u:
      v413 = *(_DWORD *)(v3 + 276);
      *(_DWORD *)(v3 + 276) = &v413;
      v414 = a3;
      v415 = 0;
      v416 = *(_DWORD *)(v3 + 272);
      v25 = *(_DWORD *)(a3 + 8);
      if ( v25 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, a2, v25);
          if ( v415 )
          {
LABEL_52:
            LOBYTE(v4) = v413;
            *(_DWORD *)(v3 + 276) = v413;
            return (unsigned int)v4;
          }
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      d_print_mod(v3, v400, v396);
      goto LABEL_52;
    case 0x26u:
      v413 = *(_DWORD *)(v3 + 276);
      v407 = v413;
      *(_DWORD *)(v3 + 276) = &v413;
      v414 = a3;
      v415 = 0;
      v4 = *(int **)(v3 + 272);
      v416 = *(_DWORD *)(v3 + 272);
      if ( v407 )
      {
        v4 = (int *)(**(_DWORD **)(v407 + 4) - 23);
        v401 = 1;
        if ( (unsigned int)v4 <= 2 )
        {
          v4 = &v413;
          v26 = v407;
          v27 = &v413;
          do
          {
            if ( !*(_DWORD *)(v26 + 8) )
            {
              if ( v401 > 3 )
              {
                *(_DWORD *)(v3 + 280) = 1;
                return (unsigned int)v4;
              }
              v4 = (int *)&v429[16 * v401];
              qmemcpy(v4 - 16, (const void *)v26, 0x10u);
              *(v4 - 16) = (int)v27;
              v27 = &v413 + 4 * v401;
              LOBYTE(v4) = v3;
              *(_DWORD *)(v3 + 276) = v27;
              *(_DWORD *)(v26 + 8) = 1;
              ++v401;
            }
            v26 = *(_DWORD *)v26;
            if ( !v26 )
              break;
            v4 = (int *)(**(_DWORD **)(v26 + 4) - 23);
          }
          while ( (unsigned int)v4 <= 2 );
        }
      }
      else
      {
        v401 = 1;
      }
      v28 = *(_DWORD *)(a3 + 8);
      if ( v28 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v28);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      *(_DWORD *)(v3 + 276) = v407;
      if ( !v415 )
      {
        if ( v401 != 1 )
        {
          v29 = v401 - 1;
          v30 = &v413 + 4 * (v401 - 1) + 1;
          while ( 1 )
          {
            d_print_mod(v3, v400, *v30);
            v30 -= 4;
            if ( v29 == 1 )
              break;
            --v29;
          }
          v407 = *(_DWORD *)(v3 + 276);
        }
        LOBYTE(v4) = d_print_array_type_isra_7(v3, v400, (_DWORD *)(v396 + 4), v407);
      }
      return (unsigned int)v4;
    case 0x3Du:
      v31 = *(_DWORD *)(v3 + 256);
      if ( v31 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 100;
        v32 = 1;
      }
      else
      {
        v32 = v31 + 1;
        *(_BYTE *)(v3 + v31) = 100;
        *(_DWORD *)(v3 + 256) = v31 + 1;
        *(_BYTE *)(v3 + 260) = 100;
        if ( v31 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 101;
          v33 = 1;
          goto LABEL_72;
        }
      }
      v33 = v32 + 1;
      *(_BYTE *)(v3 + v32) = 101;
      *(_DWORD *)(v3 + 256) = v32 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v32 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v34 = 1;
        goto LABEL_73;
      }
LABEL_72:
      v34 = v33 + 1;
      *(_BYTE *)(v3 + v33) = 99;
      *(_DWORD *)(v3 + 256) = v33 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v33 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v35 = 1;
        goto LABEL_74;
      }
LABEL_73:
      v35 = v34 + 1;
      *(_BYTE *)(v3 + v34) = 108;
      *(_DWORD *)(v3 + 256) = v34 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v34 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v36 = 1;
        goto LABEL_75;
      }
LABEL_74:
      v36 = v35 + 1;
      *(_BYTE *)(v3 + v35) = 116;
      *(_DWORD *)(v3 + 256) = v35 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v35 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 121;
        v37 = 1;
        goto LABEL_76;
      }
LABEL_75:
      v37 = v36 + 1;
      *(_BYTE *)(v3 + v36) = 121;
      *(_DWORD *)(v3 + 256) = v36 + 1;
      *(_BYTE *)(v3 + 260) = 121;
      if ( v36 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 112;
        v38 = 1;
        goto LABEL_77;
      }
LABEL_76:
      v38 = v37 + 1;
      *(_BYTE *)(v3 + v37) = 112;
      *(_DWORD *)(v3 + 256) = v37 + 1;
      *(_BYTE *)(v3 + 260) = 112;
      if ( v37 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v39 = 1;
        goto LABEL_78;
      }
LABEL_77:
      v39 = v38 + 1;
      *(_BYTE *)(v3 + v38) = 101;
      *(_DWORD *)(v3 + 256) = v38 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v38 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v40 = 1;
        goto LABEL_79;
      }
LABEL_78:
      v40 = v39 + 1;
      *(_BYTE *)(v3 + v39) = 32;
      *(_DWORD *)(v3 + 256) = v39 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v39 != 254 )
      {
LABEL_79:
        v4 = (int *)(v40 + 1);
        goto LABEL_80;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v4 = (int *)1;
      v40 = 0;
LABEL_80:
      *(_BYTE *)(v3 + v40) = 40;
      *(_DWORD *)(v3 + 256) = v4;
      *(_BYTE *)(v3 + 260) = 40;
      v41 = *(_DWORD *)(v396 + 4);
      if ( v41 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, v400, v41);
          v4 = *(int **)(v3 + 256);
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v42 = 1;
        v4 = 0;
      }
      else
      {
        v42 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 41;
      *(_DWORD *)(v3 + 256) = v42;
      *(_BYTE *)(v3 + 260) = 41;
      return (unsigned int)v4;
    case 0x10u:
      v43 = *(_DWORD *)(v3 + 256);
      if ( v43 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 118;
        v44 = 1;
      }
      else
      {
        v44 = v43 + 1;
        *(_BYTE *)(v3 + v43) = 118;
        *(_DWORD *)(v3 + 256) = v43 + 1;
        *(_BYTE *)(v3 + 260) = 118;
        if ( v43 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 105;
          v45 = 1;
          goto LABEL_89;
        }
      }
      v45 = v44 + 1;
      *(_BYTE *)(v3 + v44) = 105;
      *(_DWORD *)(v3 + 256) = v44 + 1;
      *(_BYTE *)(v3 + 260) = 105;
      if ( v44 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v46 = 1;
        goto LABEL_90;
      }
LABEL_89:
      v46 = v45 + 1;
      *(_BYTE *)(v3 + v45) = 114;
      *(_DWORD *)(v3 + 256) = v45 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v45 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v47 = 1;
        goto LABEL_91;
      }
LABEL_90:
      v47 = v46 + 1;
      *(_BYTE *)(v3 + v46) = 116;
      *(_DWORD *)(v3 + 256) = v46 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v46 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 117;
        v48 = 1;
        goto LABEL_92;
      }
LABEL_91:
      v48 = v47 + 1;
      *(_BYTE *)(v3 + v47) = 117;
      *(_DWORD *)(v3 + 256) = v47 + 1;
      *(_BYTE *)(v3 + 260) = 117;
      if ( v47 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v49 = 1;
        goto LABEL_93;
      }
LABEL_92:
      v49 = v48 + 1;
      *(_BYTE *)(v3 + v48) = 97;
      *(_DWORD *)(v3 + 256) = v48 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v48 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v50 = 1;
        goto LABEL_94;
      }
LABEL_93:
      v50 = v49 + 1;
      *(_BYTE *)(v3 + v49) = 108;
      *(_DWORD *)(v3 + 256) = v49 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v49 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v51 = 1;
        goto LABEL_95;
      }
LABEL_94:
      v51 = v50 + 1;
      *(_BYTE *)(v3 + v50) = 32;
      *(_DWORD *)(v3 + 256) = v50 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v50 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v52 = 1;
        goto LABEL_96;
      }
LABEL_95:
      v52 = v51 + 1;
      *(_BYTE *)(v3 + v51) = 116;
      *(_DWORD *)(v3 + 256) = v51 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v51 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 104;
        v53 = 1;
        goto LABEL_97;
      }
LABEL_96:
      v53 = v52 + 1;
      *(_BYTE *)(v3 + v52) = 104;
      *(_DWORD *)(v3 + 256) = v52 + 1;
      *(_BYTE *)(v3 + 260) = 104;
      if ( v52 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 117;
        v54 = 1;
        goto LABEL_98;
      }
LABEL_97:
      v54 = v53 + 1;
      *(_BYTE *)(v3 + v53) = 117;
      *(_DWORD *)(v3 + 256) = v53 + 1;
      *(_BYTE *)(v3 + 260) = 117;
      if ( v53 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 110;
        v55 = 1;
        goto LABEL_99;
      }
LABEL_98:
      v55 = v54 + 1;
      *(_BYTE *)(v3 + v54) = 110;
      *(_DWORD *)(v3 + 256) = v54 + 1;
      *(_BYTE *)(v3 + 260) = 110;
      if ( v54 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 107;
        v56 = 1;
        goto LABEL_100;
      }
LABEL_99:
      v56 = v55 + 1;
      *(_BYTE *)(v3 + v55) = 107;
      *(_DWORD *)(v3 + 256) = v55 + 1;
      *(_BYTE *)(v3 + 260) = 107;
      if ( v55 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v57 = 1;
        goto LABEL_101;
      }
LABEL_100:
      v57 = v56 + 1;
      *(_BYTE *)(v3 + v56) = 32;
      *(_DWORD *)(v3 + 256) = v56 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v56 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v58 = 1;
        goto LABEL_102;
      }
LABEL_101:
      v58 = v57 + 1;
      *(_BYTE *)(v3 + v57) = 116;
      *(_DWORD *)(v3 + 256) = v57 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v57 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v4 = (int *)1;
        goto LABEL_103;
      }
LABEL_102:
      v4 = (int *)(v58 + 1);
      *(_BYTE *)(v3 + v58) = 111;
      *(_DWORD *)(v3 + 256) = v58 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v58 != 254 )
      {
LABEL_103:
        v59 = (int)v4 + 1;
        goto LABEL_104;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v59 = 1;
      v4 = 0;
LABEL_104:
      *((_BYTE *)v4 + v3) = 32;
      *(_DWORD *)(v3 + 256) = v59;
      *(_BYTE *)(v3 + 260) = 32;
      LOBYTE(v4) = v396;
      v60 = *(_DWORD *)(v396 + 4);
      if ( v60 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v60);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x42u:
      d_append_string(v3, "{unnamed type#");
      d_append_num(v3, *(_DWORD *)(v396 + 4) + 1);
      v4 = *(int **)(v3 + 256);
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v61 = 1;
        v4 = 0;
      }
      else
      {
        v61 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 125;
      *(_DWORD *)(v3 + 256) = v61;
      *(_BYTE *)(v3 + 260) = 125;
      return (unsigned int)v4;
    case 0x40u:
      d_append_string(v3, "{lambda(");
      v62 = *(_DWORD *)(v396 + 4);
      if ( v62 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, v400, v62);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      d_append_string(v3, ")#");
      d_append_num(v3, *(_DWORD *)(v396 + 8) + 1);
      v4 = *(int **)(v3 + 256);
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v63 = 1;
        v4 = 0;
      }
      else
      {
        v63 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 125;
      *(_DWORD *)(v3 + 256) = v63;
      *(_BYTE *)(v3 + 260) = 125;
      return (unsigned int)v4;
    case 0x33u:
      *(_DWORD *)(v3 + 280) = 1;
      return (unsigned int)v4;
    case 0x39u:
      v64 = *(_DWORD *)(v3 + 256);
      if ( v64 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 106;
        v65 = 1;
      }
      else
      {
        v65 = v64 + 1;
        *(_BYTE *)(v3 + v64) = 106;
        *(_DWORD *)(v3 + 256) = v64 + 1;
        *(_BYTE *)(v3 + 260) = 106;
        if ( v64 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 97;
          v66 = 1;
          goto LABEL_120;
        }
      }
      v66 = v65 + 1;
      *(_BYTE *)(v3 + v65) = 97;
      *(_DWORD *)(v3 + 256) = v65 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v65 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 118;
        v67 = 1;
        goto LABEL_121;
      }
LABEL_120:
      v67 = v66 + 1;
      *(_BYTE *)(v3 + v66) = 118;
      *(_DWORD *)(v3 + 256) = v66 + 1;
      *(_BYTE *)(v3 + 260) = 118;
      if ( v66 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v68 = 1;
        goto LABEL_122;
      }
LABEL_121:
      v68 = v67 + 1;
      *(_BYTE *)(v3 + v67) = 97;
      *(_DWORD *)(v3 + 256) = v67 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v67 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v69 = 1;
        goto LABEL_123;
      }
LABEL_122:
      v69 = v68 + 1;
      *(_BYTE *)(v3 + v68) = 32;
      *(_DWORD *)(v3 + 256) = v68 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v68 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v70 = 1;
        goto LABEL_124;
      }
LABEL_123:
      v70 = v69 + 1;
      *(_BYTE *)(v3 + v69) = 114;
      *(_DWORD *)(v3 + 256) = v69 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v69 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v71 = 1;
        goto LABEL_125;
      }
LABEL_124:
      v71 = v70 + 1;
      *(_BYTE *)(v3 + v70) = 101;
      *(_DWORD *)(v3 + 256) = v70 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v70 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 115;
        v72 = 1;
        goto LABEL_126;
      }
LABEL_125:
      v72 = v71 + 1;
      *(_BYTE *)(v3 + v71) = 115;
      *(_DWORD *)(v3 + 256) = v71 + 1;
      *(_BYTE *)(v3 + 260) = 115;
      if ( v71 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v73 = 1;
        goto LABEL_127;
      }
LABEL_126:
      v73 = v72 + 1;
      *(_BYTE *)(v3 + v72) = 111;
      *(_DWORD *)(v3 + 256) = v72 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v72 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 117;
        v74 = 1;
        goto LABEL_128;
      }
LABEL_127:
      v74 = v73 + 1;
      *(_BYTE *)(v3 + v73) = 117;
      *(_DWORD *)(v3 + 256) = v73 + 1;
      *(_BYTE *)(v3 + 260) = 117;
      if ( v73 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v75 = 1;
        goto LABEL_129;
      }
LABEL_128:
      v75 = v74 + 1;
      *(_BYTE *)(v3 + v74) = 114;
      *(_DWORD *)(v3 + 256) = v74 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v74 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v76 = 1;
        goto LABEL_130;
      }
LABEL_129:
      v76 = v75 + 1;
      *(_BYTE *)(v3 + v75) = 99;
      *(_DWORD *)(v3 + 256) = v75 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v75 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v4 = (int *)1;
        goto LABEL_131;
      }
LABEL_130:
      v4 = (int *)(v76 + 1);
      *(_BYTE *)(v3 + v76) = 101;
      *(_DWORD *)(v3 + 256) = v76 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v76 != 254 )
      {
LABEL_131:
        v77 = (int)v4 + 1;
        goto LABEL_132;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v77 = 1;
      v4 = 0;
LABEL_132:
      *((_BYTE *)v4 + v3) = 32;
      *(_DWORD *)(v3 + 256) = v77;
      *(_BYTE *)(v3 + 260) = 32;
      LOBYTE(v4) = v396;
      v78 = *(_DWORD *)(v396 + 4);
      if ( v78 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v78);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x37u:
    case 0x38u:
      v79 = *(_DWORD *)(a3 + 4);
      if ( *(_DWORD *)v79 != 35 )
      {
        v80 = 0;
        goto LABEL_139;
      }
      v80 = *(_DWORD *)(*(_DWORD *)(v79 + 4) + 16);
      if ( v80 < 1 )
        goto LABEL_139;
      if ( v80 > 6 )
      {
        if ( v80 == 7 )
        {
          v369 = *(_DWORD *)(a3 + 8);
          if ( !*(_DWORD *)v369 && *(_DWORD *)(v369 + 8) == 1 && v4 == (int *)55 )
          {
            v370 = **(_BYTE **)(v369 + 4);
            if ( v370 == 48 )
            {
              LOBYTE(v4) = d_append_string(v3, "false");
              return (unsigned int)v4;
            }
            if ( v370 == 49 )
            {
              LOBYTE(v4) = d_append_string(v3, "true");
              return (unsigned int)v4;
            }
          }
        }
LABEL_139:
        v81 = *(_DWORD *)(v3 + 256);
        if ( v81 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v82 = 1;
          v81 = 0;
        }
        else
        {
          v82 = v81 + 1;
        }
        *(_BYTE *)(v3 + v81) = 40;
        *(_DWORD *)(v3 + 256) = v82;
        *(_BYTE *)(v3 + 260) = 40;
        v83 = *(_DWORD *)(v396 + 4);
        if ( v83 )
        {
          if ( !*(_DWORD *)(v3 + 280) )
          {
            d_print_comp_part_8(v3, v400, v83);
            v82 = *(_DWORD *)(v3 + 256);
          }
        }
        else
        {
          *(_DWORD *)(v3 + 280) = 1;
        }
        if ( v82 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 41;
          *(_DWORD *)(v3 + 256) = 1;
          *(_BYTE *)(v3 + 260) = 41;
          if ( *(_DWORD *)v396 != 56 )
          {
            if ( v80 != 8 )
              goto LABEL_147;
            v84 = 1;
            goto LABEL_768;
          }
          v84 = 1;
        }
        else
        {
          v84 = v82 + 1;
          *(_BYTE *)(v3 + v82) = 41;
          *(_DWORD *)(v3 + 256) = v82 + 1;
          *(_BYTE *)(v3 + 260) = 41;
          if ( *(_DWORD *)v396 != 56 )
          {
LABEL_146:
            if ( v80 != 8 )
            {
LABEL_147:
              LOBYTE(v4) = v396;
              v85 = *(_DWORD *)(v396 + 8);
              if ( v85 )
              {
                v4 = *(int **)(v3 + 280);
                if ( !v4 )
                  LOBYTE(v4) = d_print_comp_part_8(v3, v400, v85);
              }
              else
              {
                *(_DWORD *)(v3 + 280) = 1;
              }
              if ( v80 == 8 )
              {
                v86 = *(_DWORD *)(v3 + 256);
                if ( v86 == 255 )
                {
                  *(_BYTE *)(v3 + 255) = 0;
                  (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
                  ++*(_DWORD *)(v3 + 288);
                  v86 = 0;
                }
                *(_BYTE *)(v3 + v86) = 93;
                v4 = (int *)(v86 + 1);
                *(_DWORD *)(v3 + 256) = v4;
                *(_BYTE *)(v3 + 260) = 93;
              }
              return (unsigned int)v4;
            }
            if ( v84 == 255 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v84 = 0;
            }
LABEL_768:
            *(_BYTE *)(v3 + v84) = 91;
            *(_DWORD *)(v3 + 256) = v84 + 1;
            *(_BYTE *)(v3 + 260) = 91;
            goto LABEL_147;
          }
          if ( v84 == 255 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            v84 = 0;
          }
        }
        *(_BYTE *)(v3 + v84++) = 45;
        *(_DWORD *)(v3 + 256) = v84;
        *(_BYTE *)(v3 + 260) = 45;
        goto LABEL_146;
      }
      v371 = *(_DWORD **)(a3 + 8);
      if ( *v371 )
        goto LABEL_139;
      if ( v4 == (int *)56 )
      {
        d_append_char(v3, 45);
        v371 = *(_DWORD **)(v396 + 8);
      }
      LOBYTE(v4) = d_print_comp(v3, v400, (int)v371);
      switch ( v80 )
      {
        default:
          return (unsigned int)v4;
        case 6u:
          LOBYTE(v4) = d_append_string(v3, "ull");
          break;
        case 5u:
          LOBYTE(v4) = d_append_string(v3, "ll");
          break;
        case 4u:
          LOBYTE(v4) = d_append_string(v3, "ul");
          break;
        case 3u:
          LOBYTE(v4) = d_append_char(v3, 108);
          break;
        case 2u:
          LOBYTE(v4) = d_append_char(v3, 117);
          break;
      }
      return (unsigned int)v4;
    case 0x35u:
    case 0x36u:
      *(_DWORD *)(v3 + 280) = 1;
      return (unsigned int)v4;
    case 0x34u:
      v4 = *(int **)(a3 + 8);
      if ( *v4 != 53 || (v312 = v4[2], v313 = *(_DWORD *)v312 == 54, *(_DWORD *)v312 != 54) )
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      else
      {
        v314 = *(_DWORD *)(a3 + 4);
        v399 = v4[1];
        v405 = *(_DWORD **)(v312 + 4);
        v403 = *(_DWORD **)(v312 + 8);
        v315 = **(_BYTE ***)(v314 + 4);
        v316 = "qu";
        v317 = 3;
        do
        {
          if ( !v317 )
            break;
          v313 = *v315++ == *v316++;
          --v317;
        }
        while ( v313 );
        if ( v313 )
        {
          d_print_subexpr(v3, v400, (_DWORD *)v399);
          d_print_expr_op(v3, v400, v314);
          d_print_subexpr(v3, v400, v405);
          d_append_string(v3, " : ");
          LOBYTE(v4) = d_print_subexpr(v3, v400, v403);
        }
        else
        {
          d_append_string(v3, "new ");
          if ( *(_DWORD *)(v399 + 4) )
          {
            d_print_subexpr(v3, v400, (_DWORD *)v399);
            d_append_char(v3, 32);
          }
          LOBYTE(v4) = d_print_comp(v3, v400, (int)v405);
          if ( v403 )
            LOBYTE(v4) = d_print_subexpr(v3, v400, v403);
        }
      }
      return (unsigned int)v4;
    case 0x3Bu:
      v87 = *(_BYTE *)(a3 + 4);
      v4 = *(int **)(v3 + 256);
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v88 = 1;
        v4 = 0;
      }
      else
      {
        v88 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = v87;
      *(_DWORD *)(v3 + 256) = v88;
      *(_BYTE *)(v3 + 260) = v87;
      return (unsigned int)v4;
    case 0x2Fu:
      v89 = *(_DWORD *)(v3 + 256);
      if ( v89 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v90 = 1;
      }
      else
      {
        v90 = v89 + 1;
        *(_BYTE *)(v3 + v89) = 111;
        *(_DWORD *)(v3 + 256) = v89 + 1;
        *(_BYTE *)(v3 + 260) = 111;
        if ( v89 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 112;
          v91 = 1;
          goto LABEL_163;
        }
      }
      v91 = v90 + 1;
      *(_BYTE *)(v3 + v90) = 112;
      *(_DWORD *)(v3 + 256) = v90 + 1;
      *(_BYTE *)(v3 + 260) = 112;
      if ( v90 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v92 = 1;
        goto LABEL_164;
      }
LABEL_163:
      v92 = v91 + 1;
      *(_BYTE *)(v3 + v91) = 101;
      *(_DWORD *)(v3 + 256) = v91 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v91 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v93 = 1;
        goto LABEL_165;
      }
LABEL_164:
      v93 = v92 + 1;
      *(_BYTE *)(v3 + v92) = 114;
      *(_DWORD *)(v3 + 256) = v92 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v92 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v94 = 1;
        goto LABEL_166;
      }
LABEL_165:
      v94 = v93 + 1;
      *(_BYTE *)(v3 + v93) = 97;
      *(_DWORD *)(v3 + 256) = v93 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v93 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v95 = 1;
        goto LABEL_167;
      }
LABEL_166:
      v95 = v94 + 1;
      *(_BYTE *)(v3 + v94) = 116;
      *(_DWORD *)(v3 + 256) = v94 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v94 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v96 = 1;
        goto LABEL_168;
      }
LABEL_167:
      v96 = v95 + 1;
      *(_BYTE *)(v3 + v95) = 111;
      *(_DWORD *)(v3 + 256) = v95 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v95 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v97 = 1;
        goto LABEL_169;
      }
LABEL_168:
      v97 = v96 + 1;
      *(_BYTE *)(v3 + v96) = 114;
      *(_DWORD *)(v3 + 256) = v96 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v96 != 254 )
      {
LABEL_169:
        v98 = v97 + 1;
        goto LABEL_170;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v98 = 1;
      v97 = 0;
LABEL_170:
      *(_BYTE *)(v3 + v97) = 32;
      *(_DWORD *)(v3 + 256) = v98;
      *(_BYTE *)(v3 + 260) = 32;
      v99 = *(_DWORD **)(v396 + 4);
      if ( *v99 == 4 )
      {
        LOBYTE(v4) = d_print_cast_isra_10_part_11(v3, v400, (int *)(v396 + 4));
      }
      else
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, (int)v99);
      }
      return (unsigned int)v4;
    case 0x3Cu:
      LOBYTE(v4) = d_append_num(v3, *(_DWORD *)(a3 + 4));
      return (unsigned int)v4;
    case 0x31u:
      v100 = *(_DWORD *)(a3 + 4);
      v398 = *(_DWORD *)(a3 + 8);
      v101 = *(_DWORD *)v100 == 45;
      if ( *(_DWORD *)v100 != 45 )
      {
        if ( *(_DWORD *)v100 == 47 )
        {
          v355 = *(_DWORD *)(v3 + 256);
          if ( v355 == 255 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            v356 = 1;
            v355 = 0;
          }
          else
          {
            v356 = v355 + 1;
          }
          *(_BYTE *)(v3 + v355) = 40;
          *(_DWORD *)(v3 + 256) = v356;
          *(_BYTE *)(v3 + 260) = 40;
          v357 = (int *)(v100 + 4);
          if ( **(_DWORD **)(v100 + 4) == 4 )
          {
            d_print_cast_isra_10_part_11(v3, v400, v357);
            v356 = *(_DWORD *)(v3 + 256);
          }
          else if ( !*(_DWORD *)(v3 + 280) )
          {
            d_print_comp_part_8(v3, v400, *(_DWORD *)(v100 + 4));
            v356 = *(_DWORD *)(v3 + 256);
          }
          if ( v356 == 255 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            v384 = *(_DWORD *)(v3 + 268);
            (*(void (__fastcall **)(int *))(v3 + 264))(v357);
            ++*(_DWORD *)(v3 + 288);
            v358 = 1;
            v356 = 0;
          }
          else
          {
            v358 = v356 + 1;
          }
          *(_BYTE *)(v3 + v356) = 41;
          *(_DWORD *)(v3 + 256) = v358;
          *(_BYTE *)(v3 + 260) = 41;
        }
        else if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, a2, v100);
        }
        goto LABEL_178;
      }
      v404 = **(_BYTE ***)(v100 + 4);
      v343 = "ad";
      v344 = 3;
      v345 = **(_BYTE ***)(v100 + 4);
      do
      {
        if ( !v344 )
          break;
        v101 = *v345++ == *v343++;
        --v344;
      }
      while ( v101 );
      if ( v101 && *(_DWORD *)v398 == 3 )
      {
        if ( **(_DWORD **)(v398 + 4) == 1 && **(_DWORD **)(v398 + 8) == 37 )
          v398 = *(_DWORD *)(v398 + 4);
      }
      else if ( *(_DWORD *)v398 == 51 )
      {
        d_print_subexpr(v3, a2, *(_DWORD **)(v398 + 4));
        LOBYTE(v4) = d_print_expr_op(v3, v400, v100);
        return (unsigned int)v4;
      }
      d_print_expr_op_part_12(v3, v100);
      LOBYTE(v4) = (_BYTE)v404;
      v346 = v404 == 0;
      if ( !v404 )
        goto LABEL_178;
      v347 = "gs";
      v348 = 3;
      v349 = v404;
      do
      {
        if ( !v348 )
          break;
        v346 = *v349++ == *v347++;
        --v348;
      }
      while ( v346 );
      if ( v346 )
      {
        if ( v398 )
        {
          if ( !*(_DWORD *)(v3 + 280) )
            LOBYTE(v4) = d_print_comp_part_8(v3, v400, v398);
        }
        else
        {
          *(_DWORD *)(v3 + 280) = 1;
        }
      }
      else
      {
        v350 = "st";
        v351 = 3;
        v352 = v404;
        do
        {
          if ( !v351 )
            break;
          v346 = *v352++ == *v350++;
          --v351;
        }
        while ( v346 );
        if ( !v346 )
        {
LABEL_178:
          LOBYTE(v4) = d_print_subexpr(v3, v400, (_DWORD *)v398);
          return (unsigned int)v4;
        }
        v353 = *(_DWORD *)(v3 + 256);
        if ( v353 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v353 = 0;
        }
        *(_BYTE *)(v3 + v353) = 40;
        v354 = v353 + 1;
        *(_DWORD *)(v3 + 256) = v354;
        *(_BYTE *)(v3 + 260) = 40;
        if ( v398 )
        {
          if ( !*(_DWORD *)(v3 + 280) )
          {
            d_print_comp_part_8(v3, v400, v398);
            v354 = *(_DWORD *)(v3 + 256);
          }
        }
        else
        {
          *(_DWORD *)(v3 + 280) = 1;
        }
        if ( v354 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v354 = 0;
        }
        *(_BYTE *)(v3 + v354) = 41;
        v4 = (int *)(v354 + 1);
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = 41;
      }
      return (unsigned int)v4;
    case 0x30u:
      v102 = *(_DWORD *)(a3 + 4);
      if ( *(_DWORD *)v102 == 45 )
      {
        v4 = *(int **)(v102 + 4);
        v361 = v4[2];
        v362 = v4[1];
        if ( v361 )
        {
          v4 = *(int **)(v3 + 256);
          v363 = 0;
          do
          {
            v365 = *(_BYTE *)(v362 + v363);
            if ( v4 == (int *)255 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              v366 = v365;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v4 = (int *)1;
              v364 = 0;
              v365 = v366;
            }
            else
            {
              v364 = v4;
              v4 = (int *)((char *)v4 + 1);
            }
            *((_BYTE *)v364 + v3) = v365;
            *(_DWORD *)(v3 + 256) = v4;
            *(_BYTE *)(v3 + 260) = v365;
            ++v363;
          }
          while ( v361 != v363 );
        }
      }
      else
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, a2, v102);
      }
      return (unsigned int)v4;
    case 0x32u:
      v4 = *(int **)(a3 + 8);
      if ( *v4 == 51 )
      {
        v318 = *(_DWORD *)(a3 + 4);
        v319 = *(_DWORD *)v318 == 45;
        v320 = *(_DWORD *)(v318 + 4);
        if ( v319 )
        {
          v319 = *(_DWORD *)(v320 + 8) == 1;
          if ( *(_DWORD *)(v320 + 8) == 1 )
          {
            v374 = *(_BYTE **)(v320 + 4);
            v319 = *v374 == 62;
            if ( *v374 == 62 )
            {
              d_append_char(v3, 40);
              v320 = *(_DWORD *)(*(_DWORD *)(v396 + 4) + 4);
              v4 = *(int **)(v396 + 8);
            }
          }
        }
        v321 = *(_BYTE **)v320;
        v322 = 3;
        v323 = "cl";
        do
        {
          if ( !v322 )
            break;
          v319 = *v321++ == *v323++;
          --v322;
        }
        while ( v319 );
        v324 = v4[1];
        if ( v319 && *(_DWORD *)v324 == 3 )
        {
          if ( **(_DWORD **)(v324 + 8) != 37 )
            *(_DWORD *)(v3 + 280) = 1;
          d_print_subexpr(v3, v400, *(_DWORD **)(v324 + 4));
        }
        else
        {
          d_print_subexpr(v3, v400, (_DWORD *)v324);
        }
        v326 = *(_DWORD *)(v396 + 4);
        v327 = "ix";
        v328 = 3;
        v329 = **(_BYTE ***)(v326 + 4);
        do
        {
          if ( !v328 )
            break;
          v325 = *v329++ == *v327++;
          --v328;
        }
        while ( v325 );
        if ( v325 )
        {
          d_append_char(v3, 91);
          d_print_comp(v3, v400, *(_DWORD *)(*(_DWORD *)(v396 + 8) + 8));
          d_append_char(v3, 93);
        }
        else
        {
          v330 = 3;
          v331 = **(_BYTE ***)(v326 + 4);
          v332 = "cl";
          do
          {
            if ( !v330 )
              break;
            v325 = *v331++ == *v332++;
            --v330;
          }
          while ( v325 );
          if ( !v325 )
            d_print_expr_op(v3, v400, *(_DWORD *)(v396 + 4));
          d_print_subexpr(v3, v400, *(_DWORD **)(*(_DWORD *)(v396 + 8) + 8));
        }
        v4 = *(int **)(v396 + 4);
        if ( *v4 == 45 )
        {
          v4 = (int *)v4[1];
          if ( v4[2] == 1 )
          {
            v4 = (int *)v4[1];
            if ( *(_BYTE *)v4 == 62 )
              LOBYTE(v4) = d_append_char(v3, 41);
          }
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x2Du:
      v103 = *(_DWORD *)(a3 + 4);
      v104 = *(_DWORD *)(v103 + 8);
      v105 = *(_DWORD *)(v3 + 256);
      if ( v105 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v106 = 1;
      }
      else
      {
        v106 = v105 + 1;
        *(_BYTE *)(v3 + v105) = 111;
        *(_DWORD *)(v3 + 256) = v105 + 1;
        *(_BYTE *)(v3 + 260) = 111;
        if ( v105 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 112;
          v107 = 1;
          goto LABEL_187;
        }
      }
      v107 = v106 + 1;
      *(_BYTE *)(v3 + v106) = 112;
      *(_DWORD *)(v3 + 256) = v106 + 1;
      *(_BYTE *)(v3 + 260) = 112;
      if ( v106 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v108 = 1;
        goto LABEL_188;
      }
LABEL_187:
      v108 = v107 + 1;
      *(_BYTE *)(v3 + v107) = 101;
      *(_DWORD *)(v3 + 256) = v107 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v107 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v109 = 1;
        goto LABEL_189;
      }
LABEL_188:
      v109 = v108 + 1;
      *(_BYTE *)(v3 + v108) = 114;
      *(_DWORD *)(v3 + 256) = v108 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v108 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v110 = 1;
        goto LABEL_190;
      }
LABEL_189:
      v110 = v109 + 1;
      *(_BYTE *)(v3 + v109) = 97;
      *(_DWORD *)(v3 + 256) = v109 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v109 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v111 = 1;
        goto LABEL_191;
      }
LABEL_190:
      v111 = v110 + 1;
      *(_BYTE *)(v3 + v110) = 116;
      *(_DWORD *)(v3 + 256) = v110 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v110 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v112 = 1;
LABEL_192:
        v4 = (int *)(v112 + 1);
        *(_BYTE *)(v3 + v112) = 114;
        *(_DWORD *)(v3 + 256) = v112 + 1;
        *(_BYTE *)(v3 + 260) = 114;
        v113 = *(_BYTE **)(v103 + 4);
        if ( (unsigned __int8)(*v113 - 97) > 0x19u )
          goto LABEL_193;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v340 = 0;
          goto LABEL_589;
        }
LABEL_588:
        v340 = v4;
        v4 = (int *)((char *)v4 + 1);
LABEL_589:
        *((_BYTE *)v340 + v3) = 32;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = 32;
        v113 = *(_BYTE **)(v103 + 4);
        goto LABEL_193;
      }
LABEL_191:
      v112 = v111 + 1;
      *(_BYTE *)(v3 + v111) = 111;
      *(_DWORD *)(v3 + 256) = v111 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v111 != 254 )
        goto LABEL_192;
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      *(_BYTE *)v3 = 114;
      *(_DWORD *)(v3 + 256) = 1;
      *(_BYTE *)(v3 + 260) = 114;
      v113 = *(_BYTE **)(v103 + 4);
      v359 = *v113 - 97;
      v360 = v359 < 0x19u;
      v101 = v359 == 25;
      v4 = (int *)1;
      if ( v360 || v101 )
        goto LABEL_588;
LABEL_193:
      if ( v113[v104 - 1] == 32 )
        --v104;
      if ( v104 )
      {
        v114 = 0;
        do
        {
          v116 = v113[v114];
          if ( v4 == (int *)255 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            v117 = v116;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            v4 = (int *)1;
            v115 = 0;
            v116 = v117;
          }
          else
          {
            v115 = v4;
            v4 = (int *)((char *)v4 + 1);
          }
          *((_BYTE *)v115 + v3) = v116;
          *(_DWORD *)(v3 + 256) = v4;
          *(_BYTE *)(v3 + 260) = v116;
          ++v114;
        }
        while ( v104 != v114 );
      }
      return (unsigned int)v4;
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x21u:
    case 0x22u:
      v118 = *(_DWORD *)(v3 + 276);
      goto LABEL_202;
    case 0x17u:
    case 0x18u:
    case 0x19u:
      v118 = *(_DWORD *)(v3 + 276);
      v123 = v118;
      if ( !v118 )
        goto LABEL_202;
      while ( 2 )
      {
        if ( *(_DWORD *)(v123 + 8) )
          goto LABEL_210;
        v124 = **(int ***)(v123 + 4);
        if ( (unsigned int)v124 - 23 <= 2 )
        {
          if ( v4 == v124 )
          {
            LOBYTE(v4) = v396;
            v125 = *(_DWORD *)(v396 + 4);
            if ( v125 )
            {
              v4 = *(int **)(v3 + 280);
              if ( !v4 )
                LOBYTE(v4) = d_print_comp_part_8(v3, v400, v125);
            }
            else
            {
              *(_DWORD *)(v3 + 280) = 1;
            }
            return (unsigned int)v4;
          }
LABEL_210:
          v123 = *(_DWORD *)v123;
          if ( !v123 )
            break;
          continue;
        }
        break;
      }
LABEL_202:
      v119 = *(_DWORD *)(v3 + 272);
      v120 = v396;
LABEL_203:
      v413 = v118;
      *(_DWORD *)(v3 + 276) = &v413;
      v414 = v120;
      v415 = 0;
      v416 = v119;
      goto LABEL_204;
    case 0x16u:
      v126 = *(_DWORD *)(a3 + 8);
      v127 = *(_DWORD *)(a3 + 4);
      if ( v126 )
      {
        v4 = *(int **)(v3 + 256);
        v128 = 0;
        do
        {
          v130 = *(_BYTE *)(v127 + v128);
          if ( v4 == (int *)255 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            v131 = v130;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            v4 = (int *)1;
            v129 = 0;
            v130 = v131;
          }
          else
          {
            v129 = v4;
            v4 = (int *)((char *)v4 + 1);
          }
          *((_BYTE *)v129 + v3) = v130;
          *(_DWORD *)(v3 + 256) = v4;
          *(_BYTE *)(v3 + 260) = v130;
          ++v128;
        }
        while ( v126 != v128 );
      }
      return (unsigned int)v4;
    case 0x15u:
      v132 = *(_DWORD *)(v3 + 256);
      if ( v132 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 104;
        v133 = 1;
      }
      else
      {
        v133 = v132 + 1;
        *(_BYTE *)(v3 + v132) = 104;
        *(_DWORD *)(v3 + 256) = v132 + 1;
        *(_BYTE *)(v3 + 260) = 104;
        if ( v132 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 105;
          v134 = 1;
          goto LABEL_226;
        }
      }
      v134 = v133 + 1;
      *(_BYTE *)(v3 + v133) = 105;
      *(_DWORD *)(v3 + 256) = v133 + 1;
      *(_BYTE *)(v3 + 260) = 105;
      if ( v133 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 100;
        v135 = 1;
        goto LABEL_227;
      }
LABEL_226:
      v135 = v134 + 1;
      *(_BYTE *)(v3 + v134) = 100;
      *(_DWORD *)(v3 + 256) = v134 + 1;
      *(_BYTE *)(v3 + 260) = 100;
      if ( v134 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 100;
        v136 = 1;
        goto LABEL_228;
      }
LABEL_227:
      v136 = v135 + 1;
      *(_BYTE *)(v3 + v135) = 100;
      *(_DWORD *)(v3 + 256) = v135 + 1;
      *(_BYTE *)(v3 + 260) = 100;
      if ( v135 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v137 = 1;
        goto LABEL_229;
      }
LABEL_228:
      v137 = v136 + 1;
      *(_BYTE *)(v3 + v136) = 101;
      *(_DWORD *)(v3 + 256) = v136 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v136 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 110;
        v138 = 1;
        goto LABEL_230;
      }
LABEL_229:
      v138 = v137 + 1;
      *(_BYTE *)(v3 + v137) = 110;
      *(_DWORD *)(v3 + 256) = v137 + 1;
      *(_BYTE *)(v3 + 260) = 110;
      if ( v137 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v139 = 1;
        goto LABEL_231;
      }
LABEL_230:
      v139 = v138 + 1;
      *(_BYTE *)(v3 + v138) = 32;
      *(_DWORD *)(v3 + 256) = v138 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v138 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v140 = 1;
        goto LABEL_232;
      }
LABEL_231:
      v140 = v139 + 1;
      *(_BYTE *)(v3 + v139) = 97;
      *(_DWORD *)(v3 + 256) = v139 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v139 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v141 = 1;
        goto LABEL_233;
      }
LABEL_232:
      v141 = v140 + 1;
      *(_BYTE *)(v3 + v140) = 108;
      *(_DWORD *)(v3 + 256) = v140 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v140 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 105;
        v142 = 1;
        goto LABEL_234;
      }
LABEL_233:
      v142 = v141 + 1;
      *(_BYTE *)(v3 + v141) = 105;
      *(_DWORD *)(v3 + 256) = v141 + 1;
      *(_BYTE *)(v3 + 260) = 105;
      if ( v141 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v143 = 1;
        goto LABEL_235;
      }
LABEL_234:
      v143 = v142 + 1;
      *(_BYTE *)(v3 + v142) = 97;
      *(_DWORD *)(v3 + 256) = v142 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v142 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 115;
        v144 = 1;
        goto LABEL_236;
      }
LABEL_235:
      v144 = v143 + 1;
      *(_BYTE *)(v3 + v143) = 115;
      *(_DWORD *)(v3 + 256) = v143 + 1;
      *(_BYTE *)(v3 + 260) = 115;
      if ( v143 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v145 = 1;
        goto LABEL_237;
      }
LABEL_236:
      v145 = v144 + 1;
      *(_BYTE *)(v3 + v144) = 32;
      *(_DWORD *)(v3 + 256) = v144 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v144 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 102;
        v146 = 1;
        goto LABEL_238;
      }
LABEL_237:
      v146 = v145 + 1;
      *(_BYTE *)(v3 + v145) = 102;
      *(_DWORD *)(v3 + 256) = v145 + 1;
      *(_BYTE *)(v3 + 260) = 102;
      if ( v145 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v147 = 1;
        goto LABEL_239;
      }
LABEL_238:
      v147 = v146 + 1;
      *(_BYTE *)(v3 + v146) = 111;
      *(_DWORD *)(v3 + 256) = v146 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v146 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v4 = (int *)1;
        goto LABEL_240;
      }
LABEL_239:
      v4 = (int *)(v147 + 1);
      *(_BYTE *)(v3 + v147) = 114;
      *(_DWORD *)(v3 + 256) = v147 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v147 != 254 )
      {
LABEL_240:
        v148 = (int)v4 + 1;
        goto LABEL_241;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v148 = 1;
      v4 = 0;
LABEL_241:
      *((_BYTE *)v4 + v3) = 32;
      *(_DWORD *)(v3 + 256) = v148;
      *(_BYTE *)(v3 + 260) = 32;
      v149 = *(_DWORD *)(v396 + 4);
      if ( v149 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v149);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x14u:
      v150 = *(_DWORD *)(v3 + 256);
      v151 = "reference temporary #";
      do
      {
        v153 = *v151;
        if ( v150 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v154 = v153;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v150 = 1;
          v152 = 0;
          v153 = v154;
        }
        else
        {
          v152 = v150++;
        }
        *(_BYTE *)(v3 + v152) = v153;
        *(_DWORD *)(v3 + 256) = v150;
        *(_BYTE *)(v3 + 260) = v153;
        ++v151;
      }
      while ( v151 != "" );
      v277 = *(_DWORD *)(v396 + 8);
      if ( v277 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, v400, v277);
          v150 = *(_DWORD *)(v3 + 256);
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v150 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v278 = 1;
      }
      else
      {
        v278 = v150 + 1;
        *(_BYTE *)(v3 + v150) = 32;
        *(_DWORD *)(v3 + 256) = v150 + 1;
        *(_BYTE *)(v3 + 260) = 32;
        if ( v150 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 102;
          v279 = 1;
          goto LABEL_476;
        }
      }
      v279 = v278 + 1;
      *(_BYTE *)(v3 + v278) = 102;
      *(_DWORD *)(v3 + 256) = v278 + 1;
      *(_BYTE *)(v3 + 260) = 102;
      if ( v278 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v280 = 1;
        goto LABEL_477;
      }
LABEL_476:
      v280 = v279 + 1;
      *(_BYTE *)(v3 + v279) = 111;
      *(_DWORD *)(v3 + 256) = v279 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v279 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v4 = (int *)1;
        goto LABEL_478;
      }
LABEL_477:
      v4 = (int *)(v280 + 1);
      *(_BYTE *)(v3 + v280) = 114;
      *(_DWORD *)(v3 + 256) = v280 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v280 != 254 )
      {
LABEL_478:
        v281 = (int)v4 + 1;
        goto LABEL_479;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v281 = 1;
      v4 = 0;
LABEL_479:
      *((_BYTE *)v4 + v3) = 32;
      *(_DWORD *)(v3 + 256) = v281;
      *(_BYTE *)(v3 + 260) = 32;
      LOBYTE(v4) = v396;
      v282 = *(_DWORD *)(v396 + 4);
      if ( v282 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v282);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x13u:
      v4 = *(int **)(v3 + 256);
      v155 = "guard variable for ";
      do
      {
        v157 = *v155;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v158 = v157;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v156 = 0;
          v157 = v158;
        }
        else
        {
          v156 = v4;
          v4 = (int *)((char *)v4 + 1);
        }
        *((_BYTE *)v156 + v3) = v157;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = v157;
        ++v155;
      }
      while ( v155 != "" );
      v286 = *(_DWORD *)(v396 + 4);
      if ( v286 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v286);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 8u:
      v4 = *(int **)(v3 + 256);
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v159 = 1;
        v4 = 0;
      }
      else
      {
        v159 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 126;
      *(_DWORD *)(v3 + 256) = v159;
      *(_BYTE *)(v3 + 260) = 126;
      v160 = *(_DWORD *)(v396 + 8);
      if ( v160 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v160);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 7u:
      LOBYTE(v4) = a3;
      v161 = *(_DWORD *)(a3 + 8);
      if ( v161 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, a2, v161);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0xCu:
      d_append_string(v3, "typeinfo for ");
      LOBYTE(v4) = v396;
      v162 = *(_DWORD *)(v396 + 4);
      if ( v162 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v162);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 4u:
      v163 = *(_DWORD *)(v3 + 276);
      *(_DWORD *)(v3 + 276) = 0;
      v164 = *(_DWORD *)(a3 + 4);
      if ( a2 & 4 )
      {
        if ( !*(_DWORD *)v164 )
        {
          v165 = *(_DWORD *)(v164 + 8) == 6;
          if ( *(_DWORD *)(v164 + 8) == 6 )
          {
            v381 = *(_BYTE **)(v164 + 4);
            v382 = "JArray";
            v383 = 6;
            do
            {
              if ( !v383 )
                break;
              v165 = *v381++ == *v382++;
              --v383;
            }
            while ( v165 );
            if ( v165 )
            {
              d_print_comp(v3, a2, *(_DWORD *)(v396 + 8));
              LOBYTE(v4) = d_append_string(v3, "[]");
              goto LABEL_279;
            }
          }
        }
      }
      else if ( !v164 )
      {
        *(_DWORD *)(v3 + 280) = 1;
        goto LABEL_270;
      }
      if ( !*(_DWORD *)(v3 + 280) )
        d_print_comp_part_8(v3, a2, *(_DWORD *)(v396 + 4));
LABEL_270:
      v166 = *(_DWORD *)(v3 + 256);
      if ( *(_BYTE *)(v3 + 260) == 60 )
      {
        if ( v166 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v166 = 0;
        }
        *(_BYTE *)(v3 + v166++) = 32;
        *(_DWORD *)(v3 + 256) = v166;
        *(_BYTE *)(v3 + 260) = 32;
      }
      if ( v166 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v4 = (int *)1;
        v166 = 0;
      }
      else
      {
        v4 = (int *)(v166 + 1);
      }
      *(_BYTE *)(v3 + v166) = 60;
      *(_DWORD *)(v3 + 256) = v4;
      *(_BYTE *)(v3 + 260) = 60;
      v167 = *(_DWORD *)(v396 + 8);
      if ( v167 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, v400, v167);
          v4 = *(int **)(v3 + 256);
          if ( *(_BYTE *)(v3 + 260) == 62 )
          {
            if ( v4 == (int *)255 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v4 = 0;
            }
            *((_BYTE *)v4 + v3) = 32;
            v4 = (int *)((char *)v4 + 1);
            *(_DWORD *)(v3 + 256) = v4;
            *(_BYTE *)(v3 + 260) = 32;
          }
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v168 = 1;
        v4 = 0;
      }
      else
      {
        v168 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 62;
      *(_DWORD *)(v3 + 256) = v168;
      *(_BYTE *)(v3 + 260) = 62;
LABEL_279:
      *(_DWORD *)(v3 + 276) = v163;
      return (unsigned int)v4;
    case 0xEu:
      d_append_string(v3, "typeinfo fn for ");
      LOBYTE(v4) = v396;
      v169 = *(_DWORD *)(v396 + 4);
      if ( v169 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v169);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 6u:
      v170 = *(_DWORD *)(a3 + 4);
      if ( !v170 )
      {
        v171 = *(_DWORD *)(v3 + 256);
        if ( v171 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 116;
          v172 = 1;
        }
        else
        {
          v172 = v171 + 1;
          *(_BYTE *)(v3 + v171) = 116;
          *(_DWORD *)(v3 + 256) = v171 + 1;
          *(_BYTE *)(v3 + 260) = 116;
          if ( v171 == 254 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            *(_BYTE *)v3 = 104;
            v173 = 1;
            goto LABEL_287;
          }
        }
        v173 = v172 + 1;
        *(_BYTE *)(v3 + v172) = 104;
        *(_DWORD *)(v3 + 256) = v172 + 1;
        *(_BYTE *)(v3 + 260) = 104;
        if ( v172 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 105;
          v4 = (int *)1;
          goto LABEL_288;
        }
LABEL_287:
        v4 = (int *)(v173 + 1);
        *(_BYTE *)(v3 + v173) = 105;
        *(_DWORD *)(v3 + 256) = v173 + 1;
        *(_BYTE *)(v3 + 260) = 105;
        if ( v173 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v174 = 1;
          v4 = 0;
          goto LABEL_289;
        }
LABEL_288:
        v174 = (int)v4 + 1;
LABEL_289:
        *((_BYTE *)v4 + v3) = 115;
        *(_DWORD *)(v3 + 256) = v174;
        *(_BYTE *)(v3 + 260) = 115;
        return (unsigned int)v4;
      }
      v291 = *(_DWORD *)(v3 + 256);
      if ( v291 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v380 = v170;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 123;
        v292 = 1;
        v170 = v380;
      }
      else
      {
        v292 = v291 + 1;
        *(_BYTE *)(v3 + v291) = 123;
        *(_DWORD *)(v3 + 256) = v291 + 1;
        *(_BYTE *)(v3 + 260) = 123;
        if ( v291 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v379 = v170;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 112;
          v293 = 1;
          v170 = v379;
          goto LABEL_514;
        }
      }
      v293 = v292 + 1;
      *(_BYTE *)(v3 + v292) = 112;
      *(_DWORD *)(v3 + 256) = v292 + 1;
      *(_BYTE *)(v3 + 260) = 112;
      if ( v292 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v378 = v170;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v294 = 1;
        v170 = v378;
        goto LABEL_515;
      }
LABEL_514:
      v294 = v293 + 1;
      *(_BYTE *)(v3 + v293) = 97;
      *(_DWORD *)(v3 + 256) = v293 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v293 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v377 = v170;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v295 = 1;
        v170 = v377;
        goto LABEL_516;
      }
LABEL_515:
      v295 = v294 + 1;
      *(_BYTE *)(v3 + v294) = 114;
      *(_DWORD *)(v3 + 256) = v294 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v294 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v376 = v170;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 109;
        v296 = 1;
        v170 = v376;
        goto LABEL_517;
      }
LABEL_516:
      v296 = v295 + 1;
      *(_BYTE *)(v3 + v295) = 109;
      *(_DWORD *)(v3 + 256) = v295 + 1;
      *(_BYTE *)(v3 + 260) = 109;
      if ( v295 != 254 )
      {
LABEL_517:
        v297 = v296 + 1;
        goto LABEL_518;
      }
      *(_BYTE *)(v3 + 255) = 0;
      v375 = v170;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v297 = 1;
      v296 = 0;
      v170 = v375;
LABEL_518:
      *(_BYTE *)(v3 + v296) = 35;
      *(_DWORD *)(v3 + 256) = v297;
      *(_BYTE *)(v3 + 260) = 35;
      d_append_num(v3, v170);
      v4 = *(int **)(v3 + 256);
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v298 = 1;
        v4 = 0;
      }
      else
      {
        v298 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 125;
      *(_DWORD *)(v3 + 256) = v298;
      *(_BYTE *)(v3 + 260) = 125;
      return (unsigned int)v4;
    case 0xAu:
      v175 = *(_DWORD *)(v3 + 256);
      if ( v175 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 86;
        v176 = 1;
      }
      else
      {
        v176 = v175 + 1;
        *(_BYTE *)(v3 + v175) = 86;
        *(_DWORD *)(v3 + 256) = v175 + 1;
        *(_BYTE *)(v3 + 260) = 86;
        if ( v175 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 84;
          v177 = 1;
          goto LABEL_293;
        }
      }
      v177 = v176 + 1;
      *(_BYTE *)(v3 + v176) = 84;
      *(_DWORD *)(v3 + 256) = v176 + 1;
      *(_BYTE *)(v3 + 260) = 84;
      if ( v176 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 84;
        v178 = 1;
        goto LABEL_294;
      }
LABEL_293:
      v178 = v177 + 1;
      *(_BYTE *)(v3 + v177) = 84;
      *(_DWORD *)(v3 + 256) = v177 + 1;
      *(_BYTE *)(v3 + 260) = 84;
      if ( v177 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v179 = 1;
        goto LABEL_295;
      }
LABEL_294:
      v179 = v178 + 1;
      *(_BYTE *)(v3 + v178) = 32;
      *(_DWORD *)(v3 + 256) = v178 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v178 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 102;
        v180 = 1;
        goto LABEL_296;
      }
LABEL_295:
      v180 = v179 + 1;
      *(_BYTE *)(v3 + v179) = 102;
      *(_DWORD *)(v3 + 256) = v179 + 1;
      *(_BYTE *)(v3 + 260) = 102;
      if ( v179 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v181 = 1;
        goto LABEL_297;
      }
LABEL_296:
      v181 = v180 + 1;
      *(_BYTE *)(v3 + v180) = 111;
      *(_DWORD *)(v3 + 256) = v180 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v180 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v4 = (int *)1;
        goto LABEL_298;
      }
LABEL_297:
      v4 = (int *)(v181 + 1);
      *(_BYTE *)(v3 + v181) = 114;
      *(_DWORD *)(v3 + 256) = v181 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v181 != 254 )
      {
LABEL_298:
        v182 = (int)v4 + 1;
        goto LABEL_299;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v182 = 1;
      v4 = 0;
LABEL_299:
      *((_BYTE *)v4 + v3) = 32;
      *(_DWORD *)(v3 + 256) = v182;
      *(_BYTE *)(v3 + 260) = 32;
      v183 = *(_DWORD *)(v396 + 4);
      if ( v183 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v183);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0xFu:
      v4 = *(int **)(v3 + 256);
      v184 = "non-virtual thunk to ";
      do
      {
        v186 = *v184;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v187 = v186;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v185 = 0;
          v186 = v187;
        }
        else
        {
          v185 = v4;
          v4 = (int *)((char *)v4 + 1);
        }
        *((_BYTE *)v185 + v3) = v186;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = v186;
        ++v184;
      }
      while ( v184 != "" );
      v285 = *(_DWORD *)(v396 + 4);
      if ( v285 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v285);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0xDu:
      v4 = *(int **)(v3 + 256);
      v188 = "typeinfo name for ";
      do
      {
        v190 = *v188;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v191 = v190;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v189 = 0;
          v190 = v191;
        }
        else
        {
          v189 = v4;
          v4 = (int *)((char *)v4 + 1);
        }
        *((_BYTE *)v189 + v3) = v190;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = v190;
        ++v188;
      }
      while ( v188 != "" );
      v287 = *(_DWORD *)(v396 + 4);
      if ( v287 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v287);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 1u:
    case 2u:
      v192 = *(_DWORD *)(a3 + 4);
      if ( v192 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, a2, v192);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( !(v400 & 4) )
      {
        v193 = *(_DWORD *)(v3 + 256);
        if ( v193 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 58;
          v194 = 1;
        }
        else
        {
          v194 = v193 + 1;
          *(_BYTE *)(v3 + v193) = 58;
          *(_DWORD *)(v3 + 256) = v193 + 1;
          *(_BYTE *)(v3 + 260) = 58;
          if ( v193 == 254 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            v195 = 1;
            v194 = 0;
            goto LABEL_319;
          }
        }
        v195 = v194 + 1;
LABEL_319:
        *(_BYTE *)(v3 + v194) = 58;
        *(_DWORD *)(v3 + 256) = v195;
        *(_BYTE *)(v3 + 260) = 58;
        goto LABEL_320;
      }
      v304 = *(_DWORD *)(v3 + 256);
      if ( v304 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v305 = 1;
        v304 = 0;
      }
      else
      {
        v305 = v304 + 1;
      }
      *(_BYTE *)(v3 + v304) = 46;
      *(_DWORD *)(v3 + 256) = v305;
      *(_BYTE *)(v3 + 260) = 46;
LABEL_320:
      LOBYTE(v4) = v396;
      v196 = *(_DWORD *)(v396 + 8);
      if ( v196 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v196);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0u:
      if ( a2 & 4 )
      {
        LOBYTE(v4) = d_print_java_identifier(v3, *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8));
      }
      else
      {
        v197 = *(_DWORD *)(a3 + 8);
        v198 = *(_DWORD *)(a3 + 4);
        if ( v197 )
        {
          v4 = *(int **)(v3 + 256);
          v199 = 0;
          do
          {
            v201 = *(_BYTE *)(v198 + v199);
            if ( v4 == (int *)255 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              v202 = v201;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v4 = (int *)1;
              v200 = 0;
              v201 = v202;
            }
            else
            {
              v200 = v4;
              v4 = (int *)((char *)v4 + 1);
            }
            *((_BYTE *)v200 + v3) = v201;
            *(_DWORD *)(v3 + 256) = v4;
            *(_BYTE *)(v3 + 260) = v201;
            ++v199;
          }
          while ( v197 != v199 );
        }
      }
      return (unsigned int)v4;
    case 3u:
      v408 = *(_DWORD *)(v3 + 276);
      *(_DWORD *)(v3 + 276) = 0;
      v203 = *(_DWORD *)(a3 + 4);
      if ( !v203 )
        goto LABEL_808;
      v413 = 0;
      *(_DWORD *)(v3 + 276) = &v413;
      v414 = v203;
      v415 = 0;
      v402 = *(_DWORD *)(v3 + 272);
      v416 = *(_DWORD *)(v3 + 272);
      v4 = *(int **)v203;
      if ( (unsigned int)(*(_DWORD *)v203 - 26) > 2 )
      {
        v406 = 1;
      }
      else
      {
        v203 = *(_DWORD *)(v203 + 4);
        if ( !v203 )
          goto LABEL_808;
        v417 = &v413;
        *(_DWORD *)(v3 + 276) = &v417;
        v418 = v203;
        v419 = 0;
        v420 = v402;
        v4 = *(int **)v203;
        if ( (unsigned int)(*(_DWORD *)v203 - 26) > 2 )
        {
          v406 = 2;
          goto LABEL_916;
        }
        v203 = *(_DWORD *)(v203 + 4);
        if ( !v203 )
          goto LABEL_808;
        v421 = (int *)&v417;
        *(_DWORD *)(v3 + 276) = &v421;
        v422 = v203;
        v423 = 0;
        v424 = v402;
        v4 = *(int **)v203;
        if ( (unsigned int)(*(_DWORD *)v203 - 26) > 2 )
        {
          v406 = 3;
          goto LABEL_916;
        }
        v203 = *(_DWORD *)(v203 + 4);
        if ( !v203 )
        {
LABEL_808:
          *(_DWORD *)(v3 + 280) = 1;
          return (unsigned int)v4;
        }
        v425 = (int *)&v421;
        *(_DWORD *)(v3 + 276) = &v425;
        v426 = v203;
        v427 = 0;
        v428 = v402;
        v4 = *(int **)v203;
        if ( (unsigned int)(*(_DWORD *)v203 - 26) <= 2 )
        {
          if ( *(_DWORD *)(v203 + 4) )
          {
            *(_DWORD *)(v3 + 280) = 1;
            return (unsigned int)v4;
          }
          goto LABEL_808;
        }
        v406 = 4;
      }
LABEL_916:
      if ( v4 == (int *)4 )
      {
        v411 = v402;
        v4 = &v411;
        *(_DWORD *)(v3 + 272) = &v411;
        v412 = v203;
LABEL_927:
        v391 = *(_DWORD *)(a3 + 8);
        if ( v391 )
        {
          if ( !*(_DWORD *)(v3 + 280) )
            LOBYTE(v4) = d_print_comp_part_8(v3, v400, v391);
        }
        else
        {
          *(_DWORD *)(v3 + 280) = 1;
        }
        if ( *(_DWORD *)v203 == 4 )
        {
          LOBYTE(v4) = v411;
          *(_DWORD *)(v3 + 272) = v411;
        }
        if ( v406 )
        {
          v4 = (int *)(16 * (v406 - 1));
          v392 = (char *)v4 + (_DWORD)&v413 + 8;
          v393 = v406 - 1;
          if ( !*(_DWORD *)v392 )
            goto LABEL_936;
          while ( 1 )
          {
            v392 -= 16;
            if ( !v393 )
              break;
            --v393;
            if ( !*(_DWORD *)v392 )
            {
LABEL_936:
              v394 = *(_DWORD *)(v3 + 256);
              if ( v394 == 255 )
              {
                *(_BYTE *)(v3 + 255) = 0;
                (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
                ++*(_DWORD *)(v3 + 288);
                v394 = 0;
              }
              *(_BYTE *)(v3 + v394) = 32;
              *(_DWORD *)(v3 + 256) = v394 + 1;
              *(_BYTE *)(v3 + 260) = 32;
              LOBYTE(v4) = d_print_mod(v3, v400, *((_DWORD *)v392 - 1));
            }
          }
        }
        *(_DWORD *)(v3 + 276) = v408;
        return (unsigned int)v4;
      }
      if ( v4 != (int *)2 )
        goto LABEL_927;
      v4 = *(int **)(v203 + 8);
      v386 = *v4;
      if ( *v4 == 65 )
      {
        v4 = (int *)v4[1];
        v386 = *v4;
      }
      if ( (unsigned int)(v386 - 26) > 2 )
        goto LABEL_927;
      if ( v406 <= 3 )
      {
        v387 = &v413 + 4 * (v406 - 1);
        v410 = v203;
        v388 = v4;
        v409 = v3;
        v389 = v406;
        for ( i = v406 - 1; ; i = v389 - 1 )
        {
          qmemcpy(v387 + 4, v387, 0x10u);
          v387[4] = (int)(&v413 + 4 * i);
          *(_DWORD *)(v409 + 276) = &v413 + 4 * v389;
          v387[1] = (int)v388;
          v387[2] = 0;
          v387[3] = v402;
          ++v389;
          v388 = (int *)v388[1];
          v4 = (int *)(*v388 - 26);
          if ( (unsigned int)v4 > 2 )
          {
            v406 = v389;
            v203 = v410;
            v3 = v409;
            goto LABEL_927;
          }
          v387 += 4;
          if ( v389 == 4 )
            break;
        }
        v3 = v409;
      }
      *(_DWORD *)(v3 + 280) = 1;
      return (unsigned int)v4;
    case 0xBu:
      v204 = *(_DWORD *)(v3 + 256);
      v205 = "construction vtable for ";
      do
      {
        v207 = *v205;
        if ( v204 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v208 = v207;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v204 = 1;
          v206 = 0;
          v207 = v208;
        }
        else
        {
          v206 = v204++;
        }
        *(_BYTE *)(v3 + v206) = v207;
        *(_DWORD *)(v3 + 256) = v204;
        *(_BYTE *)(v3 + 260) = v207;
        ++v205;
      }
      while ( v205 != "" );
      v283 = *(_DWORD *)(v396 + 4);
      if ( v283 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, v400, v283);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      LOBYTE(v4) = d_append_string(v3, "-in-");
      v284 = *(_DWORD *)(v396 + 8);
      if ( v284 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v284);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 5u:
      v4 = (int *)d_lookup_template_argument_isra_5(v3, (int *)(a3 + 4));
      if ( !v4 )
        goto LABEL_579;
      if ( *v4 != 43 )
        goto LABEL_347;
      v333 = *(_DWORD *)(v3 + 284);
      while ( v333 > 0 )
      {
        --v333;
        v4 = (int *)v4[2];
        if ( !v4 || *v4 != 43 )
          goto LABEL_579;
      }
      if ( v333 || (v4 = (int *)v4[1]) == 0 )
      {
LABEL_579:
        *(_DWORD *)(v3 + 280) = 1;
        return (unsigned int)v4;
      }
LABEL_347:
      v209 = *(_DWORD **)(v3 + 272);
      *(_DWORD *)(v3 + 272) = *v209;
      if ( !*(_DWORD *)(v3 + 280) )
        LOBYTE(v4) = d_print_comp_part_8(v3, v400, (int)v4);
      *(_DWORD *)(v3 + 272) = v209;
      return (unsigned int)v4;
    case 9u:
      v210 = *(_DWORD *)(v3 + 256);
      if ( v210 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 118;
        v211 = 1;
      }
      else
      {
        v211 = v210 + 1;
        *(_BYTE *)(v3 + v210) = 118;
        *(_DWORD *)(v3 + 256) = v210 + 1;
        *(_BYTE *)(v3 + 260) = 118;
        if ( v210 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 116;
          v212 = 1;
          goto LABEL_353;
        }
      }
      v212 = v211 + 1;
      *(_BYTE *)(v3 + v211) = 116;
      *(_DWORD *)(v3 + 256) = v211 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v211 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v213 = 1;
        goto LABEL_354;
      }
LABEL_353:
      v213 = v212 + 1;
      *(_BYTE *)(v3 + v212) = 97;
      *(_DWORD *)(v3 + 256) = v212 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v212 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 98;
        v214 = 1;
        goto LABEL_355;
      }
LABEL_354:
      v214 = v213 + 1;
      *(_BYTE *)(v3 + v213) = 98;
      *(_DWORD *)(v3 + 256) = v213 + 1;
      *(_BYTE *)(v3 + 260) = 98;
      if ( v213 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v215 = 1;
        goto LABEL_356;
      }
LABEL_355:
      v215 = v214 + 1;
      *(_BYTE *)(v3 + v214) = 108;
      *(_DWORD *)(v3 + 256) = v214 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v214 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v216 = 1;
        goto LABEL_357;
      }
LABEL_356:
      v216 = v215 + 1;
      *(_BYTE *)(v3 + v215) = 101;
      *(_DWORD *)(v3 + 256) = v215 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v215 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v217 = 1;
        goto LABEL_358;
      }
LABEL_357:
      v217 = v216 + 1;
      *(_BYTE *)(v3 + v216) = 32;
      *(_DWORD *)(v3 + 256) = v216 + 1;
      *(_BYTE *)(v3 + 260) = 32;
      if ( v216 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 102;
        v218 = 1;
        goto LABEL_359;
      }
LABEL_358:
      v218 = v217 + 1;
      *(_BYTE *)(v3 + v217) = 102;
      *(_DWORD *)(v3 + 256) = v217 + 1;
      *(_BYTE *)(v3 + 260) = 102;
      if ( v217 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v219 = 1;
        goto LABEL_360;
      }
LABEL_359:
      v219 = v218 + 1;
      *(_BYTE *)(v3 + v218) = 111;
      *(_DWORD *)(v3 + 256) = v218 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v218 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v4 = (int *)1;
        goto LABEL_361;
      }
LABEL_360:
      v4 = (int *)(v219 + 1);
      *(_BYTE *)(v3 + v219) = 114;
      *(_DWORD *)(v3 + 256) = v219 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v219 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v220 = 1;
        v4 = 0;
LABEL_362:
        *((_BYTE *)v4 + v3) = 32;
        *(_DWORD *)(v3 + 256) = v220;
        *(_BYTE *)(v3 + 260) = 32;
        LOBYTE(v4) = v396;
        v221 = *(_DWORD *)(v396 + 4);
        if ( v221 )
        {
          if ( !*(_DWORD *)(v3 + 280) )
            LOBYTE(v4) = d_print_comp_part_8(v3, v400, v221);
        }
        else
        {
          *(_DWORD *)(v3 + 280) = 1;
        }
        return (unsigned int)v4;
      }
LABEL_361:
      v220 = (int)v4 + 1;
      goto LABEL_362;
    case 0x3Au:
      v222 = *(_DWORD *)(a3 + 4);
      if ( v222 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, a2, v222);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      LOBYTE(v4) = v396;
      v223 = *(_DWORD *)(v396 + 8);
      if ( v223 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v223);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x44u:
      v4 = *(int **)(v3 + 256);
      v224 = "non-transaction clone for ";
      do
      {
        v226 = *v224;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v227 = v226;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v225 = 0;
          v226 = v227;
        }
        else
        {
          v225 = v4;
          v4 = (int *)((char *)v4 + 1);
        }
        *((_BYTE *)v225 + v3) = v226;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = v226;
        ++v224;
      }
      while ( v224 != "" );
      v288 = *(_DWORD *)(v396 + 4);
      if ( v288 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v288);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x2Eu:
      v228 = *(_DWORD *)(v3 + 256);
      if ( v228 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v229 = 1;
      }
      else
      {
        v229 = v228 + 1;
        *(_BYTE *)(v3 + v228) = 111;
        *(_DWORD *)(v3 + 256) = v228 + 1;
        *(_BYTE *)(v3 + 260) = 111;
        if ( v228 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 112;
          v230 = 1;
          goto LABEL_379;
        }
      }
      v230 = v229 + 1;
      *(_BYTE *)(v3 + v229) = 112;
      *(_DWORD *)(v3 + 256) = v229 + 1;
      *(_BYTE *)(v3 + 260) = 112;
      if ( v229 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v231 = 1;
        goto LABEL_380;
      }
LABEL_379:
      v231 = v230 + 1;
      *(_BYTE *)(v3 + v230) = 101;
      *(_DWORD *)(v3 + 256) = v230 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v230 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v232 = 1;
        goto LABEL_381;
      }
LABEL_380:
      v232 = v231 + 1;
      *(_BYTE *)(v3 + v231) = 114;
      *(_DWORD *)(v3 + 256) = v231 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v231 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v233 = 1;
        goto LABEL_382;
      }
LABEL_381:
      v233 = v232 + 1;
      *(_BYTE *)(v3 + v232) = 97;
      *(_DWORD *)(v3 + 256) = v232 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v232 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v234 = 1;
        goto LABEL_383;
      }
LABEL_382:
      v234 = v233 + 1;
      *(_BYTE *)(v3 + v233) = 116;
      *(_DWORD *)(v3 + 256) = v233 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v233 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v235 = 1;
        goto LABEL_384;
      }
LABEL_383:
      v235 = v234 + 1;
      *(_BYTE *)(v3 + v234) = 111;
      *(_DWORD *)(v3 + 256) = v234 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v234 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v4 = (int *)1;
        goto LABEL_385;
      }
LABEL_384:
      v4 = (int *)(v235 + 1);
      *(_BYTE *)(v3 + v235) = 114;
      *(_DWORD *)(v3 + 256) = v235 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v235 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v236 = 1;
        v4 = 0;
LABEL_386:
        *((_BYTE *)v4 + v3) = 32;
        *(_DWORD *)(v3 + 256) = v236;
        *(_BYTE *)(v3 + 260) = 32;
        LOBYTE(v4) = v396;
        v237 = *(_DWORD *)(v396 + 8);
        if ( v237 )
        {
          v4 = *(int **)(v3 + 280);
          if ( !v4 )
            LOBYTE(v4) = d_print_comp_part_8(v3, v400, v237);
        }
        else
        {
          *(_DWORD *)(v3 + 280) = 1;
        }
        return (unsigned int)v4;
      }
LABEL_385:
      v236 = (int)v4 + 1;
      goto LABEL_386;
    case 0x2Cu:
      v238 = *(_DWORD *)(a3 + 4);
      v239 = *(_DWORD *)(v396 + 8);
      if ( v238 && !*(_DWORD *)(v3 + 280) )
        d_print_comp_part_8(v3, a2, v238);
      v240 = *(_DWORD *)(v3 + 256);
      if ( v240 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v4 = (int *)1;
        v240 = 0;
      }
      else
      {
        v4 = (int *)(v240 + 1);
      }
      *(_BYTE *)(v3 + v240) = 123;
      *(_DWORD *)(v3 + 256) = v4;
      *(_BYTE *)(v3 + 260) = 123;
      if ( v239 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, v400, v239);
          v4 = *(int **)(v3 + 256);
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v4 == (int *)255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v241 = 1;
        v4 = 0;
      }
      else
      {
        v241 = (int)v4 + 1;
      }
      *((_BYTE *)v4 + v3) = 125;
      *(_DWORD *)(v3 + 256) = v241;
      *(_BYTE *)(v3 + 260) = 125;
      return (unsigned int)v4;
    case 0x25u:
      if ( a2 & 0x20 )
      {
        v341 = a2 & 0xFFFFFF9F;
        LOBYTE(v4) = d_print_function_type_isra_9(v3, a2 & 0xFFFFFF9F, (_DWORD *)(a3 + 8), *(_DWORD *)(v3 + 276));
        v342 = *(_DWORD *)(v396 + 4);
        if ( v342 && !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v341, v342);
        return (unsigned int)v4;
      }
      if ( !*(_DWORD *)(a3 + 4) || a2 & 0x40 )
        goto LABEL_403;
      v367 = *(_DWORD *)(v3 + 276);
      v413 = *(_DWORD *)(v3 + 276);
      *(_DWORD *)(v3 + 276) = &v413;
      v414 = a3;
      v415 = 0;
      v416 = *(_DWORD *)(v3 + 272);
      v368 = *(_DWORD *)(a3 + 4);
      if ( v368 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, a2 & 0xFFFFFF9F, v368);
          *(_DWORD *)(v3 + 276) = v413;
          LOBYTE(v4) = v415;
          if ( v415 )
            return (unsigned int)v4;
          goto LABEL_763;
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      *(_DWORD *)(v3 + 276) = v367;
LABEL_763:
      d_append_char(v3, 32);
LABEL_403:
      LOBYTE(v4) = d_print_function_type_isra_9(v3, v400 & 0xFFFFFF9F, (_DWORD *)(v396 + 8), *(_DWORD *)(v3 + 276));
      return (unsigned int)v4;
    case 0x3Fu:
      v4 = *(int **)(v3 + 256);
      v242 = "global destructors keyed to ";
      do
      {
        v244 = *v242;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v245 = v244;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v243 = 0;
          v244 = v245;
        }
        else
        {
          v243 = v4;
          v4 = (int *)((char *)v4 + 1);
        }
        *((_BYTE *)v243 + v3) = v244;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = v244;
        ++v242;
      }
      while ( v242 != "" );
      v290 = *(_DWORD *)(v396 + 4);
      if ( v290 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v290);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x3Eu:
      v246 = *(_DWORD *)(v3 + 256);
      v247 = "global constructors keyed to ";
      do
      {
        v249 = *v247;
        if ( v246 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v250 = v249;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v246 = 1;
          v248 = 0;
          v249 = v250;
        }
        else
        {
          v248 = v246++;
        }
        *(_BYTE *)(v3 + v248) = v249;
        *(_DWORD *)(v3 + 256) = v246;
        *(_BYTE *)(v3 + 260) = v249;
        ++v247;
      }
      while ( v247 != "" );
      LOBYTE(v4) = v396;
      v289 = *(_DWORD *)(v396 + 4);
      if ( v289 )
      {
        v4 = *(int **)(v3 + 280);
        if ( !v4 )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v289);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x43u:
      d_append_string(v3, "transaction clone for ");
      LOBYTE(v4) = v396;
      v251 = *(_DWORD *)(v396 + 4);
      if ( v251 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v251);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x12u:
      d_append_string(v3, "java Class for ");
      LOBYTE(v4) = v396;
      v252 = *(_DWORD *)(v396 + 4);
      if ( v252 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v252);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x28u:
      if ( !*(_WORD *)(a3 + 10) )
        goto LABEL_421;
      v334 = *(_DWORD *)(v3 + 256);
      if ( v334 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 95;
        v335 = 1;
      }
      else
      {
        v335 = v334 + 1;
        *(_BYTE *)(v3 + v334) = 95;
        *(_DWORD *)(v3 + 256) = v334 + 1;
        *(_BYTE *)(v3 + 260) = 95;
        if ( v334 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 83;
          v336 = 1;
          goto LABEL_583;
        }
      }
      v336 = v335 + 1;
      *(_BYTE *)(v3 + v335) = 83;
      *(_DWORD *)(v3 + 256) = v335 + 1;
      *(_BYTE *)(v3 + 260) = 83;
      if ( v335 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v337 = 1;
        goto LABEL_584;
      }
LABEL_583:
      v337 = v336 + 1;
      *(_BYTE *)(v3 + v336) = 97;
      *(_DWORD *)(v3 + 256) = v336 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v336 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v338 = 1;
        goto LABEL_585;
      }
LABEL_584:
      v338 = v337 + 1;
      *(_BYTE *)(v3 + v337) = 116;
      *(_DWORD *)(v3 + 256) = v337 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v337 != 254 )
      {
LABEL_585:
        v339 = v338 + 1;
        goto LABEL_586;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v339 = 1;
      v338 = 0;
LABEL_586:
      *(_BYTE *)(v3 + v338) = 32;
      *(_DWORD *)(v3 + 256) = v339;
      *(_BYTE *)(v3 + 260) = 32;
LABEL_421:
      v253 = *(_DWORD *)(v396 + 4);
      if ( *(char ***)(v253 + 4) == &off_41D0E0 )
      {
        v255 = *(_DWORD *)(v3 + 256);
      }
      else
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, v400, v253);
        v254 = *(_DWORD *)(v3 + 256);
        if ( v254 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v255 = 1;
          v254 = 0;
        }
        else
        {
          v255 = v254 + 1;
        }
        *(_BYTE *)(v3 + v254) = 32;
        *(_DWORD *)(v3 + 256) = v255;
        *(_BYTE *)(v3 + 260) = 32;
      }
      if ( *(_WORD *)(v396 + 8) )
      {
        if ( v255 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 95;
          v256 = 1;
        }
        else
        {
          v256 = v255 + 1;
          *(_BYTE *)(v3 + v255) = 95;
          *(_DWORD *)(v3 + 256) = v255 + 1;
          *(_BYTE *)(v3 + 260) = 95;
          if ( v255 == 254 )
          {
            *(_BYTE *)(v3 + 255) = 0;
            (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
            ++*(_DWORD *)(v3 + 288);
            *(_BYTE *)v3 = 65;
            v257 = 1;
            goto LABEL_431;
          }
        }
        v257 = v256 + 1;
        *(_BYTE *)(v3 + v256) = 65;
        *(_DWORD *)(v3 + 256) = v256 + 1;
        *(_BYTE *)(v3 + 260) = 65;
        if ( v256 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 99;
          v258 = 1;
          goto LABEL_432;
        }
LABEL_431:
        v258 = v257 + 1;
        *(_BYTE *)(v3 + v257) = 99;
        *(_DWORD *)(v3 + 256) = v257 + 1;
        *(_BYTE *)(v3 + 260) = 99;
        if ( v257 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 99;
          v259 = 1;
          goto LABEL_433;
        }
LABEL_432:
        v259 = v258 + 1;
        *(_BYTE *)(v3 + v258) = 99;
        *(_DWORD *)(v3 + 256) = v258 + 1;
        *(_BYTE *)(v3 + 260) = 99;
        if ( v258 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 117;
          v4 = (int *)1;
          goto LABEL_434;
        }
LABEL_433:
        v4 = (int *)(v259 + 1);
        *(_BYTE *)(v3 + v259) = 117;
        *(_DWORD *)(v3 + 256) = v259 + 1;
        *(_BYTE *)(v3 + 260) = 117;
        if ( v259 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v260 = 1;
          v4 = 0;
          goto LABEL_435;
        }
LABEL_434:
        v260 = (int)v4 + 1;
LABEL_435:
        *((_BYTE *)v4 + v3) = 109;
        *(_DWORD *)(v3 + 256) = v260;
        *(_BYTE *)(v3 + 260) = 109;
        return (unsigned int)v4;
      }
      if ( v255 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 95;
        v299 = 1;
      }
      else
      {
        v299 = v255 + 1;
        *(_BYTE *)(v3 + v255) = 95;
        *(_DWORD *)(v3 + 256) = v255 + 1;
        *(_BYTE *)(v3 + 260) = 95;
        if ( v255 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 70;
          v300 = 1;
          goto LABEL_524;
        }
      }
      v300 = v299 + 1;
      *(_BYTE *)(v3 + v299) = 70;
      *(_DWORD *)(v3 + 256) = v299 + 1;
      *(_BYTE *)(v3 + 260) = 70;
      if ( v299 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v301 = 1;
        goto LABEL_525;
      }
LABEL_524:
      v301 = v300 + 1;
      *(_BYTE *)(v3 + v300) = 114;
      *(_DWORD *)(v3 + 256) = v300 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v300 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v302 = 1;
        goto LABEL_526;
      }
LABEL_525:
      v302 = v301 + 1;
      *(_BYTE *)(v3 + v301) = 97;
      *(_DWORD *)(v3 + 256) = v301 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v301 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v4 = (int *)1;
        goto LABEL_527;
      }
LABEL_526:
      v4 = (int *)(v302 + 1);
      *(_BYTE *)(v3 + v302) = 99;
      *(_DWORD *)(v3 + 256) = v302 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v302 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v303 = 1;
        v4 = 0;
        goto LABEL_528;
      }
LABEL_527:
      v303 = (int)v4 + 1;
LABEL_528:
      *((_BYTE *)v4 + v3) = 116;
      *(_DWORD *)(v3 + 256) = v303;
      *(_BYTE *)(v3 + 260) = 116;
      return (unsigned int)v4;
    case 0x11u:
      v4 = *(int **)(v3 + 256);
      v261 = "covariant return thunk to ";
      do
      {
        v263 = *v261;
        if ( v4 == (int *)255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v264 = v263;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v4 = (int *)1;
          v262 = 0;
          v263 = v264;
        }
        else
        {
          v262 = v4;
          v4 = (int *)((char *)v4 + 1);
        }
        *((_BYTE *)v262 + v3) = v263;
        *(_DWORD *)(v3 + 256) = v4;
        *(_BYTE *)(v3 + 260) = v263;
        ++v261;
      }
      while ( v261 != "" );
      v276 = *(_DWORD *)(v396 + 4);
      if ( v276 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, v400, v276);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
    case 0x23u:
      v4 = *(int **)(a3 + 4);
      if ( a2 & 4 )
      {
        v306 = v4[3];
        v307 = v4[2];
        if ( v306 )
        {
          v4 = *(int **)(v3 + 256);
          v308 = 0;
          do
          {
            v310 = *(_BYTE *)(v307 + v308);
            if ( v4 == (int *)255 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              v311 = v310;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v4 = (int *)1;
              v309 = 0;
              v310 = v311;
            }
            else
            {
              v309 = v4;
              v4 = (int *)((char *)v4 + 1);
            }
            *((_BYTE *)v309 + v3) = v310;
            *(_DWORD *)(v3 + 256) = v4;
            *(_BYTE *)(v3 + 260) = v310;
            ++v308;
          }
          while ( v306 != v308 );
        }
      }
      else
      {
        v265 = v4[1];
        v266 = *v4;
        if ( v265 )
        {
          v4 = *(int **)(v3 + 256);
          v267 = 0;
          do
          {
            v269 = *(_BYTE *)(v266 + v267);
            if ( v4 == (int *)255 )
            {
              *(_BYTE *)(v3 + 255) = 0;
              v270 = v269;
              (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
              ++*(_DWORD *)(v3 + 288);
              v4 = (int *)1;
              v268 = 0;
              v269 = v270;
            }
            else
            {
              v268 = v4;
              v4 = (int *)((char *)v4 + 1);
            }
            *((_BYTE *)v268 + v3) = v269;
            *(_DWORD *)(v3 + 256) = v4;
            *(_BYTE *)(v3 + 260) = v269;
            ++v267;
          }
          while ( v265 != v267 );
        }
      }
      return (unsigned int)v4;
    case 0x1Fu:
    case 0x20u:
      v271 = *(_DWORD *)(a3 + 4);
      v272 = *(int **)v271;
      v119 = *(_DWORD *)(v3 + 272);
      if ( *(_DWORD *)v271 != 5 )
        goto LABEL_449;
      if ( !v119 )
        goto LABEL_796;
      v372 = *(_DWORD *)(v271 + 4);
      v373 = *(_DWORD *)(*(_DWORD *)(v119 + 4) + 8);
      if ( !v373 || *(_DWORD *)v373 != 43 )
        goto LABEL_796;
      if ( v372 > 0 )
      {
        while ( 1 )
        {
          --v372;
          v373 = *(_DWORD *)(v373 + 8);
          if ( !v373 || *(_DWORD *)v373 != 43 )
            break;
          if ( !v372 )
            goto LABEL_901;
        }
      }
      else if ( !v372 )
      {
LABEL_901:
        v271 = *(_DWORD *)(v373 + 4);
        if ( v271 )
        {
          v272 = *(int **)v271;
          if ( *(_DWORD *)v271 != 43 )
          {
LABEL_449:
            if ( v272 == (int *)31 || v4 == v272 )
            {
              v118 = *(_DWORD *)(v3 + 276);
              v396 = v271;
              v120 = v271;
              goto LABEL_203;
            }
            if ( v272 != (int *)32 )
            {
              v118 = *(_DWORD *)(v3 + 276);
              v120 = v396;
              goto LABEL_203;
            }
            v121 = *(_DWORD *)(v271 + 4);
            v413 = *(_DWORD *)(v3 + 276);
            *(_DWORD *)(v3 + 276) = &v413;
            v414 = v396;
            v415 = 0;
            v416 = v119;
            if ( !v121 )
            {
LABEL_204:
              v121 = *(_DWORD *)(v396 + 4);
              if ( !v121 )
              {
                *(_DWORD *)(v3 + 280) = 1;
                v122 = v415;
                goto LABEL_206;
              }
            }
            if ( *(_DWORD *)(v3 + 280) )
              goto LABEL_466;
            d_print_comp_part_8(v3, v400, v121);
            v122 = v415;
LABEL_206:
            if ( v122 )
            {
LABEL_207:
              LOBYTE(v4) = v413;
              *(_DWORD *)(v3 + 276) = v413;
              return (unsigned int)v4;
            }
LABEL_466:
            d_print_mod(v3, v400, v396);
            goto LABEL_207;
          }
          v385 = *(_DWORD *)(v3 + 284);
          while ( v385 > 0 )
          {
            --v385;
            v271 = *(_DWORD *)(v271 + 8);
            if ( !v271 || *(_DWORD *)v271 != 43 )
              goto LABEL_796;
          }
          if ( !v385 )
          {
            v271 = *(_DWORD *)(v271 + 4);
            if ( v271 )
            {
              v272 = *(int **)v271;
              goto LABEL_449;
            }
          }
        }
      }
LABEL_796:
      *(_DWORD *)(v3 + 280) = 1;
      return (unsigned int)v4;
    case 0x24u:
      LOBYTE(v4) = a3;
      v273 = *(_DWORD *)(a3 + 4);
      if ( v273 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          LOBYTE(v4) = d_print_comp_part_8(v3, a2, v273);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      return (unsigned int)v4;
  }
}
// 41D0E0: using guessed type char *off_41D0E0;
// 402C34: using guessed type char var_1C[28];

//----- (00408ABC) --------------------------------------------------------
char __usercall d_print_comp@<al>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  if ( a3 )
  {
    if ( !*(_DWORD *)(result + 280) )
      LOBYTE(result) = d_print_comp_part_8(result, a2, a3);
  }
  else
  {
    *(_DWORD *)(result + 280) = 1;
  }
  return result;
}

//----- (00408AE0) --------------------------------------------------------
int __usercall d_print_cast_isra_10_part_11@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>)
{
  int v3; // ebx@1
  int v4; // edi@1
  int *v5; // esi@1
  int v6; // ebp@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // edx@5
  int result; // eax@7
  int v11; // ecx@8
  int v12; // edx@12
  int v13; // edx@15
  int v14; // eax@19
  int v15; // [sp+18h] [bp-24h]@1
  int v16; // [sp+1Ch] [bp-20h]@1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = *(_DWORD *)(a1 + 276);
  *(_DWORD *)(a1 + 276) = 0;
  v7 = *(_DWORD *)(a1 + 272);
  v15 = v7;
  *(_DWORD *)(v3 + 272) = &v15;
  v16 = *a3;
  v8 = *(_DWORD *)(v16 + 4);
  if ( v8 )
  {
    if ( !*(_DWORD *)(v3 + 280) )
    {
      d_print_comp_part_8(v3, a2, v8);
      v7 = v15;
    }
  }
  else
  {
    *(_DWORD *)(v3 + 280) = 1;
  }
  *(_DWORD *)(v3 + 272) = v7;
  if ( *(_BYTE *)(v3 + 260) == 60 )
  {
    v14 = *(_DWORD *)(v3 + 256);
    if ( v14 == 255 )
    {
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v9 = 1;
      v14 = 0;
    }
    else
    {
      v9 = v14 + 1;
    }
    *(_BYTE *)(v3 + v14) = 32;
    *(_DWORD *)(v3 + 256) = v9;
    *(_BYTE *)(v3 + 260) = 32;
  }
  else
  {
    v9 = *(_DWORD *)(v3 + 256);
  }
  if ( v9 == 255 )
  {
    *(_BYTE *)(v3 + 255) = 0;
    (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
    ++*(_DWORD *)(v3 + 288);
    result = 1;
    v9 = 0;
  }
  else
  {
    result = v9 + 1;
  }
  *(_BYTE *)(v3 + v9) = 60;
  *(_DWORD *)(v3 + 256) = result;
  *(_BYTE *)(v3 + 260) = 60;
  v11 = *(_DWORD *)(*v5 + 8);
  if ( v11 )
  {
    if ( !*(_DWORD *)(v3 + 280) )
    {
      d_print_comp_part_8(v3, v4, v11);
      result = *(_DWORD *)(v3 + 256);
      if ( *(_BYTE *)(v3 + 260) == 62 )
      {
        if ( result == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          result = 1;
          v13 = 0;
        }
        else
        {
          v13 = *(_DWORD *)(v3 + 256);
          ++result;
        }
        *(_BYTE *)(v3 + v13) = 32;
        *(_DWORD *)(v3 + 256) = result;
        *(_BYTE *)(v3 + 260) = 32;
        if ( result != 255 )
          goto LABEL_12;
LABEL_17:
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v12 = 1;
        result = 0;
        goto LABEL_13;
      }
    }
  }
  else
  {
    *(_DWORD *)(v3 + 280) = 1;
  }
  if ( result == 255 )
    goto LABEL_17;
LABEL_12:
  v12 = result + 1;
LABEL_13:
  *(_BYTE *)(v3 + result) = 62;
  *(_DWORD *)(v3 + 256) = v12;
  *(_BYTE *)(v3 + 260) = 62;
  *(_DWORD *)(v3 + 276) = v6;
  return result;
}

//----- (00408D0C) --------------------------------------------------------
char __usercall d_print_subexpr@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>)
{
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // eax@4
  int v6; // esi@5
  signed int v7; // esi@6
  int v8; // eax@8
  int v9; // edx@12
  int v10; // ST08_4@14
  int v11; // ST1C_4@15
  _DWORD *v12; // ST18_4@15

  v3 = a1;
  v4 = *a3;
  if ( *a3 <= 1u || v4 == 44 || v4 == 6 )
  {
    v7 = 1;
  }
  else
  {
    v5 = *(_DWORD *)(v3 + 256);
    if ( v5 == 255 )
    {
      *(_BYTE *)(v3 + 255) = 0;
      v11 = a2;
      v12 = a3;
      (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v6 = 1;
      v5 = 0;
      a3 = v12;
      a2 = v11;
    }
    else
    {
      v6 = v5 + 1;
    }
    *(_BYTE *)(v3 + v5) = 40;
    *(_DWORD *)(v3 + 256) = v6;
    *(_BYTE *)(v3 + 260) = 40;
    v7 = 0;
  }
  v8 = *(_DWORD *)(v3 + 280);
  if ( !v8 )
    LOBYTE(v8) = d_print_comp_part_8(v3, a2, (int)a3);
  if ( !v7 )
  {
    v8 = *(_DWORD *)(v3 + 256);
    if ( v8 == 255 )
    {
      *(_BYTE *)(v3 + 255) = 0;
      v10 = *(_DWORD *)(v3 + 268);
      (*(void (__fastcall **)(_DWORD *, int))(v3 + 264))(a3, a2);
      ++*(_DWORD *)(v3 + 288);
      v9 = 1;
      v8 = 0;
    }
    else
    {
      v9 = v8 + 1;
    }
    *(_BYTE *)(v3 + v8) = 41;
    *(_DWORD *)(v3 + 256) = v9;
    *(_BYTE *)(v3 + 260) = 41;
  }
  return v8;
}

//----- (00408E10) --------------------------------------------------------
int __usercall d_print_array_type_isra_7@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int *v6; // ebp@1
  int *v7; // ecx@1
  int v8; // ebx@2
  int v9; // eax@6
  int v10; // edx@8
  int result; // eax@11
  int v12; // edx@16
  int v13; // edx@19
  int v14; // eax@20
  int v15; // edx@21
  int v16; // edx@22

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = (int *)a4;
  if ( a4 )
  {
    v8 = a4;
    while ( *(_DWORD *)(v8 + 8) )
    {
      v8 = *(_DWORD *)v8;
      if ( !v8 )
      {
        d_print_mod_list(a1, a2, (int *)a4, 0);
        goto LABEL_6;
      }
    }
    if ( **(_DWORD **)(v8 + 4) == 38 )
    {
      d_print_mod_list(a1, a2, (int *)a4, 0);
      v10 = *(_DWORD *)(v4 + 256);
      goto LABEL_10;
    }
    v13 = *(_DWORD *)(a1 + 256);
    if ( v13 == 255 )
    {
      *(_BYTE *)(a1 + 255) = 0;
      (*(void (__cdecl **)(int, signed int, _DWORD))(a1 + 264))(a1, 255, *(_DWORD *)(a1 + 268));
      ++*(_DWORD *)(v4 + 288);
      *(_BYTE *)v4 = 32;
      v14 = 1;
      v7 = (int *)a4;
    }
    else
    {
      v14 = v13 + 1;
      *(_BYTE *)(v4 + v13) = 32;
      *(_DWORD *)(v4 + 256) = v13 + 1;
      *(_BYTE *)(v4 + 260) = 32;
      if ( v13 == 254 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        ++*(_DWORD *)(v4 + 288);
        v15 = 1;
        v14 = 0;
        v7 = (int *)a4;
        goto LABEL_22;
      }
    }
    v15 = v14 + 1;
LABEL_22:
    *(_BYTE *)(v4 + v14) = 40;
    *(_DWORD *)(v4 + 256) = v15;
    *(_BYTE *)(v4 + 260) = 40;
    d_print_mod_list(v4, v5, v7, 0);
    v16 = *(_DWORD *)(v4 + 256);
    if ( v16 == 255 )
    {
      *(_BYTE *)(v4 + 255) = 0;
      (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
      ++*(_DWORD *)(v4 + 288);
      v9 = 1;
      v16 = 0;
    }
    else
    {
      v9 = v16 + 1;
    }
    *(_BYTE *)(v4 + v16) = 41;
    *(_DWORD *)(v4 + 256) = v9;
    *(_BYTE *)(v4 + 260) = 41;
    goto LABEL_7;
  }
LABEL_6:
  v9 = *(_DWORD *)(v4 + 256);
LABEL_7:
  if ( v9 == 255 )
  {
    *(_BYTE *)(v4 + 255) = 0;
    (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
    ++*(_DWORD *)(v4 + 288);
    v10 = 1;
    v9 = 0;
  }
  else
  {
    v10 = v9 + 1;
  }
  *(_BYTE *)(v4 + v9) = 32;
  *(_DWORD *)(v4 + 256) = v10;
  *(_BYTE *)(v4 + 260) = 32;
LABEL_10:
  if ( v10 == 255 )
  {
    *(_BYTE *)(v4 + 255) = 0;
    (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
    ++*(_DWORD *)(v4 + 288);
    result = 1;
    v10 = 0;
  }
  else
  {
    result = v10 + 1;
  }
  *(_BYTE *)(v4 + v10) = 91;
  *(_DWORD *)(v4 + 256) = result;
  *(_BYTE *)(v4 + 260) = 91;
  if ( *v6 && !*(_DWORD *)(v4 + 280) )
  {
    d_print_comp_part_8(v4, v5, *v6);
    result = *(_DWORD *)(v4 + 256);
  }
  if ( result == 255 )
  {
    *(_BYTE *)(v4 + 255) = 0;
    (*(void (__cdecl **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
    ++*(_DWORD *)(v4 + 288);
    v12 = 1;
    result = 0;
  }
  else
  {
    v12 = result + 1;
  }
  *(_BYTE *)(v4 + result) = 93;
  *(_DWORD *)(v4 + 256) = v12;
  *(_BYTE *)(v4 + 260) = 93;
  return result;
}

//----- (004090C4) --------------------------------------------------------
char __usercall d_print_expr_op@<al>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edx@5
  int v4; // edi@5
  int v5; // ebp@5
  signed int v6; // edx@6
  int v7; // ebx@6
  signed int v8; // esi@7
  char v9; // cl@9
  int v10; // ST18_4@10
  char v11; // ST1C_1@10

  if ( *(_DWORD *)a3 == 45 )
  {
    v3 = *(_DWORD *)(a3 + 4);
    v4 = *(_DWORD *)(v3 + 8);
    v5 = *(_DWORD *)(v3 + 4);
    if ( v4 )
    {
      v6 = *(_DWORD *)(result + 256);
      v7 = 0;
      do
      {
        v9 = *(_BYTE *)(v5 + v7);
        if ( v6 == 255 )
        {
          *(_BYTE *)(result + 255) = 0;
          v10 = result;
          v11 = v9;
          (*(void (__cdecl **)(int, signed int, _DWORD))(result + 264))(result, 255, *(_DWORD *)(result + 268));
          result = v10;
          ++*(_DWORD *)(result + 288);
          v6 = 1;
          v8 = 0;
          v9 = v11;
        }
        else
        {
          v8 = v6++;
        }
        *(_BYTE *)(result + v8) = v9;
        *(_DWORD *)(result + 256) = v6;
        *(_BYTE *)(result + 260) = v9;
        ++v7;
      }
      while ( v4 != v7 );
    }
  }
  else if ( !*(_DWORD *)(result + 280) )
  {
    LOBYTE(result) = d_print_comp_part_8(result, a2, a3);
  }
  return result;
}

//----- (00409164) --------------------------------------------------------
char __usercall d_print_mod@<al>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  unsigned int v4; // eax@1
  int v5; // ST1C_4@4
  int v6; // ST18_4@4
  int v7; // esi@4
  int v8; // eax@5
  int v9; // ST1C_4@6
  int v10; // ST18_4@6
  int v11; // esi@6
  int v12; // eax@7
  int v13; // ST1C_4@8
  int v14; // ST18_4@8
  int v15; // esi@8
  int v16; // eax@9
  int v17; // ST1C_4@10
  int v18; // ST18_4@10
  int v19; // esi@10
  int v20; // eax@11
  int v21; // ST1C_4@12
  int v22; // ST18_4@12
  int v23; // esi@12
  int v24; // ecx@14
  int v25; // edx@18
  int v26; // eax@24
  int v27; // edx@25
  int v28; // eax@26
  int v29; // edx@27
  int v30; // eax@28
  int v31; // edx@29
  int v32; // eax@30
  int v33; // edx@31
  int v34; // edx@33
  int v35; // eax@35
  int v36; // edx@36
  int v37; // eax@37
  int v38; // edx@38
  int v39; // eax@39
  int v40; // edx@40
  int v41; // eax@41
  int v42; // edx@42
  int v43; // edx@44
  int v44; // edx@46
  int v45; // eax@47
  int v46; // edx@48
  int v47; // eax@49
  int v48; // edx@50
  int v49; // esi@54
  int v50; // edx@59
  int v51; // edx@61
  int v52; // ST08_4@65
  int v53; // edx@66
  int v54; // eax@67
  int v55; // edx@68
  int v56; // eax@69
  int v57; // edx@70
  int v58; // eax@71
  int v59; // edx@72
  int v60; // edx@74
  int v61; // edx@76
  int v62; // eax@77
  int v63; // edx@78
  int v64; // eax@79
  int v65; // edx@80
  int v66; // eax@81
  int v67; // edx@82
  int v68; // eax@83
  int v69; // edx@84
  int v70; // eax@88
  int v71; // esi@89
  int v72; // ecx@91
  int v73; // eax@94
  int v74; // edx@95
  int v75; // eax@99
  int v76; // ST1C_4@101
  int v77; // ST18_4@101
  int v78; // ST1C_4@103
  int v79; // ST18_4@103
  int v80; // ST1C_4@105
  int v81; // ST18_4@105
  int v82; // ST1C_4@107
  int v83; // ST18_4@107
  int v84; // ST1C_4@109
  int v85; // ST18_4@109
  int v86; // ST08_4@144
  int v87; // ST08_4@145
  int v88; // ST1C_4@150
  int v89; // ST18_4@150
  int v90; // ST08_4@151
  int v91; // ST08_4@152
  int v92; // ST1C_4@153
  int v93; // ST18_4@153

  v3 = a1;
  v4 = *(_DWORD *)a3 - 3;
  if ( v4 > 0x26 )
  {
LABEL_2:
    v4 = *(_DWORD *)(v3 + 280);
    if ( !v4 )
      LOBYTE(v4) = d_print_comp_part_8(v3, a2, a3);
    return v4;
  }
  switch ( *(_DWORD *)a3 )
  {
    default:
      goto LABEL_2;
    case 3:
      a3 = *(_DWORD *)(a3 + 4);
      if ( !a3 )
        goto LABEL_23;
      goto LABEL_2;
    case 0x17:
    case 0x1A:
      v26 = *(_DWORD *)(v3 + 256);
      if ( v26 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v86 = *(_DWORD *)(v3 + 268);
        (*(void (__fastcall **)(int, int))(v3 + 264))(a3, a2);
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v27 = 1;
      }
      else
      {
        v27 = v26 + 1;
        *(_BYTE *)(v3 + v26) = 32;
        *(_DWORD *)(v3 + 256) = v26 + 1;
        *(_BYTE *)(v3 + 260) = 32;
        if ( v26 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 114;
          v28 = 1;
          goto LABEL_27;
        }
      }
      v28 = v27 + 1;
      *(_BYTE *)(v3 + v27) = 114;
      *(_DWORD *)(v3 + 256) = v27 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v27 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v29 = 1;
        goto LABEL_28;
      }
LABEL_27:
      v29 = v28 + 1;
      *(_BYTE *)(v3 + v28) = 101;
      *(_DWORD *)(v3 + 256) = v28 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v28 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 115;
        v30 = 1;
        goto LABEL_29;
      }
LABEL_28:
      v30 = v29 + 1;
      *(_BYTE *)(v3 + v29) = 115;
      *(_DWORD *)(v3 + 256) = v29 + 1;
      *(_BYTE *)(v3 + 260) = 115;
      if ( v29 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v31 = 1;
        goto LABEL_30;
      }
LABEL_29:
      v31 = v30 + 1;
      *(_BYTE *)(v3 + v30) = 116;
      *(_DWORD *)(v3 + 256) = v30 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v30 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v32 = 1;
        goto LABEL_31;
      }
LABEL_30:
      v32 = v31 + 1;
      *(_BYTE *)(v3 + v31) = 114;
      *(_DWORD *)(v3 + 256) = v31 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v31 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 105;
        v33 = 1;
        goto LABEL_32;
      }
LABEL_31:
      v33 = v32 + 1;
      *(_BYTE *)(v3 + v32) = 105;
      *(_DWORD *)(v3 + 256) = v32 + 1;
      *(_BYTE *)(v3 + 260) = 105;
      if ( v32 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v4 = 1;
        goto LABEL_33;
      }
LABEL_32:
      v4 = v33 + 1;
      *(_BYTE *)(v3 + v33) = 99;
      *(_DWORD *)(v3 + 256) = v33 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v33 == 254 )
        goto LABEL_52;
      goto LABEL_33;
    case 0x18:
    case 0x1B:
      v35 = *(_DWORD *)(v3 + 256);
      if ( v35 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v91 = *(_DWORD *)(v3 + 268);
        (*(void (__fastcall **)(int, int))(v3 + 264))(a3, a2);
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v36 = 1;
      }
      else
      {
        v36 = v35 + 1;
        *(_BYTE *)(v3 + v35) = 32;
        *(_DWORD *)(v3 + 256) = v35 + 1;
        *(_BYTE *)(v3 + 260) = 32;
        if ( v35 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 118;
          v37 = 1;
          goto LABEL_38;
        }
      }
      v37 = v36 + 1;
      *(_BYTE *)(v3 + v36) = 118;
      *(_DWORD *)(v3 + 256) = v36 + 1;
      *(_BYTE *)(v3 + 260) = 118;
      if ( v36 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v38 = 1;
        goto LABEL_39;
      }
LABEL_38:
      v38 = v37 + 1;
      *(_BYTE *)(v3 + v37) = 111;
      *(_DWORD *)(v3 + 256) = v37 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v37 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v39 = 1;
        goto LABEL_40;
      }
LABEL_39:
      v39 = v38 + 1;
      *(_BYTE *)(v3 + v38) = 108;
      *(_DWORD *)(v3 + 256) = v38 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v38 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v40 = 1;
        goto LABEL_41;
      }
LABEL_40:
      v40 = v39 + 1;
      *(_BYTE *)(v3 + v39) = 97;
      *(_DWORD *)(v3 + 256) = v39 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v39 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v41 = 1;
        goto LABEL_42;
      }
LABEL_41:
      v41 = v40 + 1;
      *(_BYTE *)(v3 + v40) = 116;
      *(_DWORD *)(v3 + 256) = v40 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v40 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 105;
        v42 = 1;
        goto LABEL_43;
      }
LABEL_42:
      v42 = v41 + 1;
      *(_BYTE *)(v3 + v41) = 105;
      *(_DWORD *)(v3 + 256) = v41 + 1;
      *(_BYTE *)(v3 + 260) = 105;
      if ( v41 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v4 = 1;
        goto LABEL_44;
      }
LABEL_43:
      v4 = v42 + 1;
      *(_BYTE *)(v3 + v42) = 108;
      *(_DWORD *)(v3 + 256) = v42 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v42 != 254 )
      {
LABEL_44:
        v43 = v4 + 1;
        goto LABEL_45;
      }
      *(_BYTE *)(v3 + 255) = 0;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v43 = 1;
      v4 = 0;
LABEL_45:
      *(_BYTE *)(v3 + v4) = 101;
      *(_DWORD *)(v3 + 256) = v43;
      *(_BYTE *)(v3 + 260) = 101;
      return v4;
    case 0x19:
    case 0x1C:
      v44 = *(_DWORD *)(v3 + 256);
      if ( v44 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v45 = 1;
      }
      else
      {
        v45 = v44 + 1;
        *(_BYTE *)(v3 + v44) = 32;
        *(_DWORD *)(v3 + 256) = v44 + 1;
        *(_BYTE *)(v3 + 260) = 32;
        if ( v44 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 99;
          v46 = 1;
          goto LABEL_49;
        }
      }
      v46 = v45 + 1;
      *(_BYTE *)(v3 + v45) = 99;
      *(_DWORD *)(v3 + 256) = v45 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v45 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v47 = 1;
        goto LABEL_50;
      }
LABEL_49:
      v47 = v46 + 1;
      *(_BYTE *)(v3 + v46) = 111;
      *(_DWORD *)(v3 + 256) = v46 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v46 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 110;
        v48 = 1;
        goto LABEL_51;
      }
LABEL_50:
      v48 = v47 + 1;
      *(_BYTE *)(v3 + v47) = 110;
      *(_DWORD *)(v3 + 256) = v47 + 1;
      *(_BYTE *)(v3 + 260) = 110;
      if ( v47 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 115;
        v4 = 1;
        goto LABEL_33;
      }
LABEL_51:
      v4 = v48 + 1;
      *(_BYTE *)(v3 + v48) = 115;
      *(_DWORD *)(v3 + 256) = v48 + 1;
      *(_BYTE *)(v3 + 260) = 115;
      if ( v48 == 254 )
      {
LABEL_52:
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v34 = 1;
        v4 = 0;
LABEL_34:
        *(_BYTE *)(v3 + v4) = 116;
        *(_DWORD *)(v3 + 256) = v34;
        *(_BYTE *)(v3 + 260) = 116;
        return v4;
      }
LABEL_33:
      v34 = v4 + 1;
      goto LABEL_34;
    case 0x1D:
      v4 = *(_DWORD *)(v3 + 256);
      if ( v4 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v88 = a2;
        v89 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v49 = 1;
        v4 = 0;
        a3 = v89;
        a2 = v88;
      }
      else
      {
        v49 = v4 + 1;
      }
      *(_BYTE *)(v3 + v4) = 32;
      *(_DWORD *)(v3 + 256) = v49;
      *(_BYTE *)(v3 + 260) = 32;
      a3 = *(_DWORD *)(a3 + 8);
      if ( a3 )
        goto LABEL_2;
LABEL_23:
      *(_DWORD *)(v3 + 280) = 1;
      return v4;
    case 0x1E:
      if ( a2 & 4 )
        return v4;
      v4 = *(_DWORD *)(v3 + 256);
      if ( v4 == 255 )
        goto LABEL_59;
      goto LABEL_97;
    case 0x1F:
      v4 = *(_DWORD *)(v3 + 256);
      if ( v4 != 255 )
        goto LABEL_61;
      goto LABEL_65;
    case 0x20:
      a2 = *(_DWORD *)(v3 + 256);
      if ( a2 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 38;
        v4 = 1;
      }
      else
      {
        v4 = a2 + 1;
        *(_BYTE *)(v3 + a2) = 38;
        *(_DWORD *)(v3 + 256) = a2 + 1;
        *(_BYTE *)(v3 + 260) = 38;
        if ( a2 == 254 )
        {
LABEL_65:
          *(_BYTE *)(v3 + 255) = 0;
          v52 = *(_DWORD *)(v3 + 268);
          (*(void (__fastcall **)(int, int))(v3 + 264))(a3, a2);
          ++*(_DWORD *)(v3 + 288);
          v51 = 1;
          v4 = 0;
LABEL_62:
          *(_BYTE *)(v3 + v4) = 38;
          *(_DWORD *)(v3 + 256) = v51;
          *(_BYTE *)(v3 + 260) = 38;
          return v4;
        }
      }
LABEL_61:
      v51 = v4 + 1;
      goto LABEL_62;
    case 0x21:
      v53 = *(_DWORD *)(v3 + 256);
      if ( v53 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v54 = 1;
      }
      else
      {
        v54 = v53 + 1;
        *(_BYTE *)(v3 + v53) = 99;
        *(_DWORD *)(v3 + 256) = v53 + 1;
        *(_BYTE *)(v3 + 260) = 99;
        if ( v53 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 111;
          v55 = 1;
          goto LABEL_69;
        }
      }
      v55 = v54 + 1;
      *(_BYTE *)(v3 + v54) = 111;
      *(_DWORD *)(v3 + 256) = v54 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v54 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 109;
        v56 = 1;
        goto LABEL_70;
      }
LABEL_69:
      v56 = v55 + 1;
      *(_BYTE *)(v3 + v55) = 109;
      *(_DWORD *)(v3 + 256) = v55 + 1;
      *(_BYTE *)(v3 + 260) = 109;
      if ( v55 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 112;
        v57 = 1;
        goto LABEL_71;
      }
LABEL_70:
      v57 = v56 + 1;
      *(_BYTE *)(v3 + v56) = 112;
      *(_DWORD *)(v3 + 256) = v56 + 1;
      *(_BYTE *)(v3 + 260) = 112;
      if ( v56 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 108;
        v58 = 1;
        goto LABEL_72;
      }
LABEL_71:
      v58 = v57 + 1;
      *(_BYTE *)(v3 + v57) = 108;
      *(_DWORD *)(v3 + 256) = v57 + 1;
      *(_BYTE *)(v3 + 260) = 108;
      if ( v57 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v59 = 1;
        goto LABEL_73;
      }
LABEL_72:
      v59 = v58 + 1;
      *(_BYTE *)(v3 + v58) = 101;
      *(_DWORD *)(v3 + 256) = v58 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v58 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 120;
        v4 = 1;
        goto LABEL_74;
      }
LABEL_73:
      v4 = v59 + 1;
      *(_BYTE *)(v3 + v59) = 120;
      *(_DWORD *)(v3 + 256) = v59 + 1;
      *(_BYTE *)(v3 + 260) = 120;
      if ( v59 == 254 )
        goto LABEL_86;
      goto LABEL_74;
    case 0x22:
      v61 = *(_DWORD *)(v3 + 256);
      if ( v61 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 105;
        v62 = 1;
      }
      else
      {
        v62 = v61 + 1;
        *(_BYTE *)(v3 + v61) = 105;
        *(_DWORD *)(v3 + 256) = v61 + 1;
        *(_BYTE *)(v3 + 260) = 105;
        if ( v61 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 109;
          v63 = 1;
          goto LABEL_79;
        }
      }
      v63 = v62 + 1;
      *(_BYTE *)(v3 + v62) = 109;
      *(_DWORD *)(v3 + 256) = v62 + 1;
      *(_BYTE *)(v3 + 260) = 109;
      if ( v62 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v64 = 1;
        goto LABEL_80;
      }
LABEL_79:
      v64 = v63 + 1;
      *(_BYTE *)(v3 + v63) = 97;
      *(_DWORD *)(v3 + 256) = v63 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v63 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 103;
        v65 = 1;
        goto LABEL_81;
      }
LABEL_80:
      v65 = v64 + 1;
      *(_BYTE *)(v3 + v64) = 103;
      *(_DWORD *)(v3 + 256) = v64 + 1;
      *(_BYTE *)(v3 + 260) = 103;
      if ( v64 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 105;
        v66 = 1;
        goto LABEL_82;
      }
LABEL_81:
      v66 = v65 + 1;
      *(_BYTE *)(v3 + v65) = 105;
      *(_DWORD *)(v3 + 256) = v65 + 1;
      *(_BYTE *)(v3 + 260) = 105;
      if ( v65 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 110;
        v67 = 1;
        goto LABEL_83;
      }
LABEL_82:
      v67 = v66 + 1;
      *(_BYTE *)(v3 + v66) = 110;
      *(_DWORD *)(v3 + 256) = v66 + 1;
      *(_BYTE *)(v3 + 260) = 110;
      if ( v66 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 97;
        v68 = 1;
        goto LABEL_84;
      }
LABEL_83:
      v68 = v67 + 1;
      *(_BYTE *)(v3 + v67) = 97;
      *(_DWORD *)(v3 + 256) = v67 + 1;
      *(_BYTE *)(v3 + 260) = 97;
      if ( v67 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v69 = 1;
        goto LABEL_85;
      }
LABEL_84:
      v69 = v68 + 1;
      *(_BYTE *)(v3 + v68) = 114;
      *(_DWORD *)(v3 + 256) = v68 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v68 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 121;
        v4 = 1;
        goto LABEL_74;
      }
LABEL_85:
      v4 = v69 + 1;
      *(_BYTE *)(v3 + v69) = 121;
      *(_DWORD *)(v3 + 256) = v69 + 1;
      *(_BYTE *)(v3 + 260) = 121;
      if ( v69 == 254 )
      {
LABEL_86:
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v60 = 1;
        v4 = 0;
LABEL_75:
        *(_BYTE *)(v3 + v4) = 32;
        *(_DWORD *)(v3 + 256) = v60;
        *(_BYTE *)(v3 + 260) = 32;
        return v4;
      }
LABEL_74:
      v60 = v4 + 1;
      goto LABEL_75;
    case 0x27:
      if ( *(_BYTE *)(v3 + 260) != 40 )
      {
        v70 = *(_DWORD *)(v3 + 256);
        if ( v70 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v92 = a2;
          v93 = a3;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v71 = 1;
          v70 = 0;
          a3 = v93;
          a2 = v92;
        }
        else
        {
          v71 = v70 + 1;
        }
        *(_BYTE *)(v3 + v70) = 32;
        *(_DWORD *)(v3 + 256) = v71;
        *(_BYTE *)(v3 + 260) = 32;
      }
      v72 = *(_DWORD *)(a3 + 4);
      if ( v72 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          d_print_comp_part_8(v3, a2, v72);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      v73 = *(_DWORD *)(v3 + 256);
      if ( v73 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v87 = *(_DWORD *)(v3 + 268);
        (*(void (__fastcall **)(int, int))(v3 + 264))(v72, a2);
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 58;
        v74 = 1;
      }
      else
      {
        v74 = v73 + 1;
        *(_BYTE *)(v3 + v73) = 58;
        *(_DWORD *)(v3 + 256) = v73 + 1;
        *(_BYTE *)(v3 + 260) = 58;
        if ( v73 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 58;
          v4 = 1;
          goto LABEL_97;
        }
      }
      v4 = v74 + 1;
      *(_BYTE *)(v3 + v74) = 58;
      *(_DWORD *)(v3 + 256) = v74 + 1;
      *(_BYTE *)(v3 + 260) = 58;
      if ( v74 == 254 )
      {
LABEL_59:
        *(_BYTE *)(v3 + 255) = 0;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v50 = 1;
        v4 = 0;
        goto LABEL_98;
      }
LABEL_97:
      v50 = v4 + 1;
LABEL_98:
      *(_BYTE *)(v3 + v4) = 42;
      *(_DWORD *)(v3 + 256) = v50;
      *(_BYTE *)(v3 + 260) = 42;
      return v4;
    case 0x29:
      v75 = *(_DWORD *)(v3 + 256);
      if ( v75 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v5 = a2;
        v6 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 32;
        v7 = 1;
        a2 = v5;
        a3 = v6;
      }
      else
      {
        v7 = v75 + 1;
        *(_BYTE *)(v3 + v75) = 32;
        *(_DWORD *)(v3 + 256) = v75 + 1;
        *(_BYTE *)(v3 + 260) = 32;
        if ( v75 == 254 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          v76 = a2;
          v77 = a3;
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          *(_BYTE *)v3 = 95;
          v8 = 1;
          a2 = v76;
          a3 = v77;
          goto LABEL_102;
        }
      }
      v8 = v7 + 1;
      *(_BYTE *)(v3 + v7) = 95;
      *(_DWORD *)(v3 + 256) = v7 + 1;
      *(_BYTE *)(v3 + 260) = 95;
      if ( v7 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v9 = a2;
        v10 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 95;
        v11 = 1;
        a2 = v9;
        a3 = v10;
        goto LABEL_7;
      }
LABEL_102:
      v11 = v8 + 1;
      *(_BYTE *)(v3 + v8) = 95;
      *(_DWORD *)(v3 + 256) = v8 + 1;
      *(_BYTE *)(v3 + 260) = 95;
      if ( v8 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v78 = a2;
        v79 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 118;
        v12 = 1;
        a2 = v78;
        a3 = v79;
        goto LABEL_104;
      }
LABEL_7:
      v12 = v11 + 1;
      *(_BYTE *)(v3 + v11) = 118;
      *(_DWORD *)(v3 + 256) = v11 + 1;
      *(_BYTE *)(v3 + 260) = 118;
      if ( v11 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v13 = a2;
        v14 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 101;
        v15 = 1;
        a2 = v13;
        a3 = v14;
        goto LABEL_9;
      }
LABEL_104:
      v15 = v12 + 1;
      *(_BYTE *)(v3 + v12) = 101;
      *(_DWORD *)(v3 + 256) = v12 + 1;
      *(_BYTE *)(v3 + 260) = 101;
      if ( v12 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v80 = a2;
        v81 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 99;
        v16 = 1;
        a2 = v80;
        a3 = v81;
        goto LABEL_106;
      }
LABEL_9:
      v16 = v15 + 1;
      *(_BYTE *)(v3 + v15) = 99;
      *(_DWORD *)(v3 + 256) = v15 + 1;
      *(_BYTE *)(v3 + 260) = 99;
      if ( v15 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v17 = a2;
        v18 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 116;
        v19 = 1;
        a2 = v17;
        a3 = v18;
        goto LABEL_11;
      }
LABEL_106:
      v19 = v16 + 1;
      *(_BYTE *)(v3 + v16) = 116;
      *(_DWORD *)(v3 + 256) = v16 + 1;
      *(_BYTE *)(v3 + 260) = 116;
      if ( v16 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v82 = a2;
        v83 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 111;
        v20 = 1;
        a2 = v82;
        a3 = v83;
        goto LABEL_108;
      }
LABEL_11:
      v20 = v19 + 1;
      *(_BYTE *)(v3 + v19) = 111;
      *(_DWORD *)(v3 + 256) = v19 + 1;
      *(_BYTE *)(v3 + 260) = 111;
      if ( v19 == 254 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v21 = a2;
        v22 = a3;
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        *(_BYTE *)v3 = 114;
        v23 = 1;
        a2 = v21;
        a3 = v22;
LABEL_13:
        v4 = v23 + 1;
        goto LABEL_14;
      }
LABEL_108:
      v23 = v20 + 1;
      *(_BYTE *)(v3 + v20) = 114;
      *(_DWORD *)(v3 + 256) = v20 + 1;
      *(_BYTE *)(v3 + 260) = 114;
      if ( v20 != 254 )
        goto LABEL_13;
      *(_BYTE *)(v3 + 255) = 0;
      v84 = a2;
      v85 = a3;
      (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
      ++*(_DWORD *)(v3 + 288);
      v4 = 1;
      v23 = 0;
      a3 = v85;
      a2 = v84;
LABEL_14:
      *(_BYTE *)(v3 + v23) = 40;
      *(_DWORD *)(v3 + 256) = v4;
      *(_BYTE *)(v3 + 260) = 40;
      v24 = *(_DWORD *)(a3 + 4);
      if ( v24 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          d_print_comp_part_8(v3, a2, v24);
          v4 = *(_DWORD *)(v3 + 256);
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v4 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        v90 = *(_DWORD *)(v3 + 268);
        (*(void (__fastcall **)(int, int))(v3 + 264))(v24, a2);
        ++*(_DWORD *)(v3 + 288);
        v25 = 1;
        v4 = 0;
      }
      else
      {
        v25 = v4 + 1;
      }
      *(_BYTE *)(v3 + v4) = 41;
      *(_DWORD *)(v3 + 256) = v25;
      *(_BYTE *)(v3 + 260) = 41;
      return v4;
  }
}

//----- (0040A6F8) --------------------------------------------------------
int __usercall d_special_name@<eax>(int a1@<eax>)
{
  int v1; // ebp@1
  int v2; // ecx@1
  int v3; // edx@1
  char v5; // bl@5
  int v6; // eax@6
  char v7; // al@7
  _BYTE *v8; // ebx@8
  int v9; // eax@9
  int v10; // edx@11
  int v11; // esi@12
  int v12; // ebx@16
  int v13; // esi@17
  int v14; // ecx@17
  int v15; // edi@17
  int v16; // edx@20
  char v17; // al@21
  int v18; // ebx@24
  int v19; // edx@31
  char v20; // al@34
  int v21; // eax@37
  int v22; // edi@38
  _BYTE *v23; // eax@39
  int v24; // edx@39
  _BYTE *v25; // eax@42
  int v26; // ecx@42
  _DWORD *v27; // ebx@51
  char v28; // cl@51
  char *v29; // edx@56
  char v30; // cl@56
  char v31; // cl@62
  char *i; // edx@64
  int v33; // eax@68
  int v34; // ecx@69
  char **v35; // ebx@71
  char v36; // si@71
  char *v37; // eax@73
  char *v38; // esi@74
  char v39; // cl@74
  int v40; // edx@75
  char v41; // al@77
  int v42; // edx@82
  int v43; // eax@83
  char v44; // dl@85
  int v45; // ecx@90
  char v46; // dl@90
  _BYTE *v47; // esi@102
  int v48; // edx@102
  _BYTE *v49; // eax@105
  int v50; // ecx@105
  int v51; // eax@110
  char v52; // al@112
  signed int v53; // ebx@115
  int v54; // edx@116
  int v55; // eax@117
  signed int v56; // [sp+18h] [bp-24h]@10
  int v57; // [sp+18h] [bp-24h]@37
  signed int v58; // [sp+18h] [bp-24h]@103
  int v59; // [sp+1Ch] [bp-20h]@25
  signed int v60; // [sp+1Ch] [bp-20h]@40
  int v61; // [sp+1Ch] [bp-20h]@102

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v2 + 20;
  v3 = *(_DWORD *)(a1 + 12);
  if ( *(_BYTE *)v3 != 84 )
  {
    if ( *(_BYTE *)v3 == 71 )
    {
      *(_DWORD *)(a1 + 12) = v3 + 1;
      v7 = *(_BYTE *)(v3 + 1);
      if ( v7 )
      {
        v8 = (_BYTE *)(v3 + 2);
        *(_DWORD *)(v1 + 12) = v3 + 2;
        switch ( v7 )
        {
          default:
            return 0;
          case 114:
            v9 = *(_BYTE *)(v3 + 2);
            if ( (_BYTE)v9 == 110 )
            {
              v8 = (_BYTE *)(v3 + 3);
              *(_DWORD *)(v1 + 12) = v3 + 3;
              v9 = *(_BYTE *)(v3 + 3);
              v56 = 1;
            }
            else
            {
              v56 = 0;
            }
            v10 = 0;
            if ( (unsigned __int8)(v9 - 48) > 9u )
              return 0;
            do
            {
              v11 = v9 + 10 * v10;
              v10 = v11 - 48;
              *(_DWORD *)(v1 + 12) = ++v8;
              v9 = *v8;
            }
            while ( (unsigned __int8)(v9 - 48) <= 9u );
            if ( v56 )
              return 0;
            if ( v11 - 48 <= 1 )
              return 0;
            if ( !(_BYTE)v9 )
              return 0;
            v12 = (int)(v8 + 1);
            *(_DWORD *)(v1 + 12) = v12;
            if ( (_BYTE)v9 != 95 )
              return 0;
            v13 = v11 - 49;
            v14 = 0;
            v15 = v12;
            break;
          case 86:
            v14 = d_name(v1);
            v19 = 19;
            return d_make_comp_constprop_21(v1, v19, v14);
          case 84:
            v20 = *(_BYTE *)(v3 + 2);
            if ( v20 && (*(_DWORD *)(v1 + 12) = v3 + 3, v20 == 110) )
            {
              v14 = d_encoding_constprop_18(v1);
              v19 = 68;
            }
            else
            {
              v14 = d_encoding_constprop_18(v1);
              v19 = 67;
            }
            return d_make_comp_constprop_21(v1, v19, v14);
          case 82:
            v57 = d_name(v1);
            v21 = *(_DWORD *)(v1 + 20);
            if ( v21 >= *(_DWORD *)(v1 + 24) )
            {
              v22 = 0;
            }
            else
            {
              v22 = *(_DWORD *)(v1 + 16) + 12 * v21;
              *(_DWORD *)(v1 + 20) = v21 + 1;
              if ( v22 )
              {
                *(_DWORD *)v22 = 60;
                v23 = *(_BYTE **)(v1 + 12);
                v24 = *v23;
                if ( (_BYTE)v24 == 110 )
                {
                  *(_DWORD *)(v1 + 12) = v23 + 1;
                  v24 = (v23++)[1];
                  v60 = 1;
                }
                else
                {
                  v60 = 0;
                }
                if ( (unsigned __int8)(v24 - 48) > 9u )
                {
                  v26 = 0;
                }
                else
                {
                  v25 = v23 + 1;
                  v26 = 0;
                  do
                  {
                    v26 = v24 + 10 * v26 - 48;
                    *(_DWORD *)(v1 + 12) = v25;
                    v24 = *v25++;
                  }
                  while ( (unsigned __int8)(v24 - 48) <= 9u );
                }
                if ( v60 )
                  v26 = -v26;
                *(_DWORD *)(v22 + 4) = v26;
              }
            }
            return d_make_comp(v1, 20, v57, v22);
          case 65:
            v14 = d_encoding_constprop_18(v1);
            v19 = 21;
            return d_make_comp_constprop_21(v1, v19, v14);
        }
        while ( *(_BYTE *)v15 )
        {
          if ( *(_BYTE *)v15 == 36 )
          {
            v52 = *(_BYTE *)(v15 + 1);
            if ( v52 == 83 )
            {
              v53 = 47;
            }
            else if ( v52 == 95 )
            {
              v53 = 46;
            }
            else
            {
              if ( v52 != 36 )
                return 0;
              v53 = 36;
            }
            v54 = *(_DWORD *)(v1 + 20);
            if ( v54 >= *(_DWORD *)(v1 + 24)
              || (v59 = *(_DWORD *)(v1 + 16) + 12 * v54,
                  v55 = *(_DWORD *)(v1 + 16) + 12 * v54,
                  *(_DWORD *)(v1 + 20) = v54 + 1,
                  !v55) )
            {
              *(_DWORD *)(v1 + 12) += 2;
              return 0;
            }
            *(_DWORD *)v55 = 59;
            *(_DWORD *)(v55 + 4) = v53;
            v15 = *(_DWORD *)(v1 + 12) + 2;
            *(_DWORD *)(v1 + 12) = v15;
            v13 -= 2;
          }
          else
          {
            v16 = 0;
            do
            {
              v17 = *(_BYTE *)(v15 + v16);
              if ( !v17 )
                break;
              if ( v17 == 36 )
                break;
              ++v16;
            }
            while ( v13 > v16 );
            v18 = *(_DWORD *)(v1 + 20);
            if ( v18 >= *(_DWORD *)(v1 + 24)
              || (v59 = *(_DWORD *)(v1 + 16) + 12 * v18, *(_DWORD *)(v1 + 20) = v18 + 1, !v59)
              || !v16 )
            {
              *(_DWORD *)(v1 + 12) += v16;
              return 0;
            }
            *(_DWORD *)v59 = 0;
            *(_DWORD *)(v59 + 4) = v15;
            *(_DWORD *)(v59 + 8) = v16;
            v15 = v16 + *(_DWORD *)(v1 + 12);
            *(_DWORD *)(v1 + 12) = v15;
            v13 -= v16;
          }
          if ( v14 )
          {
            v14 = d_make_comp(v1, 58, v14, v59);
            if ( !v14 )
              return 0;
          }
          else
          {
            v14 = v59;
          }
          if ( v13 <= 0 )
          {
            v19 = 57;
            return d_make_comp_constprop_21(v1, v19, v14);
          }
        }
      }
    }
    return 0;
  }
  *(_DWORD *)(a1 + 12) = v3 + 1;
  v5 = *(_BYTE *)(v3 + 1);
  if ( !v5 )
    return 0;
  v6 = v3 + 2;
  *(_DWORD *)(v1 + 12) = v3 + 2;
  switch ( v5 )
  {
    default:
      return 0;
    case 118:
      v27 = (_DWORD *)(v1 + 12);
      v28 = *(_BYTE *)(v3 + 2);
      if ( v28 == 110 )
      {
        v6 = v3 + 3;
        *(_DWORD *)(v1 + 12) = v3 + 3;
        v28 = *(_BYTE *)(v3 + 3);
      }
      if ( (unsigned __int8)(v28 - 48) <= 9u )
      {
        do
        {
          *v27 = ++v6;
          v28 = *(_BYTE *)v6;
        }
        while ( (unsigned __int8)(*(_BYTE *)v6 - 48) <= 9u );
      }
      if ( v28 != 95 )
        return 0;
      v29 = (char *)(v6 + 1);
      *(_DWORD *)(v1 + 12) = v6 + 1;
      v30 = *(_BYTE *)(v6 + 1);
      if ( v30 == 110 )
      {
        v29 = (char *)(v6 + 2);
        *(_DWORD *)(v1 + 12) = v6 + 2;
        v30 = *(_BYTE *)(v6 + 2);
      }
      if ( (unsigned __int8)(v30 - 48) <= 9u )
      {
        do
        {
          *v27 = ++v29;
          v30 = *v29;
        }
        while ( (unsigned __int8)(*v29 - 48) <= 9u );
      }
      if ( v30 != 95 )
        return 0;
      *(_DWORD *)(v1 + 12) = v29 + 1;
      v14 = d_encoding_constprop_18(v1);
      v19 = 16;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 104:
      v31 = *(_BYTE *)(v3 + 2);
      if ( v31 == 110 )
      {
        v6 = v3 + 3;
        *(_DWORD *)(v1 + 12) = v3 + 3;
        v31 = *(_BYTE *)(v3 + 3);
      }
      for ( i = (char *)(v6 + 1); (unsigned __int8)(v31 - 48) <= 9u; ++i )
      {
        v6 = (int)i;
        *(_DWORD *)(v1 + 12) = i;
        v31 = *i;
      }
      if ( v31 != 95 )
        return 0;
      *(_DWORD *)(v1 + 12) = v6 + 1;
      v14 = d_encoding_constprop_18(v1);
      v19 = 15;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 99:
      v33 = *(_BYTE *)(v3 + 2);
      if ( !(_BYTE)v33 )
        return 0;
      v34 = v3 + 3;
      *(_DWORD *)(v1 + 12) = v3 + 3;
      if ( v33 == 104 )
      {
        v35 = (char **)(v1 + 12);
        v41 = *(_BYTE *)(v3 + 3);
        if ( v41 == 110 )
        {
          v34 = v3 + 4;
          *(_DWORD *)(v1 + 12) = v3 + 4;
          v41 = *(_BYTE *)(v3 + 4);
        }
        while ( (unsigned __int8)(v41 - 48) <= 9u )
        {
          *v35 = (char *)++v34;
          v41 = *(_BYTE *)v34;
        }
      }
      else
      {
        if ( v33 != 118 )
          return 0;
        v35 = (char **)(v1 + 12);
        v36 = *(_BYTE *)(v3 + 3);
        if ( *(_BYTE *)(v3 + 3) == 110 )
        {
          v34 = v3 + 4;
          *(_DWORD *)(v1 + 12) = v3 + 4;
          v36 = *(_BYTE *)(v3 + 4);
        }
        v37 = (char *)(v34 + 1);
        if ( (unsigned __int8)(v36 - 48) > 9u )
        {
          v40 = v34;
        }
        else
        {
          do
          {
            v38 = v37;
            *v35 = v37;
            v39 = *v37++;
          }
          while ( (unsigned __int8)(v39 - 48) <= 9u );
          v40 = (int)v38;
          v36 = v39;
        }
        if ( v36 != 95 )
          return 0;
        v34 = v40 + 1;
        *(_DWORD *)(v1 + 12) = v40 + 1;
        v41 = *(_BYTE *)(v40 + 1);
        if ( v41 == 110 )
        {
          v34 = v40 + 2;
          *(_DWORD *)(v1 + 12) = v40 + 2;
          v41 = *(_BYTE *)(v40 + 2);
        }
        while ( (unsigned __int8)(v41 - 48) <= 9u )
        {
          *v35 = (char *)++v34;
          v41 = *(_BYTE *)v34;
        }
      }
      if ( v41 != 95 )
        return 0;
      *(_DWORD *)(v1 + 12) = v34 + 1;
      v42 = *(_BYTE *)(v34 + 1);
      if ( !(_BYTE)v42 )
        return 0;
      v43 = v34 + 2;
      *(_DWORD *)(v1 + 12) = v34 + 2;
      if ( v42 == 104 )
      {
        v46 = *(_BYTE *)(v34 + 2);
        if ( v46 == 110 )
        {
          v43 = v34 + 3;
          *(_DWORD *)(v1 + 12) = v34 + 3;
          v46 = *(_BYTE *)(v34 + 3);
        }
        while ( (unsigned __int8)(v46 - 48) <= 9u )
        {
          *v35 = (char *)++v43;
          v46 = *(_BYTE *)v43;
        }
      }
      else
      {
        if ( v42 != 118 )
          return 0;
        v44 = *(_BYTE *)(v34 + 2);
        if ( v44 == 110 )
        {
          v43 = v34 + 3;
          *(_DWORD *)(v1 + 12) = v34 + 3;
          v44 = *(_BYTE *)(v34 + 3);
        }
        if ( (unsigned __int8)(v44 - 48) <= 9u )
        {
          do
          {
            *v35 = (char *)++v43;
            v44 = *(_BYTE *)v43;
          }
          while ( (unsigned __int8)(*(_BYTE *)v43 - 48) <= 9u );
        }
        if ( v44 != 95 )
          return 0;
        v45 = v43 + 1;
        *(_DWORD *)(v1 + 12) = v43 + 1;
        v46 = *(_BYTE *)(v43 + 1);
        if ( v46 == 110 )
        {
          v45 = v43 + 2;
          *(_DWORD *)(v1 + 12) = v43 + 2;
          v46 = *(_BYTE *)(v43 + 2);
        }
        v43 = v45;
        if ( (unsigned __int8)(v46 - 48) <= 9u )
        {
          do
          {
            *v35 = (char *)++v43;
            v46 = *(_BYTE *)v43;
          }
          while ( (unsigned __int8)(*(_BYTE *)v43 - 48) <= 9u );
        }
      }
      if ( v46 != 95 )
        return 0;
      *(_DWORD *)(v1 + 12) = v43 + 1;
      v14 = d_encoding_constprop_18(v1);
      v19 = 17;
      break;
    case 86:
      *(_DWORD *)(v1 + 48) = v2 + 15;
      v14 = d_type(v1);
      v19 = 9;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 84:
      *(_DWORD *)(v1 + 48) = v2 + 10;
      v14 = d_type(v1);
      v19 = 10;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 83:
      v14 = d_type(v1);
      v19 = 13;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 74:
      v14 = d_type(v1);
      v19 = 18;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 73:
      v14 = d_type(v1);
      v19 = 12;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 70:
      v14 = d_type(v1);
      v19 = 14;
      return d_make_comp_constprop_21(v1, v19, v14);
    case 67:
      v61 = d_type(v1);
      v47 = *(_BYTE **)(v1 + 12);
      v48 = *v47;
      if ( (_BYTE)v48 == 110 )
      {
        *(_DWORD *)(v1 + 12) = v47 + 1;
        v48 = (v47++)[1];
        v58 = 1;
      }
      else
      {
        v58 = 0;
      }
      if ( (unsigned __int8)(v48 - 48) > 9u )
      {
        v50 = 0;
      }
      else
      {
        v49 = v47 + 1;
        v50 = 0;
        do
        {
          v50 = v48 + 10 * v50 - 48;
          v47 = v49;
          *(_DWORD *)(v1 + 12) = v49;
          v48 = *v49++;
        }
        while ( (unsigned __int8)(v48 - 48) <= 9u );
      }
      if ( v58 && v50 > 0 || (_BYTE)v48 != 95 )
        return 0;
      *(_DWORD *)(v1 + 12) = v47 + 1;
      v51 = d_type(v1);
      *(_DWORD *)(v1 + 48) += 5;
      return d_make_comp(v1, 11, v51, v61);
  }
  return d_make_comp_constprop_21(v1, v19, v14);
}

//----- (0040AE04) --------------------------------------------------------
int __usercall d_expr_primary@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int result; // eax@2
  int v4; // edx@3
  char v5; // cl@3
  char v6; // al@5
  char v7; // cl@8
  int v8; // eax@11
  _BYTE *v9; // edi@13
  char v10; // bl@13
  int v11; // edx@14
  char *v12; // ecx@17
  char v13; // bl@19
  int v14; // ecx@21
  int v15; // ebx@22
  int v16; // edx@32
  int v17; // [sp+1Ch] [bp-20h]@20

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 12);
  if ( *(_BYTE *)v2 != 76 )
    return 0;
  v4 = v2 + 1;
  *(_DWORD *)(v1 + 12) = v2 + 1;
  v5 = *(_BYTE *)(v2 + 1);
  if ( v5 != 95 )
  {
    if ( v5 != 90 )
    {
      v8 = d_type(v1);
      if ( !v8 )
        return 0;
      if ( *(_DWORD *)v8 == 35 )
      {
        v16 = *(_DWORD *)(v8 + 4);
        if ( *(_DWORD *)(v16 + 16) )
          *(_DWORD *)(v1 + 48) -= *(_DWORD *)(v16 + 4);
      }
      v9 = *(_BYTE **)(v1 + 12);
      v10 = *v9;
      if ( *v9 == 110 )
      {
        *(_DWORD *)(v1 + 12) = v9 + 1;
        v10 = (v9++)[1];
        v11 = 56;
      }
      else
      {
        v11 = 55;
      }
      if ( v10 == 69 )
      {
        v17 = 0;
      }
      else
      {
        if ( !v10 )
          return 0;
        v12 = v9 + 1;
        while ( 1 )
        {
          *(_DWORD *)(v1 + 12) = v12;
          v13 = *v12;
          if ( *v12 == 69 )
            break;
          ++v12;
          if ( !v13 )
            return 0;
        }
        v17 = v12 - v9;
      }
      v14 = *(_DWORD *)(v1 + 20);
      if ( v14 < *(_DWORD *)(v1 + 24)
        && (v15 = *(_DWORD *)(v1 + 16) + 12 * v14, *(_DWORD *)(v1 + 20) = v14 + 1, v15)
        && v9
        && v17 )
      {
        *(_DWORD *)v15 = 0;
        *(_DWORD *)(v15 + 4) = v9;
        *(_DWORD *)(v15 + 8) = v17;
      }
      else
      {
        v15 = 0;
      }
      result = d_make_comp(v1, v11, v8, v15);
      goto LABEL_8;
    }
LABEL_5:
    *(_DWORD *)(v1 + 12) = v4 + 1;
    v6 = *(_BYTE *)(v4 + 1);
    if ( v6 == 71 || v6 == 84 )
      result = d_special_name(v1);
    else
      result = d_encoding_part_6(v1, 0);
LABEL_8:
    v4 = *(_DWORD *)(v1 + 12);
    v7 = *(_BYTE *)v4;
    goto LABEL_9;
  }
  v4 = v2 + 2;
  *(_DWORD *)(v1 + 12) = v2 + 2;
  v7 = *(_BYTE *)(v2 + 2);
  if ( v7 == 90 )
    goto LABEL_5;
  result = 0;
LABEL_9:
  if ( v7 != 69 )
    return 0;
  *(_DWORD *)(v1 + 12) = v4 + 1;
  return result;
}

//----- (0040AF84) --------------------------------------------------------
int __usercall d_template_args@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // ecx@1
  char *v4; // edx@2
  char v5; // al@2
  int *v6; // esi@3
  int v7; // eax@4
  int v8; // eax@6
  _BYTE *v9; // edx@12
  int v11; // [sp+Ch] [bp-10h]@3

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 12);
  if ( (unsigned __int8)(*(_BYTE *)v3 - 73) > 1u )
    return 0;
  v4 = (char *)(v3 + 1);
  *(_DWORD *)(a1 + 12) = v3 + 1;
  v5 = *(_BYTE *)(v3 + 1);
  if ( v5 != 69 )
  {
    v11 = 0;
    v6 = &v11;
    while ( 1 )
    {
      if ( v5 < 73 )
        goto LABEL_4;
      if ( v5 <= 74 )
      {
        v7 = d_template_args();
      }
      else
      {
        if ( v5 != 76 )
        {
          if ( v5 == 88 )
          {
            *(_DWORD *)(v1 + 12) = v4 + 1;
            v7 = d_expression(v1);
            v9 = *(_BYTE **)(v1 + 12);
            if ( *v9 != 69 )
              return 0;
            *(_DWORD *)(v1 + 12) = v9 + 1;
            goto LABEL_5;
          }
LABEL_4:
          v7 = d_type(v1);
          goto LABEL_5;
        }
        v7 = d_expr_primary(v1);
      }
LABEL_5:
      if ( !v7 )
        return 0;
      v8 = d_make_comp_constprop_21(v1, 43, v7);
      *v6 = v8;
      if ( !v8 )
        return 0;
      v6 = (int *)(v8 + 8);
      v4 = *(char **)(v1 + 12);
      v5 = *v4;
      if ( *v4 == 69 )
      {
        *(_DWORD *)(v1 + 12) = v4 + 1;
        *(_DWORD *)(v1 + 44) = v2;
        return v11;
      }
    }
  }
  *(_DWORD *)(v1 + 12) = v3 + 2;
  return d_make_comp_constprop_21(v1, 43, 0);
}

//----- (0040B060) --------------------------------------------------------
int __usercall d_name@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // eax@1
  int v3; // esi@2
  char v5; // al@5
  int v6; // edi@7
  char v7; // al@7
  int v8; // eax@10
  int v9; // edx@15
  int v10; // eax@16
  int v11; // eax@19
  int v12; // edx@20
  int *v13; // edi@20
  char v14; // al@20
  int v15; // edx@23
  int v16; // eax@24
  int v17; // eax@31
  int v18; // edx@31
  int v19; // ecx@32
  int v20; // eax@35
  char v21; // al@39
  int v22; // esi@41
  _DWORD *v23; // eax@42
  int v24; // ecx@45
  int v25; // ecx@47
  int v26; // edx@48
  int v27; // eax@50
  char v28; // si@52
  int v29; // ebp@52
  int v30; // eax@52
  char v31; // bl@52
  int v32; // esi@52
  int v33; // eax@68
  int v34; // edx@70
  int v35; // eax@75
  char v36; // al@79
  int v37; // eax@90
  int v38; // edx@90
  _BYTE *v39; // edi@93
  int v40; // ecx@93
  int v41; // esi@94
  int v42; // edx@99
  int v43; // eax@100
  int v44; // eax@103
  int v45; // ebp@111
  int v46; // edx@111
  _BYTE *v47; // ebp@114
  int v48; // ecx@114
  int v49; // eax@119
  int v50; // edx@119
  signed int v51; // ebp@120
  _BYTE *v52; // eax@122
  int v53; // ecx@122
  _BYTE *v54; // eax@132
  int v55; // [sp+14h] [bp-38h]@7
  signed int v56; // [sp+18h] [bp-34h]@112
  int v57; // [sp+2Ch] [bp-20h]@20

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 12);
  if ( (unsigned __int8)(*(_BYTE *)v2 - 76) <= 0xEu )
  {
    switch ( *(_BYTE *)v2 )
    {
      default:
        goto LABEL_2;
      case 0x5A:
        *(_DWORD *)(v1 + 12) = v2 + 1;
        v5 = *(_BYTE *)(v2 + 1);
        if ( v5 != 71 && v5 != 84 )
        {
          v55 = d_name(v1);
          v6 = *(_DWORD *)(v1 + 12);
          v7 = *(_BYTE *)v6;
          if ( !v55 )
            goto LABEL_38;
          if ( !v7 )
            return 0;
          if ( v7 == 69 )
            goto LABEL_39;
          v8 = v55;
          while ( *(_DWORD *)v8 != 4 )
          {
            if ( *(_DWORD *)v8 >= 4u && (unsigned int)(*(_DWORD *)v8 - 26) <= 2 )
            {
              v8 = *(_DWORD *)(v8 + 4);
              if ( v8 )
                continue;
            }
LABEL_15:
            v9 = 0;
LABEL_16:
            v10 = d_bare_function_type(v1, v9);
            v55 = d_make_comp(v1, 3, v55, v10);
            v6 = *(_DWORD *)(v1 + 12);
            v7 = *(_BYTE *)v6;
            goto LABEL_38;
          }
          v44 = *(_DWORD *)(v8 + 4);
          if ( v44 )
          {
            while ( *(_DWORD *)v44 <= 0x2Fu )
            {
              switch ( *(_DWORD *)v44 )
              {
                case 7:
                case 8:
                case 0x2F:
                  goto LABEL_15;
                default:
                  goto LABEL_105;
                case 1:
                case 2:
                  v44 = *(_DWORD *)(v44 + 8);
                  if ( !v44 )
                    goto LABEL_105;
                  break;
              }
            }
          }
LABEL_105:
          v9 = 1;
          goto LABEL_16;
        }
        v55 = d_special_name(v1);
        v6 = *(_DWORD *)(v1 + 12);
        v7 = *(_BYTE *)v6;
LABEL_38:
        if ( v7 != 69 )
          return 0;
LABEL_39:
        *(_DWORD *)(v1 + 12) = v6 + 1;
        v21 = *(_BYTE *)(v6 + 1);
        if ( v21 == 115 )
        {
          *(_DWORD *)(v1 + 12) = v6 + 2;
          if ( *(_BYTE *)(v6 + 2) == 95 )
          {
            v49 = v6 + 3;
            *(_DWORD *)(v1 + 12) = v6 + 3;
            v50 = *(_BYTE *)(v6 + 3);
            if ( (_BYTE)v50 == 110 )
            {
              v49 = v6 + 4;
              *(_DWORD *)(v1 + 12) = v6 + 4;
              v50 = *(_BYTE *)(v6 + 4);
              v51 = 1;
            }
            else
            {
              v51 = 0;
            }
            if ( (unsigned __int8)(v50 - 48) > 9u )
            {
              v53 = 0;
            }
            else
            {
              v52 = (_BYTE *)(v49 + 1);
              v53 = 0;
              do
              {
                v53 = v50 + 10 * v53 - 48;
                *(_DWORD *)(v1 + 12) = v52;
                v50 = *v52++;
              }
              while ( (unsigned __int8)(v50 - 48) <= 9u );
            }
            if ( v51 && -v53 < 0 )
              return 0;
          }
          v42 = *(_DWORD *)(v1 + 20);
          if ( v42 < *(_DWORD *)(v1 + 24)
            && (v43 = *(_DWORD *)(v1 + 16) + 12 * v42, *(_DWORD *)(v1 + 20) = v42 + 1, v43) )
          {
            *(_DWORD *)v43 = 0;
            *(_DWORD *)(v43 + 4) = "string literal";
            *(_DWORD *)(v43 + 8) = 14;
          }
          else
          {
            v43 = 0;
          }
          v27 = d_make_comp(v1, 2, v55, v43);
        }
        else
        {
          if ( v21 == 100 )
          {
            v37 = v6 + 2;
            *(_DWORD *)(v1 + 12) = v6 + 2;
            v38 = *(_BYTE *)(v6 + 2);
            if ( (_BYTE)v38 == 95 )
            {
              v22 = 0;
            }
            else
            {
              if ( (_BYTE)v38 == 110 )
                return 0;
              if ( (unsigned __int8)(v38 - 48) > 9u )
                return 0;
              v39 = (_BYTE *)(v6 + 3);
              v40 = 0;
              do
              {
                v41 = v38 + 10 * v40;
                v40 = v41 - 48;
                v37 = (int)v39;
                *(_DWORD *)(v1 + 12) = v39;
                v38 = *v39++;
              }
              while ( (unsigned __int8)(v38 - 48) <= 9u );
              v22 = v41 - 47;
              if ( (_BYTE)v38 != 95 )
                return 0;
            }
            *(_DWORD *)(v1 + 12) = v37 + 1;
          }
          else
          {
            v22 = -1;
          }
          v23 = (_DWORD *)d_name(v1);
          if ( v23 )
          {
            if ( *v23 != 64 && *v23 != 66 )
            {
              v24 = *(_DWORD *)(v1 + 12);
              if ( *(_BYTE *)v24 == 95 )
              {
                v45 = v24 + 1;
                *(_DWORD *)(v1 + 12) = v24 + 1;
                v46 = *(_BYTE *)(v24 + 1);
                if ( (_BYTE)v46 == 110 )
                {
                  v45 = v24 + 2;
                  *(_DWORD *)(v1 + 12) = v24 + 2;
                  v46 = *(_BYTE *)(v24 + 2);
                  v56 = 1;
                }
                else
                {
                  v56 = 0;
                }
                if ( (unsigned __int8)(v46 - 48) > 9u )
                {
                  v48 = 0;
                }
                else
                {
                  v47 = (_BYTE *)(v45 + 1);
                  v48 = 0;
                  do
                  {
                    v48 = v46 + 10 * v48 - 48;
                    *(_DWORD *)(v1 + 12) = v47;
                    v46 = *v47++;
                  }
                  while ( (unsigned __int8)(v46 - 48) <= 9u );
                }
                if ( v56 && -v48 < 0 )
                  return 0;
              }
            }
          }
          if ( v22 == -1 )
          {
            v26 = (int)v23;
          }
          else
          {
            v25 = *(_DWORD *)(v1 + 20);
            if ( v25 < *(_DWORD *)(v1 + 24)
              && (v26 = *(_DWORD *)(v1 + 16) + 12 * v25, *(_DWORD *)(v1 + 20) = v25 + 1, v26) )
            {
              *(_DWORD *)v26 = 65;
              *(_DWORD *)(v26 + 8) = v22;
              *(_DWORD *)(v26 + 4) = v23;
            }
            else
            {
              v26 = 0;
            }
          }
          v27 = d_make_comp(v1, 2, v55, v26);
        }
        return v27;
      case 0x53:
        if ( *(_BYTE *)(v2 + 1) != 116 )
        {
          v3 = d_substitution(v1, 0);
          if ( **(_BYTE **)(v1 + 12) != 73 )
            return v3;
          goto LABEL_19;
        }
        *(_DWORD *)(v1 + 12) = v2 + 2;
        v17 = d_unqualified_name(v1);
        v18 = *(_DWORD *)(v1 + 20);
        if ( v18 < *(_DWORD *)(v1 + 24) && (v19 = *(_DWORD *)(v1 + 16) + 12 * v18, *(_DWORD *)(v1 + 20) = v18 + 1, v19) )
        {
          *(_DWORD *)v19 = 0;
          *(_DWORD *)(v19 + 4) = "std";
          *(_DWORD *)(v19 + 8) = 3;
        }
        else
        {
          v19 = 0;
        }
        v3 = d_make_comp(v1, 1, v19, v17);
        *(_DWORD *)(v1 + 48) += 3;
        if ( **(_BYTE **)(v1 + 12) != 73 )
          return v3;
        goto LABEL_34;
      case 0x4E:
        v12 = v2 + 1;
        *(_DWORD *)(v1 + 12) = v2 + 1;
        v13 = &v57;
        v14 = *(_BYTE *)(v2 + 1);
        while ( 2 )
        {
          if ( v14 == 114 )
          {
            *(_DWORD *)(v1 + 12) = v12 + 1;
            *(_DWORD *)(v1 + 48) += 9;
            v16 = d_make_comp_constprop_21(v1, 26, 0);
            *v13 = v16;
            if ( !v16 )
              return 0;
LABEL_25:
            v13 = (int *)(v16 + 4);
            v12 = *(_DWORD *)(v1 + 12);
            v14 = *(_BYTE *)v12;
            continue;
          }
          break;
        }
        if ( v14 == 86 )
        {
          *(_DWORD *)(v1 + 12) = v12 + 1;
          *(_DWORD *)(v1 + 48) += 9;
          v15 = 27;
LABEL_24:
          v16 = d_make_comp_constprop_21(v1, v15, 0);
          *v13 = v16;
          if ( !v16 )
            return 0;
          goto LABEL_25;
        }
        if ( v14 == 75 )
        {
          *(_DWORD *)(v1 + 12) = v12 + 1;
          *(_DWORD *)(v1 + 48) += 6;
          v15 = 28;
          goto LABEL_24;
        }
        v28 = v14;
        v29 = 0;
        v30 = v1;
        v31 = v28;
        v32 = v30;
        break;
      case 0x4C:
      case 0x55:
        return d_unqualified_name(v1);
    }
LABEL_53:
    if ( !v31 )
      goto LABEL_67;
    while ( 1 )
    {
      if ( v31 == 68 )
      {
        v36 = *(_BYTE *)(v12 + 1);
        if ( v36 != 84 && v36 != 116 )
          goto LABEL_68;
        v33 = d_type(v32);
LABEL_69:
        if ( v29 )
        {
          v34 = 1;
LABEL_71:
          v29 = d_make_comp(v32, v34, v29, v33);
          goto LABEL_72;
        }
        v29 = v33;
LABEL_72:
        if ( v31 == 83 )
          goto LABEL_77;
        v12 = *(_DWORD *)(v32 + 12);
        if ( *(_BYTE *)v12 != 69 )
        {
          if ( !v29 || (v35 = *(_DWORD *)(v32 + 32), v35 >= *(_DWORD *)(v32 + 36)) )
          {
LABEL_67:
            *v13 = 0;
            return 0;
          }
          *(_DWORD *)(*(_DWORD *)(v32 + 28) + 4 * v35) = v29;
          *(_DWORD *)(v32 + 32) = v35 + 1;
LABEL_77:
          v12 = *(_DWORD *)(v32 + 12);
          v31 = *(_BYTE *)v12;
          goto LABEL_53;
        }
        v31 = 69;
      }
      if ( (unsigned __int8)(v31 - 48) <= 9u
        || (unsigned __int8)(v31 - 97) <= 0x19u
        || v31 == 67
        || v31 == 85
        || v31 == 76 )
      {
LABEL_68:
        v33 = d_unqualified_name(v32);
        goto LABEL_69;
      }
      if ( v31 == 83 )
      {
        v33 = d_substitution(v32, 1);
        goto LABEL_69;
      }
      if ( v31 == 73 )
      {
        if ( !v29 )
          goto LABEL_67;
        v33 = d_template_args(v32);
        v34 = 4;
        goto LABEL_71;
      }
      if ( v31 == 84 )
      {
        v33 = d_template_param(v32);
        goto LABEL_69;
      }
      if ( v31 == 69 )
      {
        *v13 = v29;
        if ( v29 )
        {
          v54 = *(_BYTE **)(v32 + 12);
          if ( *v54 == 69 )
          {
            *(_DWORD *)(v32 + 12) = v54 + 1;
            return v57;
          }
        }
        return 0;
      }
      if ( v31 == 77 )
      {
        if ( v29 )
        {
          *(_DWORD *)(v32 + 12) = v12 + 1;
          v31 = *(_BYTE *)(v12++ + 1);
          if ( v31 )
            continue;
        }
      }
      goto LABEL_67;
    }
  }
LABEL_2:
  v3 = d_unqualified_name(v1);
  if ( **(_BYTE **)(v1 + 12) != 73 )
    return v3;
LABEL_34:
  if ( v3 )
  {
    v20 = *(_DWORD *)(v1 + 32);
    if ( v20 < *(_DWORD *)(v1 + 36) )
    {
      *(_DWORD *)(*(_DWORD *)(v1 + 28) + 4 * v20) = v3;
      *(_DWORD *)(v1 + 32) = v20 + 1;
LABEL_19:
      v11 = d_template_args(v1);
      return d_make_comp(v1, 4, v3, v11);
    }
  }
  return 0;
}

//----- (0040B65C) --------------------------------------------------------
int __usercall d_type@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edx@1
  int v3; // eax@1
  int *v4; // esi@5
  int v5; // edx@8
  int result; // eax@13
  int v7; // eax@17
  int v8; // eax@19
  int *v9; // eax@22
  _DWORD *v10; // eax@27
  int v11; // edx@27
  int v12; // eax@30
  int v13; // edx@32
  int v14; // edi@35
  char v15; // al@35
  int v16; // edx@37
  _BYTE *v17; // esi@38
  int v18; // eax@39
  int v19; // ebp@40
  int v20; // eax@45
  int v21; // ecx@46
  char v22; // al@46
  int v23; // edi@50
  char *v24; // edx@51
  char v25; // al@51
  int *v26; // esi@54
  int v27; // eax@55
  char v28; // al@56
  int v29; // eax@59
  int v30; // eax@64
  char v31; // al@65
  int v32; // esi@66
  int v33; // ebp@67
  char *v34; // edx@67
  char v35; // al@67
  int *v36; // esi@67
  int v37; // edx@70
  int v38; // eax@71
  int v39; // eax@75
  int v40; // eax@76
  int v41; // eax@77
  char v42; // al@78
  int v43; // eax@82
  int v44; // edx@86
  int v45; // esi@88
  int v46; // eax@88
  int v47; // ecx@89
  int v48; // esi@89
  int v49; // eax@93
  int v50; // ecx@94
  int v51; // eax@95
  signed int v52; // edi@96
  _BYTE *v53; // esi@98
  int v54; // edx@98
  _BYTE *v55; // eax@104
  int v56; // ST18_4@105
  int v57; // eax@105
  int v58; // edx@106
  char **v59; // edx@108
  int v60; // eax@110
  int v61; // edx@111
  int v62; // edx@114
  int v63; // edx@117
  int v64; // edx@120
  int v65; // edx@123
  int v66; // edx@126
  int v67; // edx@129
  int v68; // eax@132
  char *v69; // ecx@133
  char v70; // dl@133
  int v71; // eax@136
  int v72; // esi@137
  __int16 v73; // ax@138
  int v74; // edi@139
  _BYTE *v75; // esi@140
  char v76; // cl@140
  _BYTE *i; // edx@142
  __int16 v78; // dx@145
  int v79; // eax@150
  int v80; // eax@155
  _DWORD *v81; // eax@156
  int v82; // eax@160
  int v83; // edx@168
  int v84; // edx@169
  char *v85; // eax@172
  char v86; // dl@172
  int v87; // eax@175
  _BYTE *v88; // edx@176
  int v89; // [sp+2Ch] [bp-20h]@5

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_BYTE *)v2;
  if ( (_BYTE)v3 == 114 || (_BYTE)v3 == 86 || (_BYTE)v3 == 75 )
  {
    v4 = &v89;
    while ( 1 )
    {
      if ( (_BYTE)v3 == 114 )
      {
        *(_DWORD *)(v1 + 12) = v2 + 1;
        *(_DWORD *)(v1 + 48) += 9;
        v3 = d_make_comp_constprop_21(v1, 23, 0);
        *v4 = v3;
        if ( !v3 )
          return 0;
      }
      else
      {
        if ( (_BYTE)v3 == 86 )
        {
          *(_DWORD *)(v1 + 12) = v2 + 1;
          *(_DWORD *)(v1 + 48) += 9;
          v5 = 24;
        }
        else
        {
          if ( (_BYTE)v3 != 75 )
          {
            if ( (_BYTE)v3 == 70 && v4 != &v89 )
            {
              v9 = &v89;
              do
              {
                v10 = (_DWORD *)*v9;
                v11 = *v10;
                if ( *v10 == 24 )
                {
                  *v10 = 27;
                }
                else if ( v11 == 25 )
                {
                  *v10 = 28;
                }
                else if ( v11 == 23 )
                {
                  *v10 = 26;
                }
                v9 = v10 + 1;
              }
              while ( v4 != v9 );
            }
            v7 = d_type(v1);
            *v4 = v7;
            if ( v7 )
            {
              if ( v89 )
              {
                v8 = *(_DWORD *)(v1 + 32);
                if ( v8 < *(_DWORD *)(v1 + 36) )
                {
                  *(_DWORD *)(*(_DWORD *)(v1 + 28) + 4 * v8) = v89;
                  *(_DWORD *)(v1 + 32) = v8 + 1;
                  return v89;
                }
              }
            }
            return 0;
          }
          *(_DWORD *)(v1 + 12) = v2 + 1;
          *(_DWORD *)(v1 + 48) += 6;
          v5 = 25;
        }
        v3 = d_make_comp_constprop_21(v1, v5, 0);
        *v4 = v3;
        if ( !v3 )
          return 0;
      }
      v4 = (int *)(v3 + 4);
      v2 = *(_DWORD *)(v1 + 12);
      LOBYTE(v3) = *(_BYTE *)v2;
    }
  }
  switch ( (_BYTE)v3 )
  {
    default:
      return 0;
    case 0x75:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v12 = d_source_name(v1);
      result = d_make_comp_constprop_21(v1, 36, v12);
      v89 = result;
      goto LABEL_31;
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x4E:
    case 0x5A:
      result = d_name(v1);
      v89 = result;
      goto LABEL_31;
    case 0x41:
      v14 = v2 + 1;
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v15 = *(_BYTE *)(v2 + 1);
      if ( v15 == 95 )
      {
        v19 = 0;
      }
      else
      {
        if ( (unsigned __int8)(v15 - 48) > 9u )
        {
          v19 = d_expression(v1);
          if ( !v19 )
            goto LABEL_44;
          v17 = *(_BYTE **)(v1 + 12);
        }
        else
        {
          v16 = v2 + 2;
          do
          {
            v17 = (_BYTE *)v16;
            *(_DWORD *)(v1 + 12) = v16++;
          }
          while ( (unsigned __int8)(*v17 - 48) <= 9u );
          v18 = *(_DWORD *)(v1 + 20);
          if ( v18 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_44;
          v19 = *(_DWORD *)(v1 + 16) + 12 * v18;
          *(_DWORD *)(v1 + 20) = v18 + 1;
          if ( !v19 || v17 == (_BYTE *)v14 )
            goto LABEL_44;
          *(_DWORD *)v19 = 0;
          *(_DWORD *)(v19 + 4) = v14;
          *(_DWORD *)(v19 + 8) = &v17[-v14];
        }
        if ( *v17 != 95 )
          goto LABEL_44;
        v14 = (int)v17;
      }
      *(_DWORD *)(v1 + 12) = v14 + 1;
      v80 = d_type(v1);
      result = d_make_comp(v1, 38, v19, v80);
      goto LABEL_83;
    case 0x43:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v20 = d_type(v1);
      result = d_make_comp_constprop_21(v1, 33, v20);
      v89 = result;
      goto LABEL_31;
    case 0x46:
      v21 = v2 + 1;
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v22 = *(_BYTE *)(v2 + 1);
      if ( v22 == 89 )
      {
        v21 = v2 + 2;
        *(_DWORD *)(v1 + 12) = v2 + 2;
        v22 = *(_BYTE *)(v2 + 2);
      }
      if ( v22 == 74 )
        *(_DWORD *)(v1 + 12) = v21 + 1;
      v23 = d_type(v1);
      if ( !v23 )
        goto LABEL_60;
      v89 = 0;
      v24 = *(char **)(v1 + 12);
      v25 = *v24;
      if ( !*v24 || v25 == 69 || v25 == 46 )
        goto LABEL_61;
      v26 = &v89;
      break;
    case 0x47:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v30 = d_type(v1);
      result = d_make_comp_constprop_21(v1, 34, v30);
      v89 = result;
      goto LABEL_31;
    case 0x44:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v31 = *(_BYTE *)(v2 + 1);
      if ( !v31 )
        return 0;
      v32 = v2 + 2;
      *(_DWORD *)(v1 + 12) = v2 + 2;
      switch ( v31 )
      {
        default:
          return 0;
        case 118:
          if ( *(_BYTE *)(v2 + 2) == 95 )
          {
            *(_DWORD *)(v1 + 12) = v2 + 3;
            v50 = d_expression(v1);
          }
          else
          {
            v49 = *(_DWORD *)(v1 + 20);
            if ( v49 >= *(_DWORD *)(v1 + 24) )
              goto LABEL_44;
            v50 = *(_DWORD *)(v1 + 16) + 12 * v49;
            *(_DWORD *)(v1 + 20) = v49 + 1;
            if ( !v50 )
              goto LABEL_44;
            *(_DWORD *)v50 = 60;
            v51 = *(_BYTE *)(v2 + 2);
            if ( (_BYTE)v51 == 110 )
            {
              v32 = v2 + 3;
              *(_DWORD *)(v1 + 12) = v2 + 3;
              v51 = *(_BYTE *)(v2 + 3);
              v52 = 1;
            }
            else
            {
              v52 = 0;
            }
            if ( (unsigned __int8)(v51 - 48) > 9u )
            {
              v54 = 0;
            }
            else
            {
              v53 = (_BYTE *)(v32 + 1);
              v54 = 0;
              do
              {
                v54 = v51 + 10 * v54 - 48;
                *(_DWORD *)(v1 + 12) = v53;
                v51 = *v53++;
              }
              while ( (unsigned __int8)(v51 - 48) <= 9u );
            }
            if ( v52 )
              v54 = -v54;
            *(_DWORD *)(v50 + 4) = v54;
          }
          if ( v50 )
          {
            v55 = *(_BYTE **)(v1 + 12);
            if ( *v55 == 95 )
            {
              *(_DWORD *)(v1 + 12) = v55 + 1;
              v56 = v50;
              v57 = d_type(v1);
              result = d_make_comp(v1, 41, v56, v57);
              goto LABEL_83;
            }
          }
          break;
        case 115:
          v58 = *(_DWORD *)(v1 + 20);
          if ( v58 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_153;
          result = *(_DWORD *)(v1 + 16) + 12 * v58;
          *(_DWORD *)(v1 + 20) = v58 + 1;
          if ( !result )
            goto LABEL_182;
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = &off_41D298;
          v59 = &off_41D298;
          goto LABEL_109;
        case 112:
          v60 = d_type(v1);
          result = d_make_comp_constprop_21(v1, 69, v60);
          goto LABEL_83;
        case 110:
          v61 = *(_DWORD *)(v1 + 20);
          if ( v61 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_153;
          result = *(_DWORD *)(v1 + 16) + 12 * v61;
          *(_DWORD *)(v1 + 20) = v61 + 1;
          if ( !result )
            goto LABEL_182;
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = &off_41D2C0;
          v59 = &off_41D2C0;
          goto LABEL_109;
        case 105:
          v62 = *(_DWORD *)(v1 + 20);
          if ( v62 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_153;
          result = *(_DWORD *)(v1 + 16) + 12 * v62;
          *(_DWORD *)(v1 + 20) = v62 + 1;
          if ( !result )
            goto LABEL_182;
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = &off_41D2AC;
          v59 = &off_41D2AC;
          goto LABEL_109;
        case 104:
          v63 = *(_DWORD *)(v1 + 20);
          if ( v63 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_153;
          result = *(_DWORD *)(v1 + 16) + 12 * v63;
          *(_DWORD *)(v1 + 20) = v63 + 1;
          if ( !result )
            goto LABEL_182;
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = &off_41D284;
          v59 = &off_41D284;
          goto LABEL_109;
        case 102:
          v64 = *(_DWORD *)(v1 + 20);
          if ( v64 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_153;
          result = *(_DWORD *)(v1 + 16) + 12 * v64;
          *(_DWORD *)(v1 + 20) = v64 + 1;
          if ( !result )
            goto LABEL_182;
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = &off_41D248;
          v59 = &off_41D248;
          goto LABEL_109;
        case 101:
          v65 = *(_DWORD *)(v1 + 20);
          if ( v65 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_153;
          result = *(_DWORD *)(v1 + 16) + 12 * v65;
          *(_DWORD *)(v1 + 20) = v65 + 1;
          if ( !result )
            goto LABEL_182;
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = &off_41D270;
          v59 = &off_41D270;
          goto LABEL_109;
        case 100:
          v66 = *(_DWORD *)(v1 + 20);
          if ( v66 >= *(_DWORD *)(v1 + 24) )
          {
LABEL_153:
            v59 = (char **)::v4;
            result = 0;
          }
          else
          {
            result = *(_DWORD *)(v1 + 16) + 12 * v66;
            *(_DWORD *)(v1 + 20) = v66 + 1;
            if ( result )
            {
              *(_DWORD *)result = 35;
              *(_DWORD *)(result + 4) = &off_41D25C;
              v59 = &off_41D25C;
            }
            else
            {
LABEL_182:
              v59 = (char **)::v4;
            }
          }
LABEL_109:
          *(_DWORD *)(v1 + 48) += v59[1];
          return result;
        case 97:
          v67 = *(_DWORD *)(v1 + 20);
          if ( v67 >= *(_DWORD *)(v1 + 24) )
            return 0;
          result = *(_DWORD *)(v1 + 16) + 12 * v67;
          *(_DWORD *)(v1 + 20) = v67 + 1;
          if ( !result )
            return 0;
          *(_DWORD *)result = 0;
          *(_DWORD *)(result + 4) = "auto";
          *(_DWORD *)(result + 8) = 4;
          return result;
        case 84:
        case 116:
          v68 = d_expression(v1);
          result = d_make_comp_constprop_21(v1, 61, v68);
          v89 = result;
          if ( result )
          {
            v69 = *(char **)(v1 + 12);
            v70 = *v69;
            if ( *v69 )
            {
              *(_DWORD *)(v1 + 12) = v69 + 1;
              if ( v70 == 69 )
                goto LABEL_32;
            }
          }
          return 0;
        case 70:
          v71 = *(_DWORD *)(v1 + 20);
          if ( v71 >= *(_DWORD *)(v1 + 24) )
          {
            v72 = 0;
          }
          else
          {
            v72 = *(_DWORD *)(v1 + 16) + 12 * v71;
            *(_DWORD *)(v1 + 20) = v71 + 1;
          }
          v89 = v72;
          *(_DWORD *)v72 = 40;
          v73 = (unsigned __int8)(*(_BYTE *)(v2 + 2) - 48) <= 9u;
          *(_WORD *)(v72 + 8) = v73;
          if ( v73 )
          {
            v85 = *(char **)(v1 + 12);
            v86 = *v85;
            if ( *v85 == 110 )
            {
              *(_DWORD *)(v1 + 12) = v85 + 1;
              v86 = (v85++)[1];
            }
            if ( (unsigned __int8)(v86 - 48) <= 9u )
            {
              v87 = (int)(v85 + 1);
              do
              {
                v88 = (_BYTE *)v87;
                *(_DWORD *)(v1 + 12) = v87++;
              }
              while ( (unsigned __int8)(*v88 - 48) <= 9u );
              v72 = v89;
            }
          }
          *(_DWORD *)(v72 + 4) = d_type(v1);
          v74 = v89;
          if ( !*(_DWORD *)(v89 + 4) )
            return 0;
          v75 = *(_BYTE **)(v1 + 12);
          v76 = *v75;
          if ( *v75 == 110 )
          {
            *(_DWORD *)(v1 + 12) = v75 + 1;
            v76 = (v75++)[1];
          }
          for ( i = v75 + 1; (unsigned __int8)(v76 - 48) <= 9u; ++i )
          {
            v75 = i;
            *(_DWORD *)(v1 + 12) = i;
            v76 = *i;
          }
          if ( v76 )
          {
            *(_DWORD *)(v1 + 12) = v75 + 1;
            v78 = v76 == 115;
          }
          else
          {
            v78 = 0;
          }
          result = v74;
          *(_WORD *)(v74 + 10) = v78;
          return result;
      }
      goto LABEL_44;
    case 0x4D:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v33 = d_type(v1);
      v34 = *(char **)(v1 + 12);
      v35 = *v34;
      v36 = &v89;
      while ( 2 )
      {
        if ( v35 == 114 )
        {
          *(_DWORD *)(v1 + 12) = v34 + 1;
          *(_DWORD *)(v1 + 48) += 9;
          v37 = 26;
        }
        else if ( v35 == 86 )
        {
          *(_DWORD *)(v1 + 12) = v34 + 1;
          *(_DWORD *)(v1 + 48) += 9;
          v37 = 27;
        }
        else
        {
          if ( v35 != 75 )
          {
            v81 = (_DWORD *)d_type(v1);
            *v36 = (int)v81;
            if ( !v81 )
              goto LABEL_44;
            if ( v36 != &v89 && *v81 != 37 )
            {
              if ( !v89 )
                goto LABEL_44;
              v82 = *(_DWORD *)(v1 + 32);
              if ( v82 >= *(_DWORD *)(v1 + 36) )
                goto LABEL_44;
              *(_DWORD *)(*(_DWORD *)(v1 + 28) + 4 * v82) = v89;
              *(_DWORD *)(v1 + 32) = v82 + 1;
            }
            result = d_make_comp(v1, 39, v33, v89);
            goto LABEL_83;
          }
          *(_DWORD *)(v1 + 12) = v34 + 1;
          *(_DWORD *)(v1 + 48) += 6;
          v37 = 28;
        }
        v38 = d_make_comp_constprop_21(v1, v37, 0);
        *v36 = v38;
        if ( v38 )
        {
          v36 = (int *)(v38 + 4);
          v34 = *(char **)(v1 + 12);
          v35 = *v34;
          continue;
        }
        goto LABEL_44;
      }
    case 0x50:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v39 = d_type(v1);
      result = d_make_comp_constprop_21(v1, 30, v39);
      v89 = result;
      goto LABEL_31;
    case 0x52:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v40 = d_type(v1);
      result = d_make_comp_constprop_21(v1, 31, v40);
      v89 = result;
      goto LABEL_31;
    case 0x4F:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v41 = d_type(v1);
      result = d_make_comp_constprop_21(v1, 32, v41);
      v89 = result;
      goto LABEL_31;
    case 0x53:
      v42 = *(_BYTE *)(v2 + 1);
      if ( (unsigned __int8)(v42 - 48) <= 9u || v42 == 95 || (unsigned __int8)(v42 - 65) <= 0x19u )
      {
        result = d_substitution(v1, 0);
        v89 = result;
        if ( **(_BYTE **)(v1 + 12) != 73 )
          return result;
LABEL_82:
        v43 = d_template_args(v1);
        result = d_make_comp(v1, 4, v89, v43);
        goto LABEL_83;
      }
      result = d_name(v1);
      v89 = result;
      if ( !result )
        return 0;
      if ( *(_DWORD *)result == 22 )
        return result;
      goto LABEL_32;
    case 0x54:
      result = d_template_param(v1);
      v89 = result;
      if ( **(_BYTE **)(v1 + 12) != 73 )
        goto LABEL_31;
      if ( !result )
        return result;
      v44 = *(_DWORD *)(v1 + 32);
      if ( v44 >= *(_DWORD *)(v1 + 36) )
        return 0;
      *(_DWORD *)(*(_DWORD *)(v1 + 28) + 4 * v44) = result;
      *(_DWORD *)(v1 + 32) = v44 + 1;
      goto LABEL_82;
    case 0x55:
      *(_DWORD *)(v1 + 12) = v2 + 1;
      v45 = d_source_name(v1);
      v46 = d_type(v1);
      result = d_make_comp(v1, 29, v46, v45);
      v89 = result;
      goto LABEL_31;
    case 0x61:
    case 0x62:
    case 0x63:
    case 0x64:
    case 0x65:
    case 0x66:
    case 0x67:
    case 0x68:
    case 0x69:
    case 0x6A:
    case 0x6C:
    case 0x6D:
    case 0x6E:
    case 0x6F:
    case 0x73:
    case 0x74:
    case 0x76:
    case 0x77:
    case 0x78:
    case 0x79:
    case 0x7A:
      v47 = 4 * (5 * v3 - 485) + 4313152;
      v48 = *(_DWORD *)(v1 + 20);
      if ( v48 < *(_DWORD *)(v1 + 24) )
      {
        result = *(_DWORD *)(v1 + 16) + 12 * v48;
        *(_DWORD *)(v1 + 20) = v48 + 1;
        if ( result )
        {
          *(_DWORD *)result = 35;
          *(_DWORD *)(result + 4) = v47;
        }
        else
        {
          v47 = ::v4;
        }
      }
      else
      {
        v47 = ::v4;
        result = 0;
      }
      *(_DWORD *)(v1 + 48) += *(_DWORD *)(v47 + 4);
      *(_DWORD *)(v1 + 12) = v2 + 1;
      return result;
  }
  do
  {
    v29 = d_type(v1);
    if ( !v29 || (v27 = d_make_comp_constprop_21(v1, 42, v29), (*v26 = v27) == 0) )
    {
LABEL_60:
      v24 = *(char **)(v1 + 12);
LABEL_61:
      result = 0;
      goto LABEL_62;
    }
    v26 = (int *)(v27 + 8);
    v24 = *(char **)(v1 + 12);
    v28 = *v24;
  }
  while ( *v24 && v28 != 69 && v28 != 46 );
  v79 = v89;
  if ( !v89 )
    goto LABEL_61;
  if ( !*(_DWORD *)(v89 + 8) )
  {
    v83 = *(_DWORD *)(v89 + 4);
    if ( *(_DWORD *)v83 == 35 )
    {
      v84 = *(_DWORD *)(v83 + 4);
      if ( *(_DWORD *)(v84 + 16) == 9 )
      {
        *(_DWORD *)(v1 + 48) -= *(_DWORD *)(v84 + 4);
        *(_DWORD *)(v79 + 4) = 0;
      }
    }
  }
  result = d_make_comp(v1, 37, v23, v79);
  v24 = *(char **)(v1 + 12);
LABEL_62:
  if ( *v24 == 69 )
  {
    *(_DWORD *)(v1 + 12) = v24 + 1;
    goto LABEL_83;
  }
LABEL_44:
  result = 0;
LABEL_83:
  v89 = result;
LABEL_31:
  if ( result )
  {
LABEL_32:
    v13 = *(_DWORD *)(v1 + 32);
    if ( v13 < *(_DWORD *)(v1 + 36) )
    {
      *(_DWORD *)(*(_DWORD *)(v1 + 28) + 4 * v13) = result;
      *(_DWORD *)(v1 + 32) = v13 + 1;
      return v89;
    }
    return 0;
  }
  return result;
}
// 41D248: using guessed type char *off_41D248;
// 41D25C: using guessed type char *off_41D25C;
// 41D270: using guessed type char *off_41D270;
// 41D284: using guessed type char *off_41D284;
// 41D298: using guessed type char *off_41D298;
// 41D2AC: using guessed type char *off_41D2AC;
// 41D2C0: using guessed type char *off_41D2C0;

//----- (0040C078) --------------------------------------------------------
int __usercall d_operator_name@<eax>(int a1@<eax>)
{
  int v1; // eax@1
  char v2; // bl@1
  int v3; // ecx@6
  int v4; // edx@6
  int result; // eax@7
  int v6; // esi@11
  int v7; // eax@11
  void **v8; // edi@12
  _BYTE *v9; // ebp@12
  char v10; // cl@18
  int v11; // eax@23
  int v12; // edx@24
  char v13; // [sp+Bh] [bp-21h]@2
  int v14; // [sp+Ch] [bp-20h]@1

  v14 = a1;
  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_BYTE *)v1;
  if ( *(_BYTE *)v1 )
  {
    *(_DWORD *)(v14 + 12) = v1 + 1;
    v13 = *(_BYTE *)(v1 + 1);
    if ( v13 )
      *(_DWORD *)(v14 + 12) = v1 + 2;
    if ( v2 == 118 )
    {
      if ( (unsigned __int8)(v13 - 48) <= 9u )
      {
        v3 = d_source_name(v14);
        v4 = *(_DWORD *)(v14 + 20);
        if ( v4 < *(_DWORD *)(v14 + 24) )
        {
          result = *(_DWORD *)(v14 + 16) + 12 * v4;
          *(_DWORD *)(v14 + 20) = v4 + 1;
          if ( result )
          {
            if ( v3 )
            {
              *(_DWORD *)result = 46;
              *(_DWORD *)(result + 4) = v13 - 48;
              *(_DWORD *)(result + 8) = v3;
              return result;
            }
          }
        }
        return 0;
      }
    }
    else if ( v2 == 99 && v13 == 118 )
    {
      v11 = d_type(v14);
      return d_make_comp_constprop_21(v14, 47, v11);
    }
  }
  else
  {
    v13 = 0;
  }
  v6 = 57;
  v7 = 0;
  while ( 1 )
  {
    v8 = &cplus_demangle_operators + 4 * (v7 + (v6 - v7) / 2);
    v9 = *v8;
    if ( v2 != *(_BYTE *)*v8 )
    {
      if ( *v9 <= v2 )
        goto LABEL_20;
      goto LABEL_14;
    }
    v10 = v9[1];
    if ( v13 == v10 )
      break;
    if ( v10 <= v13 )
    {
LABEL_20:
      v7 += (v6 - v7) / 2 + 1;
      goto LABEL_15;
    }
LABEL_14:
    v6 = v7 + (v6 - v7) / 2;
LABEL_15:
    if ( v7 == v6 )
      return 0;
  }
  v12 = *(_DWORD *)(v14 + 20);
  if ( v12 >= *(_DWORD *)(v14 + 24) )
    return 0;
  result = *(_DWORD *)(v14 + 16) + 12 * v12;
  *(_DWORD *)(v14 + 20) = v12 + 1;
  if ( !result )
    return 0;
  *(_DWORD *)result = 45;
  *(_DWORD *)(result + 4) = v8;
  return result;
}
// 41D680: using guessed type void *cplus_demangle_operators;

//----- (0040C1B4) --------------------------------------------------------
int __usercall d_unqualified_name@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  char v3; // al@1
  char v4; // al@6
  int v5; // ebp@8
  int v7; // eax@10
  int v8; // edx@12
  int v9; // eax@12
  bool v10; // zf@12
  _BYTE *v11; // esi@12
  _BYTE *v12; // edi@12
  signed int v13; // ecx@12
  int v14; // eax@16
  int v15; // eax@19
  int v16; // edx@19
  _BYTE *v17; // edi@22
  int v18; // ecx@22
  int v19; // esi@23
  int v20; // esi@24
  int v21; // eax@25
  int v22; // eax@27
  int v23; // eax@29
  int v24; // esi@30
  char v25; // al@33
  int *v26; // esi@36
  int v27; // eax@38
  int v28; // eax@39
  int v29; // edi@40
  char v30; // dl@40
  int v31; // edx@43
  int v32; // eax@45
  int v33; // edx@45
  _BYTE *v34; // edi@48
  int v35; // ecx@48
  int v36; // esi@49
  int v37; // esi@50
  int v38; // eax@51
  int v39; // edx@55
  _DWORD *v40; // edi@55
  int v41; // ecx@55
  signed int v42; // ebp@56
  _BYTE *v43; // edx@58
  int v44; // ebx@58
  int v45; // edx@63
  char v46; // al@68
  signed int v47; // ecx@71
  int v48; // eax@72
  char v49; // al@77
  signed int v50; // ecx@80
  int v51; // eax@81
  int v52; // eax@86
  int v53; // eax@87
  int v54; // [sp+18h] [bp-34h]@42
  int v55; // [sp+2Ch] [bp-20h]@33

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_BYTE *)v2;
  if ( (unsigned __int8)(*(_BYTE *)v2 - 48) > 9u )
  {
    if ( (unsigned __int8)(v3 - 97) <= 0x19u )
    {
      v7 = d_operator_name(v1);
      v5 = v7;
      if ( v7 )
      {
        if ( *(_DWORD *)v7 == 45 )
        {
          v8 = *(_DWORD *)(v7 + 4);
          v9 = *(_DWORD *)(v8 + 8) + *(_DWORD *)(v1 + 48);
          v10 = v9 == -7;
          *(_DWORD *)(v1 + 48) = v9 + 7;
          v11 = *(_BYTE **)v8;
          v12 = &unk_41CD88;
          v13 = 3;
          do
          {
            if ( !v13 )
              break;
            v10 = *v11++ == *v12++;
            --v13;
          }
          while ( v10 );
          if ( v10 )
          {
            v14 = d_source_name(v1);
            v5 = d_make_comp(v1, 49, v5, v14);
          }
        }
        return v5;
      }
      return 0;
    }
    if ( (unsigned __int8)(v3 - 67) <= 1u )
    {
      v45 = *(_DWORD *)(v1 + 44);
      if ( v45 && (!*(_DWORD *)v45 || *(_DWORD *)v45 == 22) )
      {
        *(_DWORD *)(v1 + 48) += *(_DWORD *)(v45 + 8);
        v3 = *(_BYTE *)v2;
      }
      if ( v3 == 67 )
      {
        v49 = *(_BYTE *)(v2 + 1);
        if ( v49 == 50 )
        {
          v50 = 2;
        }
        else if ( v49 > 50 )
        {
          if ( v49 == 51 )
          {
            v50 = 3;
          }
          else
          {
            if ( v49 != 53 )
              return 0;
            v50 = 4;
          }
        }
        else
        {
          if ( v49 != 49 )
            return 0;
          v50 = 1;
        }
        *(_DWORD *)(v1 + 12) = v2 + 2;
        v51 = *(_DWORD *)(v1 + 20);
        if ( v51 < *(_DWORD *)(v1 + 24) )
        {
          v5 = *(_DWORD *)(v1 + 16) + 12 * v51;
          *(_DWORD *)(v1 + 20) = v51 + 1;
          if ( v5 )
          {
            if ( v45 )
            {
              *(_DWORD *)v5 = 7;
              *(_DWORD *)(v5 + 4) = v50;
              *(_DWORD *)(v5 + 8) = v45;
              return v5;
            }
          }
        }
        return 0;
      }
      if ( v3 == 68 )
      {
        v46 = *(_BYTE *)(v2 + 1);
        if ( v46 == 49 )
        {
          v47 = 2;
        }
        else if ( v46 > 49 )
        {
          if ( v46 == 50 )
          {
            v47 = 3;
          }
          else
          {
            if ( v46 != 53 )
              return 0;
            v47 = 4;
          }
        }
        else
        {
          if ( v46 != 48 )
            return 0;
          v47 = 1;
        }
        *(_DWORD *)(v1 + 12) = v2 + 2;
        v48 = *(_DWORD *)(v1 + 20);
        if ( v48 < *(_DWORD *)(v1 + 24) )
        {
          v5 = *(_DWORD *)(v1 + 16) + 12 * v48;
          *(_DWORD *)(v1 + 20) = v48 + 1;
          if ( v5 )
          {
            if ( v45 )
            {
              *(_DWORD *)v5 = 8;
              *(_DWORD *)(v5 + 4) = v47;
              *(_DWORD *)(v5 + 8) = v45;
              return v5;
            }
          }
        }
        return 0;
      }
    }
    else
    {
      if ( v3 == 76 )
      {
        *(_DWORD *)(v1 + 12) = v2 + 1;
        v23 = d_source_name(v1);
        if ( v23 )
        {
          v24 = *(_DWORD *)(v1 + 12);
          if ( *(_BYTE *)v24 != 95 )
            return v23;
          v39 = v24 + 1;
          *(_DWORD *)(v1 + 12) = v24 + 1;
          v40 = (_DWORD *)(v1 + 12);
          v41 = *(_BYTE *)(v24 + 1);
          if ( (_BYTE)v41 == 110 )
          {
            v39 = v24 + 2;
            *(_DWORD *)(v1 + 12) = v24 + 2;
            v41 = *(_BYTE *)(v24 + 2);
            v42 = 1;
          }
          else
          {
            v42 = 0;
          }
          if ( (unsigned __int8)(v41 - 48) > 9u )
          {
            v44 = 0;
          }
          else
          {
            v43 = (_BYTE *)(v39 + 1);
            v44 = 0;
            do
            {
              v44 = v41 + 10 * v44 - 48;
              *v40 = v43;
              v41 = *v43++;
            }
            while ( (unsigned __int8)(v41 - 48) <= 9u );
          }
          if ( !v42 )
            return v23;
          if ( v44 <= 0 )
            return v23;
        }
        return 0;
      }
      if ( v3 == 85 )
      {
        v4 = *(_BYTE *)(v2 + 1);
        if ( v4 == 108 )
        {
          *(_DWORD *)(v1 + 12) = v2 + 1;
          if ( *(_BYTE *)(v2 + 1) == 108 )
          {
            *(_DWORD *)(v1 + 12) = v2 + 2;
            v55 = 0;
            v25 = *(_BYTE *)(v2 + 2);
            if ( v25 )
            {
              if ( v25 != 69 && v25 != 46 )
              {
                v26 = &v55;
                while ( 1 )
                {
                  v27 = d_type(v1);
                  if ( !v27 )
                    break;
                  v28 = d_make_comp_constprop_21(v1, 42, v27);
                  *v26 = v28;
                  if ( !v28 )
                    break;
                  v26 = (int *)(v28 + 8);
                  v29 = *(_DWORD *)(v1 + 12);
                  v30 = *(_BYTE *)v29;
                  if ( !*(_BYTE *)v29 || v30 == 69 || v30 == 46 )
                  {
                    v54 = v55;
                    if ( !v55 )
                      return 0;
                    v31 = v55;
                    if ( !*(_DWORD *)(v55 + 8) )
                    {
                      v52 = *(_DWORD *)(v55 + 4);
                      if ( *(_DWORD *)v52 == 35 )
                      {
                        v53 = *(_DWORD *)(v52 + 4);
                        if ( *(_DWORD *)(v53 + 16) == 9 )
                        {
                          *(_DWORD *)(v1 + 48) -= *(_DWORD *)(v53 + 4);
                          *(_DWORD *)(v31 + 4) = 0;
                        }
                      }
                    }
                    if ( *(_BYTE *)v29 != 69 )
                      return 0;
                    v32 = v29 + 1;
                    *(_DWORD *)(v1 + 12) = v29 + 1;
                    v33 = *(_BYTE *)(v29 + 1);
                    if ( (_BYTE)v33 == 95 )
                    {
                      v37 = 0;
                    }
                    else
                    {
                      if ( (_BYTE)v33 == 110 )
                        return 0;
                      if ( (unsigned __int8)(v33 - 48) > 9u )
                        return 0;
                      v34 = (_BYTE *)(v29 + 2);
                      v35 = 0;
                      do
                      {
                        v36 = v33 + 10 * v35;
                        v35 = v36 - 48;
                        v32 = (int)v34;
                        *(_DWORD *)(v1 + 12) = v34;
                        v33 = *v34++;
                      }
                      while ( (unsigned __int8)(v33 - 48) <= 9u );
                      v37 = v36 - 47;
                      if ( (_BYTE)v33 != 95 )
                        return 0;
                    }
                    *(_DWORD *)(v1 + 12) = v32 + 1;
                    v38 = *(_DWORD *)(v1 + 20);
                    if ( v38 >= *(_DWORD *)(v1 + 24) )
                      return 0;
                    v5 = *(_DWORD *)(v1 + 16) + 12 * v38;
                    *(_DWORD *)(v1 + 20) = v38 + 1;
                    if ( !v5 )
                      return 0;
                    *(_DWORD *)v5 = 64;
                    *(_DWORD *)(v5 + 4) = v54;
                    *(_DWORD *)(v5 + 8) = v37;
                    v22 = *(_DWORD *)(v1 + 32);
                    if ( v22 >= *(_DWORD *)(v1 + 36) )
                      return 0;
                    goto LABEL_28;
                  }
                }
              }
            }
          }
          return 0;
        }
        if ( v4 == 116 )
        {
          *(_DWORD *)(v1 + 12) = v2 + 1;
          if ( *(_BYTE *)(v2 + 1) == 116 )
          {
            v15 = v2 + 2;
            *(_DWORD *)(v1 + 12) = v2 + 2;
            v16 = *(_BYTE *)(v2 + 2);
            if ( (_BYTE)v16 == 95 )
            {
              v20 = 0;
            }
            else
            {
              if ( (_BYTE)v16 == 110 )
                return 0;
              if ( (unsigned __int8)(v16 - 48) > 9u )
                return 0;
              v17 = (_BYTE *)(v2 + 3);
              v18 = 0;
              do
              {
                v19 = v16 + 10 * v18;
                v18 = v19 - 48;
                v15 = (int)v17;
                *(_DWORD *)(v1 + 12) = v17;
                v16 = *v17++;
              }
              while ( (unsigned __int8)(v16 - 48) <= 9u );
              v20 = v19 - 47;
              if ( (_BYTE)v16 != 95 )
                return 0;
            }
            *(_DWORD *)(v1 + 12) = v15 + 1;
            v21 = *(_DWORD *)(v1 + 20);
            if ( v21 < *(_DWORD *)(v1 + 24) )
            {
              v5 = *(_DWORD *)(v1 + 16) + 12 * v21;
              *(_DWORD *)(v1 + 20) = v21 + 1;
              if ( v5 )
              {
                *(_DWORD *)v5 = 66;
                *(_DWORD *)(v5 + 4) = v20;
                v22 = *(_DWORD *)(v1 + 32);
                if ( v22 < *(_DWORD *)(v1 + 36) )
                {
LABEL_28:
                  *(_DWORD *)(*(_DWORD *)(v1 + 28) + 4 * v22) = v5;
                  *(_DWORD *)(v1 + 32) = v22 + 1;
                  return v5;
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return d_source_name(v1);
}

//----- (0040C688) --------------------------------------------------------
int __usercall d_expression@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edx@1
  char v3; // al@1
  int v4; // esi@6
  int v6; // edi@14
  int *v7; // esi@15
  int v8; // eax@16
  int v9; // eax@17
  _BYTE *v10; // eax@18
  int v11; // eax@19
  int *v12; // eax@22
  int v13; // ebp@22
  int v14; // eax@23
  char v15; // al@28
  int v16; // eax@30
  _BYTE *v17; // eax@31
  int v18; // ecx@31
  int v19; // edx@35
  int v20; // esi@36
  int v21; // esi@37
  int v22; // edx@39
  signed int v23; // edx@41
  bool v24; // zf@45
  const char *v25; // edi@46
  signed int v26; // ecx@46
  _BYTE *v27; // esi@46
  char v28; // al@51
  _BYTE *v29; // eax@53
  int *v30; // esi@53
  int v31; // eax@54
  int v32; // eax@55
  _BYTE *v33; // eax@56
  int v34; // edi@57
  int v35; // esi@58
  int v36; // edx@58
  char v37; // al@58
  int v38; // eax@62
  int v39; // eax@63
  int v40; // eax@63
  int v41; // edx@68
  int v42; // ecx@68
  unsigned __int8 v43; // cf@68
  bool v44; // zf@68
  const char *v45; // edi@68
  signed int v46; // ecx@68
  _BYTE *v47; // esi@68
  signed int v48; // esi@73
  int v49; // eax@74
  int v50; // eax@75
  int v52; // eax@8
  int v53; // esi@82
  int v54; // eax@82
  int v55; // edi@82
  int v56; // eax@83
  int v57; // eax@86
  int *v58; // edi@90
  int v59; // eax@91
  int v60; // eax@92
  _BYTE *v61; // eax@93
  bool v62; // zf@95
  const char *v63; // edi@95
  signed int v64; // ecx@95
  _BYTE *v65; // esi@95
  _BYTE *v66; // edi@99
  signed int v67; // ecx@99
  _BYTE *v68; // esi@99
  _BYTE *v69; // edi@103
  signed int v70; // ecx@103
  _BYTE *v71; // esi@103
  int v72; // esi@107
  int v73; // eax@109
  int v74; // ST00_4@112
  _BYTE *v75; // eax@114
  int *v76; // esi@114
  int v77; // eax@115
  int v78; // eax@116
  _BYTE *v79; // eax@117
  int v80; // eax@120
  int v81; // ST00_4@120
  int v82; // eax@108
  int v83; // eax@128
  int v84; // eax@129
  _BYTE *v85; // eax@130
  char v86; // dl@141
  _BYTE *v87; // edx@147
  int v88; // [sp+0h] [bp-4Ch]@76
  int v89; // [sp+18h] [bp-34h]@41
  int *v90; // [sp+18h] [bp-34h]@127
  int v91; // [sp+1Ch] [bp-30h]@95
  int v92; // [sp+2Ch] [bp-20h]@15

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_BYTE *)v2;
  if ( *(_BYTE *)v2 == 76 )
    return d_expr_primary(v1);
  if ( v3 == 84 )
    return d_template_param(v1);
  if ( v3 == 115 )
  {
    v15 = *(_BYTE *)(v2 + 1);
    if ( v15 == 114 )
    {
      *(_DWORD *)(v1 + 12) = v2 + 2;
      v53 = d_type(v1);
      v54 = d_unqualified_name(v1);
      v55 = v54;
      if ( **(_BYTE **)(v1 + 12) == 73 )
      {
        v80 = d_template_args(v1);
        v81 = d_make_comp(v1, 4, v55, v80);
        v56 = d_make_comp(v1, 1, v53, v81);
      }
      else
      {
        v56 = d_make_comp(v1, 1, v53, v54);
      }
      return v56;
    }
    if ( v15 == 112 )
    {
      *(_DWORD *)(v1 + 12) = v2 + 2;
      v16 = d_expression(v1);
      return d_make_comp_constprop_21(v1, 69, v16);
    }
LABEL_22:
    v12 = (int *)d_operator_name(v1);
    v13 = (int)v12;
    if ( !v12 )
      return 0;
    v14 = *v12;
    if ( v14 == 45 )
    {
      v41 = *(_DWORD *)(v13 + 4);
      v89 = *(_DWORD *)v41;
      v42 = *(_DWORD *)(v41 + 8) - 2;
      v43 = __CFADD__(v42, *(_DWORD *)(v1 + 48));
      v44 = v42 + *(_DWORD *)(v1 + 48) == 0;
      *(_DWORD *)(v1 + 48) += v42;
      v45 = "st";
      v46 = 3;
      v47 = (_BYTE *)v89;
      do
      {
        if ( !v46 )
          break;
        v43 = *v47 < (const unsigned __int8)*v45;
        v44 = *v47++ == *v45++;
        --v46;
      }
      while ( v44 );
      if ( !(v43 | v44) == v43 )
      {
        v74 = d_type(v1);
        return d_make_comp(v1, 49, v13, v74);
      }
    }
    else
    {
      if ( v14 == 46 )
      {
        v23 = *(_DWORD *)(v13 + 4);
        v89 = 0;
        goto LABEL_42;
      }
      if ( v14 == 47 )
      {
        v48 = 0;
LABEL_74:
        v49 = *(_DWORD *)(v1 + 12);
        if ( *(_BYTE *)v49 == 95 )
        {
          *(_DWORD *)(v1 + 12) = v49 + 1;
          v92 = 0;
          v58 = &v92;
          if ( *(_BYTE *)(v49 + 1) == 69 )
          {
            *(_DWORD *)(v1 + 12) = v49 + 2;
            v50 = d_make_comp_constprop_21(v1, 42, 0);
          }
          else
          {
            while ( 1 )
            {
              v59 = d_expression(v1);
              if ( !v59 )
                break;
              v60 = d_make_comp_constprop_21(v1, 42, v59);
              *v58 = v60;
              if ( !v60 )
                break;
              v58 = (int *)(v60 + 8);
              v61 = *(_BYTE **)(v1 + 12);
              if ( *v61 == 69 )
              {
                *(_DWORD *)(v1 + 12) = v61 + 1;
                v50 = v92;
                goto LABEL_76;
              }
            }
            v50 = 0;
          }
          goto LABEL_76;
        }
LABEL_75:
        v50 = d_expression(v1);
LABEL_76:
        v88 = v50;
        if ( v48 )
          v88 = d_make_comp(v1, 51, v50, v50);
        return d_make_comp(v1, 49, v13, v88);
      }
      if ( v14 != 45 )
        return 0;
      v41 = *(_DWORD *)(v13 + 4);
      v89 = 0;
    }
    v23 = *(_DWORD *)(v41 + 12);
LABEL_42:
    if ( v23 != 1 )
    {
      if ( v23 <= 1 )
      {
        if ( v23 )
          return 0;
        v4 = d_make_comp_constprop_21(v1, 48, v13);
      }
      else
      {
        if ( v23 == 2 )
        {
          v91 = d_expression(v1);
          v63 = "cl";
          v64 = 3;
          v65 = (_BYTE *)v89;
          do
          {
            if ( !v64 )
              break;
            v62 = *v65++ == *v63++;
            --v64;
          }
          while ( v62 );
          if ( v62 )
          {
            v92 = 0;
            v75 = *(_BYTE **)(v1 + 12);
            v76 = &v92;
            if ( *v75 == 69 )
            {
              *(_DWORD *)(v1 + 12) = v75 + 1;
              v72 = d_make_comp_constprop_21(v1, 42, 0);
            }
            else
            {
              while ( 1 )
              {
                v77 = d_expression(v1);
                if ( !v77 )
                  break;
                v78 = d_make_comp_constprop_21(v1, 42, v77);
                *v76 = v78;
                if ( !v78 )
                  break;
                v76 = (int *)(v78 + 8);
                v79 = *(_BYTE **)(v1 + 12);
                if ( *v79 == 69 )
                {
                  *(_DWORD *)(v1 + 12) = v79 + 1;
                  v72 = v92;
                  goto LABEL_109;
                }
              }
              v72 = 0;
            }
          }
          else
          {
            v66 = &unk_41CD8B;
            v67 = 3;
            v68 = (_BYTE *)v89;
            do
            {
              if ( !v67 )
                break;
              v62 = *v68++ == *v66++;
              --v67;
            }
            while ( v62 );
            if ( v62 )
              goto LABEL_152;
            v69 = &unk_41CD8E;
            v70 = 3;
            v71 = (_BYTE *)v89;
            do
            {
              if ( !v70 )
                break;
              v62 = *v71++ == *v69++;
              --v70;
            }
            while ( v62 );
            if ( v62 )
            {
LABEL_152:
              v72 = d_unqualified_name(v1);
              if ( **(_BYTE **)(v1 + 12) == 73 )
              {
                v82 = d_template_args(v1);
                v72 = d_make_comp(v1, 4, v72, v82);
              }
            }
            else
            {
              v72 = d_expression(v1);
            }
          }
LABEL_109:
          v73 = d_make_comp(v1, 51, v91, v72);
          return d_make_comp(v1, 50, v13, v73);
        }
        v24 = v23 == 3;
        if ( v23 != 3 )
          return 0;
        v25 = "qu";
        v26 = 3;
        v27 = (_BYTE *)v89;
        do
        {
          if ( !v26 )
            break;
          v24 = *v27++ == *v25++;
          --v26;
        }
        while ( v24 );
        if ( v24 )
        {
          v34 = d_expression(v1);
          v35 = d_expression(v1);
          v38 = d_expression(v1);
        }
        else
        {
          if ( *(_BYTE *)v89 != 110 )
            return 0;
          v28 = *(_BYTE *)(v89 + 1);
          if ( v28 != 119 && v28 != 97 )
            return 0;
          v92 = 0;
          v29 = *(_BYTE **)(v1 + 12);
          v30 = &v92;
          if ( *v29 == 95 )
          {
            *(_DWORD *)(v1 + 12) = v29 + 1;
            v34 = d_make_comp_constprop_21(v1, 42, 0);
          }
          else
          {
            while ( 1 )
            {
              v31 = d_expression(v1);
              if ( !v31 )
                break;
              v32 = d_make_comp_constprop_21(v1, 42, v31);
              *v30 = v32;
              if ( !v32 )
                break;
              v30 = (int *)(v32 + 8);
              v33 = *(_BYTE **)(v1 + 12);
              if ( *v33 == 95 )
              {
                *(_DWORD *)(v1 + 12) = v33 + 1;
                v34 = v92;
                goto LABEL_58;
              }
            }
            v34 = 0;
          }
LABEL_58:
          v35 = d_type(v1);
          v36 = *(_DWORD *)(v1 + 12);
          v37 = *(_BYTE *)v36;
          if ( *(_BYTE *)v36 == 69 )
          {
            *(_DWORD *)(v1 + 12) = v36 + 1;
            v38 = 0;
          }
          else if ( v37 == 112 )
          {
            if ( *(_BYTE *)(v36 + 1) != 105 )
              return 0;
            *(_DWORD *)(v1 + 12) = v36 + 2;
            v92 = 0;
            v90 = &v92;
            if ( *(_BYTE *)(v36 + 2) == 69 )
            {
              *(_DWORD *)(v1 + 12) = v36 + 3;
              v38 = d_make_comp_constprop_21(v1, 42, 0);
            }
            else
            {
              while ( 1 )
              {
                v83 = d_expression(v1);
                if ( !v83 )
                  break;
                v84 = d_make_comp_constprop_21(v1, 42, v83);
                *v90 = v84;
                if ( !v84 )
                  break;
                v90 = (int *)(v84 + 8);
                v85 = *(_BYTE **)(v1 + 12);
                if ( *v85 == 69 )
                {
                  *(_DWORD *)(v1 + 12) = v85 + 1;
                  v38 = v92;
                  goto LABEL_63;
                }
              }
              v38 = 0;
            }
          }
          else
          {
            if ( v37 != 105 || *(_BYTE *)(v36 + 1) != 108 )
              return 0;
            v38 = d_expression(v1);
          }
        }
LABEL_63:
        v39 = d_make_comp(v1, 54, v35, v38);
        v40 = d_make_comp(v1, 53, v34, v39);
        v4 = d_make_comp(v1, 52, v13, v40);
      }
      return v4;
    }
    v48 = 0;
    if ( v89 )
    {
      v86 = *(_BYTE *)v89;
      if ( *(_BYTE *)v89 == 112 || v86 == 109 )
      {
        if ( v86 == *(_BYTE *)(v89 + 1) )
        {
          v87 = *(_BYTE **)(v1 + 12);
          if ( *v87 == 95 )
          {
            *(_DWORD *)(v1 + 12) = v87 + 1;
            v48 = 0;
          }
          else
          {
            v48 = 1;
          }
        }
        else
        {
          v48 = 0;
        }
      }
    }
    if ( v14 != 47 )
      goto LABEL_75;
    goto LABEL_74;
  }
  if ( v3 != 102 )
  {
    if ( (unsigned __int8)(v3 - 48) <= 9u )
      goto LABEL_6;
    if ( v3 == 111 )
    {
      if ( *(_BYTE *)(v2 + 1) == 110 )
      {
        *(_DWORD *)(v1 + 12) = v2 + 2;
LABEL_6:
        v4 = d_unqualified_name(v1);
        if ( v4 )
        {
          if ( **(_BYTE **)(v1 + 12) == 73 )
          {
            v52 = d_template_args(v1);
            v4 = d_make_comp(v1, 4, v4, v52);
          }
          return v4;
        }
        return 0;
      }
    }
    else if ( v3 == 105 )
    {
      if ( *(_BYTE *)(v2 + 1) == 108 )
      {
        v6 = 0;
        goto LABEL_15;
      }
    }
    else if ( v3 == 116 && *(_BYTE *)(v2 + 1) == 108 )
    {
      v6 = d_type(v1);
      v2 = *(_DWORD *)(v1 + 12);
LABEL_15:
      *(_DWORD *)(v1 + 12) = v2 + 2;
      v92 = 0;
      v7 = &v92;
      if ( *(_BYTE *)(v2 + 2) == 69 )
      {
        *(_DWORD *)(v1 + 12) = v2 + 3;
        v11 = d_make_comp_constprop_21(v1, 42, 0);
      }
      else
      {
        while ( 1 )
        {
          v8 = d_expression(v1);
          if ( !v8 )
            break;
          v9 = d_make_comp_constprop_21(v1, 42, v8);
          *v7 = v9;
          if ( !v9 )
            break;
          v7 = (int *)(v9 + 8);
          v10 = *(_BYTE **)(v1 + 12);
          if ( *v10 == 69 )
          {
            *(_DWORD *)(v1 + 12) = v10 + 1;
            v11 = v92;
            return d_make_comp(v1, 44, v6, v11);
          }
        }
        v11 = 0;
      }
      return d_make_comp(v1, 44, v6, v11);
    }
    goto LABEL_22;
  }
  if ( *(_BYTE *)(v2 + 1) != 112 )
    goto LABEL_22;
  v17 = (_BYTE *)(v2 + 2);
  *(_DWORD *)(v1 + 12) = v2 + 2;
  v18 = *(_BYTE *)(v2 + 2);
  if ( (_BYTE)v18 == 84 )
  {
    *(_DWORD *)(v1 + 12) = v2 + 3;
    v22 = 0;
  }
  else if ( (_BYTE)v18 == 95 )
  {
    *(_DWORD *)(v1 + 12) = v2 + 3;
    v22 = 1;
  }
  else
  {
    if ( (_BYTE)v18 == 110 )
      return 0;
    if ( (unsigned __int8)(v18 - 48) > 9u )
    {
      v21 = 1;
    }
    else
    {
      v19 = 0;
      do
      {
        v20 = v18 + 10 * v19;
        v19 = v20 - 48;
        *(_DWORD *)(v1 + 12) = ++v17;
        v18 = *v17;
      }
      while ( (unsigned __int8)(v18 - 48) <= 9u );
      v21 = v20 - 47;
    }
    if ( (_BYTE)v18 != 95 )
      return 0;
    *(_DWORD *)(v1 + 12) = v17 + 1;
    v22 = v21 + 1;
    if ( v21 == -1 )
      return 0;
  }
  v57 = *(_DWORD *)(v1 + 20);
  if ( v57 < *(_DWORD *)(v1 + 24) )
  {
    v4 = *(_DWORD *)(v1 + 16) + 12 * v57;
    *(_DWORD *)(v1 + 20) = v57 + 1;
    if ( v4 )
    {
      *(_DWORD *)v4 = 6;
      *(_DWORD *)(v4 + 4) = v22;
      return v4;
    }
  }
  return 0;
}

//----- (0040CE60) --------------------------------------------------------
int __usercall d_bare_function_type@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  char *v3; // eax@1
  int v4; // edi@3
  char v5; // al@4
  int *v6; // esi@7
  int v7; // eax@8
  char v8; // al@9
  int v9; // eax@12
  int v11; // eax@14
  int v12; // edx@20
  int v13; // edx@21
  int v14; // [sp+1Ch] [bp-10h]@4

  v2 = a1;
  v3 = *(char **)(a1 + 12);
  if ( *v3 == 74 )
  {
    *(_DWORD *)(v2 + 12) = v3 + 1;
  }
  else if ( !a2 )
  {
    v4 = 0;
    goto LABEL_4;
  }
  v4 = d_type(v2);
  if ( !v4 )
    return 0;
  v3 = *(char **)(v2 + 12);
LABEL_4:
  v14 = 0;
  v5 = *v3;
  if ( v5 && v5 != 69 && v5 != 46 )
  {
    v6 = &v14;
    while ( 1 )
    {
      v9 = d_type(v2);
      if ( !v9 )
        break;
      v7 = d_make_comp_constprop_21(v2, 42, v9);
      *v6 = v7;
      if ( !v7 )
        break;
      v6 = (int *)(v7 + 8);
      v8 = **(_BYTE **)(v2 + 12);
      if ( !v8 || v8 == 69 || v8 == 46 )
      {
        v11 = v14;
        if ( !v14 )
          return 0;
        if ( !*(_DWORD *)(v14 + 8) )
        {
          v12 = *(_DWORD *)(v14 + 4);
          if ( *(_DWORD *)v12 == 35 )
          {
            v13 = *(_DWORD *)(v12 + 4);
            if ( *(_DWORD *)(v13 + 16) == 9 )
            {
              *(_DWORD *)(v2 + 48) -= *(_DWORD *)(v13 + 4);
              *(_DWORD *)(v11 + 4) = 0;
            }
          }
        }
        return d_make_comp(v2, 37, v4, v11);
      }
    }
  }
  return 0;
}

//----- (0040CF3C) --------------------------------------------------------
int __usercall d_encoding_part_6@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // ebx@1
  char v6; // al@9
  int v7; // eax@11
  int v8; // edx@11
  bool v9; // cf@11
  int v10; // edx@13
  int v11; // eax@14
  int v12; // eax@18
  int i; // eax@21

  v2 = a1;
  v3 = a2;
  v4 = d_name(a1);
  if ( !v4 )
    return v4;
  if ( v3 && !(*(_BYTE *)(v2 + 8) & 1) )
  {
    while ( (unsigned int)(*(_DWORD *)v4 - 26) <= 2 )
      v4 = *(_DWORD *)(v4 + 4);
    if ( *(_DWORD *)v4 == 2 )
    {
      for ( i = *(_DWORD *)(v4 + 8); (unsigned int)(*(_DWORD *)i - 26) <= 2; i = *(_DWORD *)(i + 4) )
        ;
      *(_DWORD *)(v4 + 8) = i;
    }
    return v4;
  }
  v6 = **(_BYTE **)(v2 + 12);
  if ( !v6 || v6 == 69 )
    return v4;
  v7 = v4;
  v8 = *(_DWORD *)v4;
  v9 = *(_DWORD *)v4 < 4u;
  if ( *(_DWORD *)v4 == 4 )
  {
LABEL_18:
    v12 = *(_DWORD *)(v7 + 4);
    if ( v12 )
    {
      while ( *(_DWORD *)v12 <= 0x2Fu )
      {
        switch ( *(_DWORD *)v12 )
        {
          case 7:
          case 8:
          case 0x2F:
            goto LABEL_13;
          default:
            goto LABEL_20;
          case 1:
          case 2:
            v12 = *(_DWORD *)(v12 + 8);
            if ( !v12 )
              goto LABEL_20;
            break;
        }
      }
    }
LABEL_20:
    v10 = 1;
  }
  else
  {
    while ( !v9 )
    {
      if ( (unsigned int)(v8 - 26) > 2 )
        break;
      v7 = *(_DWORD *)(v7 + 4);
      if ( !v7 )
        break;
      v8 = *(_DWORD *)v7;
      v9 = *(_DWORD *)v7 < 4u;
      if ( *(_DWORD *)v7 == 4 )
        goto LABEL_18;
    }
LABEL_13:
    v10 = 0;
  }
  v11 = d_bare_function_type(v2, v10);
  return d_make_comp(v2, 3, v4, v11);
}

//----- (0040D02C) --------------------------------------------------------
int __usercall d_encoding_constprop_18@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  char v2; // al@1
  int v3; // esi@3
  char v4; // al@3
  int v5; // eax@6
  int v6; // edx@10
  int v7; // eax@11
  int result; // eax@12
  int v9; // eax@16

  v1 = a1;
  v2 = **(_BYTE **)(a1 + 12);
  if ( v2 == 71 || v2 == 84 )
  {
    result = d_special_name(v1);
  }
  else
  {
    v3 = d_name(v1);
    v4 = **(_BYTE **)(v1 + 12);
    if ( v3 && v4 && v4 != 69 )
    {
      v5 = v3;
      while ( *(_DWORD *)v5 != 4 )
      {
        if ( *(_DWORD *)v5 >= 4u && (unsigned int)(*(_DWORD *)v5 - 26) <= 2 )
        {
          v5 = *(_DWORD *)(v5 + 4);
          if ( v5 )
            continue;
        }
LABEL_10:
        v6 = 0;
        goto LABEL_11;
      }
      v9 = *(_DWORD *)(v5 + 4);
      if ( v9 )
      {
        while ( *(_DWORD *)v9 <= 0x2Fu )
        {
          switch ( *(_DWORD *)v9 )
          {
            case 7:
            case 8:
            case 0x2F:
              goto LABEL_10;
            default:
              goto LABEL_18;
            case 1:
            case 2:
              v9 = *(_DWORD *)(v9 + 8);
              if ( !v9 )
                goto LABEL_18;
              break;
          }
        }
      }
LABEL_18:
      v6 = 1;
LABEL_11:
      v7 = d_bare_function_type(v1, v6);
      v3 = d_make_comp(v1, 3, v3, v7);
    }
    result = v3;
  }
  return result;
}

//----- (0040D0D8) --------------------------------------------------------
int __usercall d_demangle_callback_constprop_15@<eax>(int a1@<eax>, void (__cdecl *a2)(char *, int, int)@<edx>, int a3@<ecx>)
{
  const char *v3; // ebx@1
  bool v4; // zf@1
  const char *v5; // edi@2
  signed int v6; // ecx@2
  _BYTE *v7; // esi@2
  char v8; // al@6
  unsigned int v9; // kr04_4@10
  int v10; // esi@10
  int v11; // ecx@10
  void *v12; // esp@10
  void *v13; // esp@10
  int v14; // eax@10
  void *v15; // esp@10
  void *v16; // esp@10
  int v17; // edx@12
  int v18; // eax@15
  char v20; // al@17
  unsigned int v21; // kr0C_4@25
  unsigned int v22; // eax@28
  int *v23; // ebx@28
  int v24; // ecx@28
  unsigned int v25; // ecx@29
  char *v26; // eax@29
  char v27; // al@37
  const char *v28; // ecx@42
  int v29; // eax@42
  char v30; // cl@43
  int v31; // [sp+Ch] [bp-19Ch]@10
  char v32; // [sp+Fh] [bp-199h]@10
  int v33; // [sp+14h] [bp-194h]@1
  void (__cdecl *v34)(char *, int, int); // [sp+18h] [bp-190h]@1
  unsigned int v35; // [sp+1Ch] [bp-18Ch]@10
  unsigned int v36; // [sp+20h] [bp-188h]@10
  int v37; // [sp+24h] [bp-184h]@9
  unsigned int v38; // [sp+28h] [bp-180h]@10
  char v39; // [sp+2Fh] [bp-179h]@1
  const char *v40; // [sp+38h] [bp-170h]@10
  const char *v41; // [sp+3Ch] [bp-16Ch]@10
  int v42; // [sp+40h] [bp-168h]@10
  const char *v43; // [sp+44h] [bp-164h]@10
  unsigned int v44; // [sp+48h] [bp-160h]@10
  int v45; // [sp+4Ch] [bp-15Ch]@10
  int v46; // [sp+50h] [bp-158h]@10
  int *v47; // [sp+54h] [bp-154h]@10
  int v48; // [sp+58h] [bp-150h]@10
  unsigned int v49; // [sp+5Ch] [bp-14Ch]@10
  int v50; // [sp+60h] [bp-148h]@10
  int v51; // [sp+64h] [bp-144h]@10
  int v52; // [sp+68h] [bp-140h]@10
  char v53[256]; // [sp+6Ch] [bp-13Ch]@15
  int v54; // [sp+16Ch] [bp-3Ch]@15
  char v55; // [sp+170h] [bp-38h]@15
  void (__cdecl *v56)(char *, int, int); // [sp+174h] [bp-34h]@15
  int v57; // [sp+178h] [bp-30h]@15
  int v58; // [sp+17Ch] [bp-2Ch]@15
  int v59; // [sp+180h] [bp-28h]@15
  int v60; // [sp+184h] [bp-24h]@15
  int v61; // [sp+188h] [bp-20h]@15
  int v62; // [sp+18Ch] [bp-1Ch]@15

  v3 = (const char *)a1;
  v34 = a2;
  v33 = a3;
  v39 = *(_BYTE *)a1;
  v4 = v39 == 95;
  if ( v39 == 95 )
  {
    v4 = *(_BYTE *)(a1 + 1) == 90;
    if ( *(_BYTE *)(a1 + 1) == 90 )
    {
      v37 = 1;
      goto LABEL_10;
    }
  }
  v5 = "_GLOBAL_";
  v6 = 8;
  v7 = (_BYTE *)a1;
  do
  {
    if ( !v6 )
      break;
    v4 = *v7++ == *v5++;
    --v6;
  }
  while ( v4 );
  if ( !v4 || (v8 = *(_BYTE *)(a1 + 8), v8 != 46) && v8 != 95 && v8 != 36 )
  {
LABEL_9:
    v37 = 0;
    goto LABEL_10;
  }
  v20 = v3[9];
  if ( v20 != 68 )
  {
    if ( v20 == 73 )
    {
      v37 = 2 * (v3[10] == 95);
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  v37 = 3 * (v3[10] == 95);
LABEL_10:
  v9 = strlen(v3) + 1;
  v40 = v3;
  v41 = &v3[v9 - 1];
  v42 = 17;
  v43 = v3;
  v10 = 2 * (v9 - 1);
  v46 = v10;
  v45 = 0;
  v49 = v9 - 1;
  v48 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v11 = 4 * (v9 - 1);
  v12 = alloca(4 * (v11 + v10) + 3);
  v13 = alloca(4 * (v11 + v10) + 3);
  v38 = (unsigned int)&v32 >> 2;
  v35 = 4 * ((unsigned int)&v32 >> 2);
  v36 = 4 * ((unsigned int)&v32 >> 2);
  v14 = 16 * ((v11 + 18) / 0x10u);
  v15 = alloca(v14);
  v16 = alloca(v14);
  v44 = 4 * ((unsigned int)&v32 >> 2);
  v47 = &v31;
  if ( v37 != 1 )
  {
    if ( (unsigned int)v37 >= 1 && (unsigned int)v37 <= 3 )
    {
      v43 = v3 + 11;
      if ( v3[11] == 95 && v3[12] == 90 )
      {
        v43 = v3 + 13;
        v23 = (int *)&v40;
        v36 = d_encoding_constprop_18((int)&v40);
        v24 = v36;
      }
      else
      {
        v21 = strlen(v3 + 11) + 1;
        if ( v10 > 0 && (v45 = 1, v35) && v21 != 1 )
        {
          *(_DWORD *)(4 * v38) = 0;
          v22 = v35;
          *(_DWORD *)(v35 + 4) = v3 + 11;
          *(_DWORD *)(v22 + 8) = v21 - 1;
          v23 = (int *)&v40;
          v24 = v36;
        }
        else
        {
          v36 = 0;
          v23 = (int *)&v40;
          v24 = 0;
        }
      }
      v17 = d_make_comp_constprop_21((int)v23, (v37 != 2) + 62, v24);
      v25 = strlen(v43) + 1;
      v26 = (char *)&v43[v25 - 1];
      v43 = &v43[v25 - 1];
      goto LABEL_30;
    }
    v17 = d_type((int)&v40);
    v39 = *v43;
    goto LABEL_13;
  }
  if ( v39 == 95 )
  {
    v43 = v3 + 1;
    v39 = v3[1];
    if ( v39 == 90 )
    {
      v43 = v3 + 2;
      v27 = v3[2];
      if ( v27 == 71 || v27 == 84 )
        v17 = d_special_name((int)&v40);
      else
        v17 = d_encoding_part_6((int)&v40, 1);
      v26 = (char *)v43;
      if ( !(v42 & 1) )
      {
LABEL_30:
        v39 = *v26;
        if ( v39 )
          return 0;
        goto LABEL_14;
      }
      if ( *v43 == 46 )
      {
        v28 = v43;
        v29 = v17;
        while ( 1 )
        {
          v30 = v28[1];
          if ( (unsigned __int8)(v30 - 97) > 0x19u && v30 != 95 && (unsigned __int8)(v30 - 48) > 9u )
            return 0;
          v29 = d_clone_suffix((int)&v40, v29);
          v28 = v43;
          if ( *v43 != 46 )
          {
            v39 = *v43;
            v17 = v29;
            goto LABEL_13;
          }
        }
      }
      v39 = *v43;
LABEL_13:
      if ( v39 )
        return 0;
      goto LABEL_14;
    }
  }
  v17 = 0;
  if ( v39 )
    return 0;
LABEL_14:
  if ( v17 )
  {
    v54 = 0;
    v55 = 0;
    v58 = 0;
    v59 = 0;
    v61 = 0;
    v62 = 0;
    v56 = v34;
    v57 = v33;
    v60 = 0;
    d_print_comp_part_8((unsigned int)v53, 17, v17);
    v18 = v54;
    v53[v54] = 0;
    v56(v53, v18, v57);
    return v60 == 0;
  }
  return 0;
}
// 40D0D8: using guessed type char var_13C[256];

//----- (0040D520) --------------------------------------------------------
void *__cdecl __cxa_demangle(int a1, void *a2, int a3, int a4)
{
  signed int v4; // esi@6
  void *v5; // ebx@7
  unsigned int v6; // ecx@9
  void *v8; // [sp+10h] [bp-2Ch]@4
  int v9; // [sp+14h] [bp-28h]@4
  int v10; // [sp+18h] [bp-24h]@4
  int v11; // [sp+1Ch] [bp-20h]@4

  if ( !a1 || a2 && !a3 )
  {
    if ( a4 )
      *(_DWORD *)a4 = -3;
    return 0;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( d_demangle_callback_constprop_15(
         a1,
         (void (__cdecl *)(char *, int, int))d_growable_string_callback_adapter,
         (int)&v8) )
  {
    if ( v11 )
      v4 = 1;
    else
      v4 = v10;
    v5 = v8;
    if ( v8 )
    {
      if ( a2 )
      {
        v6 = strlen((const char *)v8) + 1;
        if ( v6 - 1 >= *(_DWORD *)a3 )
        {
          free(a2);
          *(_DWORD *)a3 = v4;
        }
        else
        {
          qmemcpy(a2, v8, v6);
          free(v5);
          v5 = a2;
        }
      }
      else if ( a3 )
      {
        *(_DWORD *)a3 = v4;
      }
      if ( a4 )
        *(_DWORD *)a4 = 0;
      return v5;
    }
    if ( a4 )
    {
      if ( v4 == 1 )
      {
        *(_DWORD *)a4 = -1;
        return v5;
      }
      goto LABEL_21;
    }
    return 0;
  }
  free(v8);
  if ( !a4 )
    return 0;
LABEL_21:
  *(_DWORD *)a4 = -2;
  return 0;
}

//----- (0040D668) --------------------------------------------------------
int __cdecl __gcclibcxx_demangle_callback(int a1, void (__cdecl *a2)(char *, int, int), int a3)
{
  int result; // eax@3

  if ( a1 && a2 )
    result = (unsigned int)d_demangle_callback_constprop_15(a1, a2, a3) < 1 ? 0xFFFFFFFE : 0;
  else
    result = -3;
  return result;
}

//----- (0040D6A0) --------------------------------------------------------
signed int __stdcall __dyn_tls_dtor(int a1, unsigned int a2, int a3)
{
  signed int result; // eax@3

  if ( a2 && a2 != 3 )
  {
    result = 1;
  }
  else
  {
    __mingw_TLScallback(a1, a2);
    result = 1;
  }
  return result;
}

//----- (0040D6F0) --------------------------------------------------------
signed int __stdcall __dyn_tls_init(int a1, int a2, int a3)
{
  if ( _CRT_MT != 2 )
    _CRT_MT = 2;
  if ( a2 != 2 && a2 == 1 )
    __mingw_TLScallback(a1, 1u);
  return 1;
}
// 55B920: using guessed type int _CRT_MT;

//----- (0040D780) --------------------------------------------------------
int __tlregdtor()
{
  return 0;
}

//----- (0040D790) --------------------------------------------------------
unsigned int __cpu_features_init()
{
  unsigned int v0; // et0@1
  unsigned int v1; // ST04_4@1
  unsigned int v2; // et0@1
  unsigned int v3; // edx@1
  unsigned int v4; // et0@1
  unsigned int result; // eax@1

  v0 = __getcallerseflags();
  v1 = v0;
  v2 = __readeflags();
  v3 = v2;
  __writeeflags(v2 ^ 0x200000);
  v4 = __readeflags();
  __writeeflags(v1);
  result = v3 ^ v4;
  if ( (v3 ^ v4) & 0x200000 )
  {
    _EAX = 0;
    __asm { cpuid }
    if ( result )
    {
      _EAX = 1;
      __asm { cpuid }
      if ( BYTE1(_EDX) & 1 )
        __cpu_features |= 1u;
      if ( BYTE1(_EDX) & 0x80 )
        __cpu_features |= 2u;
      if ( _EDX & 0x800000 )
        __cpu_features |= 4u;
      if ( _EDX & 0x1000000 )
        __cpu_features |= 8u;
      if ( _EDX & 0x2000000 )
        __cpu_features |= 0x10u;
      if ( _EDX & 0x4000000 )
        __cpu_features |= 0x20u;
      if ( _ECX & 1 )
        __cpu_features |= 0x40u;
      if ( BYTE1(_ECX) & 0x20 )
        __cpu_features |= 0x80u;
      _EAX = 2147483648;
      __asm { cpuid }
      if ( result > 0x80000000 )
      {
        _EAX = -2147483647;
        __asm { cpuid }
        if ( _EDX < 0 )
          __cpu_features |= 0x100u;
        if ( _EDX & 0x40000000 )
          __cpu_features |= 0x200u;
      }
    }
  }
  return result;
}
// 55B914: using guessed type int __cpu_features;

//----- (0040D870) --------------------------------------------------------
void __cdecl fpreset()
{
  __asm { fninit }
}

//----- (0040D880) --------------------------------------------------------
void __noreturn __report_error(char *a1, ...)
{
  va_list va; // [sp+34h] [bp+8h]@1

  va_start(va, a1);
  fwrite("Mingw runtime failure:\n", 1u, 0x17u, &__iob[2]);
  vfprintf(&__iob[2], a1, va);
  abort();
}

//----- (0040D8E0) --------------------------------------------------------
void *__usercall __write_memory_part_0@<eax>(size_t a1@<ecx>, void *a2@<edx>, void *a3@<eax>)
{
  void *v3; // ebx@1
  void *v4; // esi@1
  size_t v5; // edi@1
  void *result; // eax@3
  bool v7; // ST1F_1@6
  bool v8; // [sp+1Eh] [bp-3Eh]@6
  DWORD flOldProtect; // [sp+20h] [bp-3Ch]@6
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+24h] [bp-38h]@1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !VirtualQuery(a3, &Buffer, 0x1Cu) )
    __report_error("  VirtualQuery failed for %d bytes at address %p", 28, v3);
  if ( Buffer.Protect == 4 || Buffer.Protect == 64 )
  {
    result = memcpy(v3, v4, v5);
  }
  else
  {
    VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &flOldProtect);
    v8 = Buffer.Protect != 64;
    v7 = Buffer.Protect != 4;
    result = memcpy(v3, v4, v5);
    if ( v7 && v8 )
      result = (void *)VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, flOldProtect, &flOldProtect);
  }
  return result;
}

//----- (0040D9F0) --------------------------------------------------------
int _pei386_runtime_relocator()
{
  int result; // eax@1

  result = was_init_31048;
  if ( !was_init_31048 )
  {
    result = 0;
    was_init_31048 = 1;
  }
  return result;
}
// 40D9F0: could not find valid save-restore pair for ebx
// 40D9F0: could not find valid save-restore pair for edi
// 40D9F0: could not find valid save-restore pair for esi
// 55B918: using guessed type int was_init_31048;

//----- (0040DBD0) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
  void (*v0)(void); // eax@1

  v0 = (void (*)(void))*p_1761;
  if ( *p_1761 )
  {
    do
    {
      v0();
      v0 = (void (*)(void))p_1761[1];
      ++p_1761;
    }
    while ( v0 );
  }
}
// 417008: using guessed type int *p_1761;

//----- (0040DC00) --------------------------------------------------------
int __do_global_ctors()
{
  int i; // ebx@1

  i = __CTOR_LIST__[0];
  if ( __CTOR_LIST__[0] == -1 )
  {
    for ( i = 0; __CTOR_LIST__[i + 1]; ++i )
      ;
  }
  for ( ; i; --i )
    ((void (*)(void))__CTOR_LIST__[i])();
  return atexit(__do_global_dtors);
}
// 41602C: using guessed type int __CTOR_LIST__[];

//----- (0040DC50) --------------------------------------------------------
int __main()
{
  int result; // eax@2

  if ( !initialized )
  {
    initialized = 1;
    result = __do_global_ctors();
  }
  return result;
}
// 55B91C: using guessed type int initialized;

//----- (0040DC70) --------------------------------------------------------
void __mingwthr_run_key_dtors_part_0()
{
  int i; // ebx@1
  LPVOID v1; // esi@2

  EnterCriticalSection(&__mingwthr_cs);
  for ( i = key_dtor_list; i; i = *(_DWORD *)(i + 8) )
  {
    v1 = TlsGetValue(*(_DWORD *)i);
    if ( !GetLastError() && v1 )
      (*(void (__cdecl **)(LPVOID))(i + 4))(v1);
  }
  LeaveCriticalSection(&__mingwthr_cs);
}
// 55B940: using guessed type int key_dtor_list;

//----- (0040DCD0) --------------------------------------------------------
signed int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v4; // eax@3
  int v5; // ebx@3
  int v6; // eax@4

  v2 = 0;
  if ( !__mingwthr_cs_init )
    return v2;
  v4 = calloc(1u, 0xCu);
  v5 = (int)v4;
  if ( !v4 )
    return -1;
  *v4 = a1;
  v4[1] = a2;
  EnterCriticalSection(&__mingwthr_cs);
  v6 = key_dtor_list;
  key_dtor_list = v5;
  *(_DWORD *)(v5 + 8) = v6;
  LeaveCriticalSection(&__mingwthr_cs);
  return 0;
}
// 55B924: using guessed type int __mingwthr_cs_init;
// 55B940: using guessed type int key_dtor_list;

//----- (0040DD60) --------------------------------------------------------
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1)
{
  int v2; // edx@3
  int v3; // eax@5

  if ( !__mingwthr_cs_init )
    return 0;
  EnterCriticalSection(&__mingwthr_cs);
  v2 = key_dtor_list;
  if ( key_dtor_list )
  {
    if ( *(_DWORD *)key_dtor_list == a1 )
    {
      key_dtor_list = *(_DWORD *)(key_dtor_list + 8);
      v3 = v2;
LABEL_12:
      free((void *)v3);
      LeaveCriticalSection(&__mingwthr_cs);
      return 0;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(v2 + 8);
      if ( !v3 )
        break;
      if ( *(_DWORD *)v3 == a1 )
      {
        *(_DWORD *)(v2 + 8) = *(_DWORD *)(v3 + 8);
        goto LABEL_12;
      }
      v2 = *(_DWORD *)(v2 + 8);
    }
  }
  LeaveCriticalSection(&__mingwthr_cs);
  return 0;
}
// 55B924: using guessed type int __mingwthr_cs_init;
// 55B940: using guessed type int key_dtor_list;

//----- (0040DDF0) --------------------------------------------------------
signed int __cdecl __mingw_TLScallback(int a1, unsigned int a2)
{
  signed int result; // eax@4

  if ( a2 == 1 )
  {
    if ( !__mingwthr_cs_init )
      InitializeCriticalSection(&__mingwthr_cs);
    __mingwthr_cs_init = 1;
    result = 1;
  }
  else
  {
    if ( a2 < 1 )
    {
      if ( __mingwthr_cs_init )
        __mingwthr_run_key_dtors_part_0();
      if ( __mingwthr_cs_init == 1 )
      {
        __mingwthr_cs_init = 0;
        DeleteCriticalSection(&__mingwthr_cs);
      }
    }
    else if ( a2 == 3 )
    {
      if ( __mingwthr_cs_init )
        __mingwthr_run_key_dtors_part_0();
    }
    result = 1;
  }
  return result;
}
// 55B924: using guessed type int __mingwthr_cs_init;

//----- (0040DE90) --------------------------------------------------------
void init_dwarf_reg_size_table()
{
  dwarf_reg_size_table[0] = 4;
  byte_55B94A = 4;
  byte_55B949 = 4;
  byte_55B94B = 4;
  byte_55B94E = 4;
  byte_55B94F = 4;
  byte_55B94D = 4;
  byte_55B94C = 4;
  byte_55B953 = 12;
  byte_55B954 = 12;
  byte_55B955 = 12;
  byte_55B956 = 12;
  byte_55B957 = 12;
  byte_55B958 = 12;
  byte_55B951 = 4;
  byte_55B950 = 4;
}
// 55B949: using guessed type char byte_55B949;
// 55B94A: using guessed type char byte_55B94A;
// 55B94B: using guessed type char byte_55B94B;
// 55B94C: using guessed type char byte_55B94C;
// 55B94D: using guessed type char byte_55B94D;
// 55B94E: using guessed type char byte_55B94E;
// 55B94F: using guessed type char byte_55B94F;
// 55B950: using guessed type char byte_55B950;
// 55B951: using guessed type char byte_55B951;
// 55B953: using guessed type char byte_55B953;
// 55B954: using guessed type char byte_55B954;
// 55B955: using guessed type char byte_55B955;
// 55B956: using guessed type char byte_55B956;
// 55B957: using guessed type char byte_55B957;
// 55B958: using guessed type char byte_55B958;

//----- (0040DF04) --------------------------------------------------------
int __usercall uw_install_context_1@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // eax@3
  const void *v5; // esi@3
  void *v6; // eax@8
  const void *v7; // esi@8
  void *v8; // eax@13
  const void *v9; // esi@13
  void *v10; // eax@18
  const void *v11; // esi@18
  void *v12; // eax@23
  const void *v13; // esi@23
  void *v14; // eax@28
  const void *v15; // esi@28
  void *v16; // eax@33
  const void *v17; // esi@33
  void *v18; // eax@38
  const void *v19; // esi@38
  void *v20; // eax@43
  const void *v21; // esi@43
  void *v22; // eax@48
  const void *v23; // esi@48
  void *v24; // eax@53
  const void *v25; // esi@53
  void *v26; // eax@58
  const void *v27; // esi@58
  void *v28; // eax@63
  const void *v29; // esi@63
  void *v30; // eax@68
  const void *v31; // esi@68
  void *v32; // eax@73
  const void *v33; // esi@73
  void *v34; // eax@78
  const void *v35; // esi@78
  void *v36; // eax@83
  const void *v37; // esi@83
  int v39; // eax@168
  int v40; // [sp+Ch] [bp-10h]@94

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 96);
  if ( (!(v3 & 0x40000000) || !*(_BYTE *)(a2 + 112)) && !*(_DWORD *)(a2 + 16) )
  {
    if ( byte_55B94C != 4 )
      goto LABEL_87;
    v40 = *(_DWORD *)(a2 + 72);
    if ( v3 & 0x40000000 )
      *(_BYTE *)(a2 + 112) = 0;
    *(_DWORD *)(a2 + 16) = &v40;
  }
  v4 = *(void **)v2;
  v5 = *(const void **)a2;
  if ( *(_BYTE *)(v2 + 108) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 108) )
  {
    if ( v4 )
    {
      if ( dwarf_reg_size_table[0] != 4 )
        goto LABEL_87;
      *(_DWORD *)v4 = v5;
    }
  }
  else if ( v5 && v4 && v5 != v4 )
  {
    qmemcpy(v4, v5, (unsigned __int8)dwarf_reg_size_table[0]);
  }
  v6 = *(void **)(v2 + 4);
  v7 = *(const void **)(a2 + 4);
  if ( *(_BYTE *)(v2 + 109) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 109) )
  {
    if ( v6 )
    {
      if ( byte_55B949 != 4 )
        goto LABEL_87;
      *(_DWORD *)v6 = v7;
    }
  }
  else if ( v7 && v6 && v7 != v6 )
  {
    qmemcpy(v6, v7, (unsigned __int8)byte_55B949);
  }
  v8 = *(void **)(v2 + 8);
  v9 = *(const void **)(a2 + 8);
  if ( *(_BYTE *)(v2 + 110) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 110) )
  {
    if ( v8 )
    {
      if ( byte_55B94A != 4 )
        goto LABEL_87;
      *(_DWORD *)v8 = v9;
    }
  }
  else if ( v9 && v8 && v9 != v8 )
  {
    qmemcpy(v8, v9, (unsigned __int8)byte_55B94A);
  }
  v10 = *(void **)(v2 + 12);
  v11 = *(const void **)(a2 + 12);
  if ( *(_BYTE *)(v2 + 111) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 111) )
  {
    if ( v10 )
    {
      if ( byte_55B94B != 4 )
        goto LABEL_87;
      *(_DWORD *)v10 = v11;
    }
  }
  else if ( v11 && v10 && v11 != v10 )
  {
    qmemcpy(v10, v11, (unsigned __int8)byte_55B94B);
  }
  v12 = *(void **)(v2 + 16);
  v13 = *(const void **)(a2 + 16);
  if ( *(_BYTE *)(v2 + 112) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 112) )
  {
    if ( v12 )
    {
      if ( byte_55B94C != 4 )
        goto LABEL_87;
      *(_DWORD *)v12 = v13;
    }
  }
  else if ( v13 && v12 && v13 != v12 )
  {
    qmemcpy(v12, v13, (unsigned __int8)byte_55B94C);
  }
  v14 = *(void **)(v2 + 20);
  v15 = *(const void **)(a2 + 20);
  if ( *(_BYTE *)(v2 + 113) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 113) )
  {
    if ( v14 )
    {
      if ( byte_55B94D != 4 )
        goto LABEL_87;
      *(_DWORD *)v14 = v15;
    }
  }
  else if ( v15 && v14 && v15 != v14 )
  {
    qmemcpy(v14, v15, (unsigned __int8)byte_55B94D);
  }
  v16 = *(void **)(v2 + 24);
  v17 = *(const void **)(a2 + 24);
  if ( *(_BYTE *)(v2 + 114) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 114) )
  {
    if ( v16 )
    {
      if ( byte_55B94E != 4 )
        goto LABEL_87;
      *(_DWORD *)v16 = v17;
    }
  }
  else if ( v17 && v16 && v17 != v16 )
  {
    qmemcpy(v16, v17, (unsigned __int8)byte_55B94E);
  }
  v18 = *(void **)(v2 + 28);
  v19 = *(const void **)(a2 + 28);
  if ( *(_BYTE *)(v2 + 115) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 115) )
  {
    if ( v18 )
    {
      if ( byte_55B94F != 4 )
        goto LABEL_87;
      *(_DWORD *)v18 = v19;
    }
  }
  else if ( v19 && v18 && v19 != v18 )
  {
    qmemcpy(v18, v19, (unsigned __int8)byte_55B94F);
  }
  v20 = *(void **)(v2 + 32);
  v21 = *(const void **)(a2 + 32);
  if ( *(_BYTE *)(v2 + 116) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 116) )
  {
    if ( v20 )
    {
      if ( byte_55B950 != 4 )
        goto LABEL_87;
      *(_DWORD *)v20 = v21;
    }
  }
  else if ( v21 && v20 && v21 != v20 )
  {
    qmemcpy(v20, v21, (unsigned __int8)byte_55B950);
  }
  v22 = *(void **)(v2 + 36);
  v23 = *(const void **)(a2 + 36);
  if ( *(_BYTE *)(v2 + 117) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 117) )
  {
    if ( v22 )
    {
      if ( byte_55B951 != 4 )
        goto LABEL_87;
      *(_DWORD *)v22 = v23;
    }
  }
  else if ( v23 && v22 && v23 != v22 )
  {
    qmemcpy(v22, v23, (unsigned __int8)byte_55B951);
  }
  v24 = *(void **)(v2 + 40);
  v25 = *(const void **)(a2 + 40);
  if ( *(_BYTE *)(v2 + 118) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 118) )
  {
    if ( v24 )
    {
      if ( byte_55B952 != 4 )
        goto LABEL_87;
      *(_DWORD *)v24 = v25;
    }
  }
  else if ( v25 && v24 && v25 != v24 )
  {
    qmemcpy(v24, v25, (unsigned __int8)byte_55B952);
  }
  v26 = *(void **)(v2 + 44);
  v27 = *(const void **)(a2 + 44);
  if ( *(_BYTE *)(v2 + 119) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 119) )
  {
    if ( v26 )
    {
      if ( byte_55B953 != 4 )
        goto LABEL_87;
      *(_DWORD *)v26 = v27;
    }
  }
  else if ( v27 && v26 && v27 != v26 )
  {
    qmemcpy(v26, v27, (unsigned __int8)byte_55B953);
  }
  v28 = *(void **)(v2 + 48);
  v29 = *(const void **)(a2 + 48);
  if ( *(_BYTE *)(v2 + 120) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 120) )
  {
    if ( v28 )
    {
      if ( byte_55B954 != 4 )
        goto LABEL_87;
      *(_DWORD *)v28 = v29;
    }
  }
  else if ( v29 && v28 && v29 != v28 )
  {
    qmemcpy(v28, v29, (unsigned __int8)byte_55B954);
  }
  v30 = *(void **)(v2 + 52);
  v31 = *(const void **)(a2 + 52);
  if ( *(_BYTE *)(v2 + 121) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 121) )
  {
    if ( v30 )
    {
      if ( byte_55B955 != 4 )
        goto LABEL_87;
      *(_DWORD *)v30 = v31;
    }
  }
  else if ( v31 && v30 && v31 != v30 )
  {
    qmemcpy(v30, v31, (unsigned __int8)byte_55B955);
  }
  v32 = *(void **)(v2 + 56);
  v33 = *(const void **)(a2 + 56);
  if ( *(_BYTE *)(v2 + 122) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 122) )
  {
    if ( v32 )
    {
      if ( byte_55B956 != 4 )
        goto LABEL_87;
      *(_DWORD *)v32 = v33;
    }
  }
  else if ( v33 && v32 && v33 != v32 )
  {
    qmemcpy(v32, v33, (unsigned __int8)byte_55B956);
  }
  v34 = *(void **)(v2 + 60);
  v35 = *(const void **)(a2 + 60);
  if ( *(_BYTE *)(v2 + 123) )
    goto LABEL_87;
  if ( *(_BYTE *)(a2 + 123) )
  {
    if ( v34 )
    {
      if ( byte_55B957 != 4 )
        goto LABEL_87;
      *(_DWORD *)v34 = v35;
    }
  }
  else if ( v35 && v34 && v35 != v34 )
  {
    qmemcpy(v34, v35, (unsigned __int8)byte_55B957);
  }
  v36 = *(void **)(v2 + 64);
  v37 = *(const void **)(a2 + 64);
  if ( *(_BYTE *)(v2 + 124) )
LABEL_87:
    abort();
  if ( *(_BYTE *)(a2 + 124) )
  {
    if ( v36 )
    {
      if ( byte_55B958 != 4 )
        goto LABEL_87;
      *(_DWORD *)v36 = v37;
      if ( !(*(_BYTE *)(v2 + 99) & 0x40) )
        goto LABEL_164;
      goto LABEL_162;
    }
  }
  else if ( v37 && v36 && v37 != v36 )
  {
    qmemcpy(v36, v37, (unsigned __int8)byte_55B958);
  }
  if ( !(*(_BYTE *)(v2 + 99) & 0x40) )
    goto LABEL_164;
LABEL_162:
  if ( *(_BYTE *)(v2 + 112) )
    return 0;
LABEL_164:
  if ( *(_DWORD *)(v2 + 16) )
    return 0;
  if ( *(_BYTE *)(a2 + 99) & 0x40 && *(_BYTE *)(a2 + 112) )
  {
    v39 = *(_DWORD *)(a2 + 16);
    return *(_DWORD *)(a2 + 104) + v39 - *(_DWORD *)(v2 + 72);
  }
  if ( byte_55B94C != 4 )
    goto LABEL_87;
  v39 = **(_DWORD **)(a2 + 16);
  return *(_DWORD *)(a2 + 104) + v39 - *(_DWORD *)(v2 + 72);
}
// 55B949: using guessed type char byte_55B949;
// 55B94A: using guessed type char byte_55B94A;
// 55B94B: using guessed type char byte_55B94B;
// 55B94C: using guessed type char byte_55B94C;
// 55B94D: using guessed type char byte_55B94D;
// 55B94E: using guessed type char byte_55B94E;
// 55B94F: using guessed type char byte_55B94F;
// 55B950: using guessed type char byte_55B950;
// 55B951: using guessed type char byte_55B951;
// 55B952: using guessed type char byte_55B952;
// 55B953: using guessed type char byte_55B953;
// 55B954: using guessed type char byte_55B954;
// 55B955: using guessed type char byte_55B955;
// 55B956: using guessed type char byte_55B956;
// 55B957: using guessed type char byte_55B957;
// 55B958: using guessed type char byte_55B958;

//----- (0040E56C) --------------------------------------------------------
char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, _DWORD **a2@<edx>, _DWORD **a3@<ecx>, char **a4)
{
  _DWORD **v4; // ebp@1
  unsigned __int8 v5; // al@2
  char *v6; // ebx@5
  char *result; // eax@5
  unsigned int v8; // ecx@13
  _DWORD **v9; // edi@13
  char v10; // dl@14
  _DWORD **v11; // esi@15
  char v12; // di@15
  char *v13; // edi@18
  int v14; // ecx@18
  _DWORD **v15; // esi@18
  char v16; // dl@19
  _DWORD *v17; // eax@23
  char *v18; // ebx@23
  char v19; // [sp+Fh] [bp-1Dh]@1

  v4 = a3;
  v19 = a1;
  if ( a1 == 80 )
  {
    v17 = (_DWORD *)(((unsigned int)a3 + 3) & 0xFFFFFFFC);
    v18 = (char *)*v17;
    result = (char *)(v17 + 1);
    *a4 = v18;
  }
  else
  {
    v5 = a1 & 0xF;
    if ( v5 > 0xCu )
LABEL_3:
      abort();
    switch ( v5 )
    {
      default:
        goto LABEL_3;
      case 0u:
      case 3u:
      case 0xBu:
        v6 = (char *)*a3;
        result = (char *)(a3 + 1);
        break;
      case 4u:
      case 0xCu:
        v6 = (char *)*a3;
        result = (char *)(a3 + 2);
        break;
      case 9u:
        result = (char *)a3;
        v6 = 0;
        v8 = 0;
        v9 = a2;
        do
        {
          v10 = *result++;
          v6 = (char *)(((v10 & 0x7F) << v8) | (unsigned int)v6);
          v8 += 7;
        }
        while ( v10 < 0 );
        v11 = v9;
        v12 = v10;
        a2 = v11;
        if ( v8 <= 0x1F && v12 & 0x40 )
          v6 = (char *)((-1 << v8) | (unsigned int)v6);
        break;
      case 1u:
        result = (char *)a3;
        v13 = 0;
        v14 = 0;
        v15 = a2;
        do
        {
          v16 = *result++;
          v13 = (char *)(((v16 & 0x7F) << v14) | (unsigned int)v13);
          v14 += 7;
        }
        while ( v16 < 0 );
        a2 = v15;
        v6 = v13;
        break;
      case 0xAu:
        v6 = (char *)*(_WORD *)a3;
        result = (char *)a3 + 2;
        break;
      case 2u:
        v6 = (char *)*(_WORD *)a3;
        result = (char *)a3 + 2;
        break;
    }
    if ( v6 )
    {
      if ( (v19 & 0x70) == 16 )
        a2 = v4;
      v6 = &v6[(_DWORD)a2];
      if ( v19 < 0 )
        v6 = *(char **)v6;
    }
    *a4 = v6;
  }
  return result;
}

//----- (0040E670) --------------------------------------------------------
int __usercall execute_stack_op@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4)
{
  char *v4; // ebx@1
  int result; // eax@1
  signed int v6; // edi@2
  char v7; // dl@3
  int v8; // ebp@3
  char *v9; // esi@3
  int v10; // ebp@6
  char v11; // dl@25
  char v12; // al@25
  unsigned __int8 v13; // dl@26
  _DWORD **v14; // edx@31
  signed int v15; // ebx@32
  int v16; // ecx@32
  char v17; // dl@33
  signed int v18; // ebp@41
  int v19; // ecx@41
  char v20; // dl@42
  int v21; // esi@43
  unsigned int v22; // ecx@43
  char v23; // dl@44
  char *v24; // edx@49
  unsigned int v25; // ecx@54
  char v26; // dl@55
  int v27; // ecx@59
  char v28; // dl@60
  int v29; // eax@62
  int v30; // ebx@70
  unsigned int v31; // ecx@70
  char v32; // dl@71
  int v33; // ebp@75
  char *v34; // edx@76
  int v35; // eax@81
  int v36; // eax@87
  int v37; // eax@90
  signed int v38; // ecx@90
  int v39; // ST14_4@92
  int v40; // ebp@92
  int v41; // ecx@94
  char v42; // al@108
  int v43; // ebx@113
  int v44; // ecx@113
  char v45; // dl@114
  unsigned int v46; // [sp+18h] [bp-134h]@1
  int v47; // [sp+1Ch] [bp-130h]@1
  int v48; // [sp+28h] [bp-124h]@65
  int v49; // [sp+2Ch] [bp-120h]@11
  int v50[71]; // [sp+30h] [bp-11Ch]@1

  v4 = a1;
  v46 = a2;
  v47 = a3;
  result = a4;
  v50[0] = a4;
  if ( (unsigned int)v4 < a2 )
  {
    v6 = 1;
    while ( 2 )
    {
      v7 = *v4;
      v8 = (unsigned __int8)*v4;
      v9 = v4 + 1;
      if ( (unsigned __int8)(*v4 - 3) > 0xEEu )
LABEL_4:
        abort();
      switch ( *v4 )
      {
        default:
          goto LABEL_4;
        case 3:
        case 12:
        case 13:
          v10 = *(_DWORD *)(v4 + 1);
          v4 += 5;
          goto LABEL_7;
        case 14:
        case 15:
          v10 = *(_DWORD *)(v4 + 1);
          v4 += 9;
          goto LABEL_7;
        case 11:
          v10 = *(_WORD *)(v4 + 1);
          v4 += 3;
          goto LABEL_7;
        case 10:
          v10 = *(_WORD *)(v4 + 1);
          v4 += 3;
          goto LABEL_7;
        case 9:
          v10 = v4[1];
          v4 += 2;
          goto LABEL_7;
        case 8:
          v10 = (unsigned __int8)v4[1];
          v4 += 2;
          goto LABEL_7;
        case 6:
        case 25:
        case 31:
        case 32:
        case 35:
        case -108:
          if ( !v6 )
            goto LABEL_4;
          v10 = v50[--v6];
          if ( v7 == 31 )
            goto LABEL_100;
          if ( (unsigned __int8)v7 <= 0x1Fu )
          {
            if ( v7 == 6 )
            {
              v10 = *(_DWORD *)v10;
              ++v4;
            }
            else
            {
              if ( v7 != 25 )
                goto LABEL_4;
              if ( v10 >= 0 )
              {
LABEL_39:
                v4 = v9;
              }
              else
              {
LABEL_100:
                v10 = -v10;
                ++v4;
              }
            }
          }
          else if ( v7 == 35 )
          {
            v43 = 0;
            v44 = 0;
            do
            {
              v45 = *v9++;
              v43 |= (v45 & 0x7F) << v44;
              v44 += 7;
            }
            while ( v45 < 0 );
            v10 += v43;
            v4 = v9;
          }
          else if ( v7 == -108 )
          {
            v42 = v4[1];
            v4 += 2;
            if ( v42 == 2 )
            {
              v10 = *(_WORD *)v10;
            }
            else if ( (unsigned __int8)v42 <= 2u )
            {
              if ( v42 != 1 )
                goto LABEL_4;
              v10 = *(_BYTE *)v10;
            }
            else
            {
              if ( v42 != 4 && v42 != 8 )
                goto LABEL_4;
              v10 = *(_DWORD *)v10;
            }
          }
          else
          {
            if ( v7 != 32 )
              goto LABEL_4;
            v10 = ~v10;
            ++v4;
          }
          goto LABEL_7;
        case -15:
          v11 = v4[1];
          v12 = v11;
          if ( v11 == -1 )
            goto LABEL_103;
          v13 = v11 & 0x70;
          if ( v13 == 32 )
          {
            v14 = *(_DWORD ***)(v47 + 84);
          }
          else
          {
            if ( v13 <= 0x20u )
            {
              if ( v13 && v13 != 16 )
                goto LABEL_4;
LABEL_103:
              v14 = 0;
              goto LABEL_104;
            }
            if ( v13 == 64 )
            {
              v14 = *(_DWORD ***)(v47 + 92);
            }
            else
            {
              if ( v13 == 80 )
                goto LABEL_103;
              if ( v13 != 48 )
                goto LABEL_4;
              v14 = *(_DWORD ***)(v47 + 88);
            }
          }
LABEL_104:
          v4 = read_encoded_value_with_base(v12, v14, (_DWORD **)(v4 + 2), (char **)&v49);
          v10 = v49;
LABEL_7:
          if ( (unsigned int)v6 > 0x3F )
            goto LABEL_4;
          v50[v6++] = v10;
LABEL_9:
          if ( v46 > (unsigned int)v4 )
            continue;
          if ( !v6 )
            goto LABEL_4;
          result = *(&v49 + v6);
          break;
        case -112:
          v15 = 0;
          v16 = 0;
          do
          {
            v17 = *v9++;
            v15 |= (v17 & 0x7F) << v16;
            v16 += 7;
          }
          while ( v17 < 0 );
          if ( v15 > 17 )
            goto LABEL_4;
          v10 = *(_DWORD *)(v47 + 4 * v15);
          if ( *(_BYTE *)(v47 + 99) & 0x40 && *(_BYTE *)(v47 + v15 + 108) )
            goto LABEL_39;
          if ( dwarf_reg_size_table[v15] == 4 )
            goto LABEL_38;
          goto LABEL_4;
        case -106:
          ++v4;
          goto LABEL_9;
        case -110:
          v18 = 0;
          v19 = 0;
          do
          {
            v20 = *v9++;
            v18 |= (v20 & 0x7F) << v19;
            v19 += 7;
          }
          while ( v20 < 0 );
          v4 = v9;
          v21 = 0;
          v22 = 0;
          do
          {
            v23 = *v4++;
            v21 |= (v23 & 0x7F) << v22;
            v22 += 7;
          }
          while ( v23 < 0 );
          if ( v22 <= 0x1F && v23 & 0x40 )
            v21 |= -(1 << v22);
          if ( v18 > 17 )
            goto LABEL_4;
          v24 = *(char **)(v47 + 4 * v18);
          if ( *(_BYTE *)(v47 + 99) & 0x40 && *(_BYTE *)(v47 + v18 + 108) )
            goto LABEL_53;
          if ( dwarf_reg_size_table[v18] != 4 )
            goto LABEL_4;
          v24 = *(char **)v24;
LABEL_53:
          v10 = (int)&v24[v21];
          goto LABEL_7;
        case 17:
          v10 = 0;
          v25 = 0;
          do
          {
            v26 = *v9++;
            v10 |= (v26 & 0x7F) << v25;
            v25 += 7;
          }
          while ( v26 < 0 );
          if ( v25 > 0x1F || !(v26 & 0x40) )
            goto LABEL_39;
          v10 |= -(1 << v25);
          v4 = v9;
          goto LABEL_7;
        case 16:
          ++v4;
          v10 = 0;
          v27 = 0;
          do
          {
            v28 = *v4++;
            v10 |= (v28 & 0x7F) << v27;
            v27 += 7;
          }
          while ( v28 < 0 );
          goto LABEL_7;
        case 21:
          v29 = (unsigned __int8)v4[1];
          v4 += 2;
          if ( v29 >= v6 - 1 )
            goto LABEL_4;
          v10 = v50[v6 - 1 - v29];
          goto LABEL_7;
        case 20:
          if ( v6 <= 1 )
            goto LABEL_4;
          v10 = *(&v48 + v6);
          ++v4;
          goto LABEL_7;
        case 19:
          if ( !v6 )
            goto LABEL_4;
          --v6;
          ++v4;
          goto LABEL_9;
        case 18:
          if ( !v6 )
            goto LABEL_4;
          v10 = *(&v49 + v6);
          ++v4;
          goto LABEL_7;
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case -128:
        case -127:
        case -126:
        case -125:
        case -124:
        case -123:
        case -122:
        case -121:
        case -120:
        case -119:
        case -118:
        case -117:
        case -116:
        case -115:
        case -114:
        case -113:
          v30 = 0;
          v31 = 0;
          do
          {
            v32 = *v9++;
            v30 |= (v32 & 0x7F) << v31;
            v31 += 7;
          }
          while ( v32 < 0 );
          if ( v31 <= 0x1F && v32 & 0x40 )
            v30 |= -(1 << v31);
          v33 = v8 - 112;
          if ( v33 > 17 )
            goto LABEL_4;
          v34 = *(char **)(v47 + 4 * v33);
          if ( *(_BYTE *)(v47 + 99) & 0x40 && *(_BYTE *)(v47 + v33 + 108) )
            goto LABEL_80;
          if ( dwarf_reg_size_table[v33] != 4 )
            goto LABEL_4;
          v34 = *(char **)v34;
LABEL_80:
          v10 = (int)&v34[v30];
          v4 = v9;
          goto LABEL_7;
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
          v35 = v8 - 80;
          if ( v8 - 80 > 17 )
            goto LABEL_4;
          v10 = *(_DWORD *)(v47 + 4 * v35);
          if ( *(_BYTE *)(v47 + 99) & 0x40 && *(_BYTE *)(v47 + v35 + 108) )
            goto LABEL_39;
          if ( dwarf_reg_size_table[v35] != 4 )
            goto LABEL_4;
LABEL_38:
          v10 = *(_DWORD *)v10;
          goto LABEL_39;
        case 40:
          if ( !v6 )
            goto LABEL_4;
          --v6;
          v36 = *(_WORD *)(v4 + 1);
          v4 += 3;
          if ( v50[v6] )
            v4 += v36;
          goto LABEL_9;
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 33:
        case 34:
        case 36:
        case 37:
        case 38:
        case 39:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
          if ( v6 <= 1 )
            goto LABEL_4;
          v37 = v50[v6 - 2];
          v38 = *(&v49 + v6);
          switch ( v7 )
          {
            default:
              goto LABEL_4;
            case 33:
              v10 = v37 | v38;
              v6 -= 2;
              ++v4;
              break;
            case 34:
              v10 = v38 + v37;
              v6 -= 2;
              ++v4;
              break;
            case 36:
              v10 = v37 << v38;
              v6 -= 2;
              ++v4;
              break;
            case 37:
              v10 = (unsigned int)v37 >> v38;
              v6 -= 2;
              ++v4;
              break;
            case 38:
              v10 = v37 >> v38;
              v6 -= 2;
              ++v4;
              break;
            case 39:
              v10 = v37 ^ v38;
              v6 -= 2;
              ++v4;
              break;
            case 41:
              v10 = v37 == v38;
              v6 -= 2;
              ++v4;
              break;
            case 42:
              v10 = v37 >= v38;
              v6 -= 2;
              ++v4;
              break;
            case 43:
              v10 = v37 > v38;
              v6 -= 2;
              ++v4;
              break;
            case 44:
              v10 = v37 <= v38;
              v6 -= 2;
              ++v4;
              break;
            case 45:
              v10 = v37 < v38;
              v6 -= 2;
              ++v4;
              break;
            case 46:
              v10 = v37 != v38;
              v6 -= 2;
              ++v4;
              break;
            case 27:
              v10 = v37 / v38;
              v6 -= 2;
              ++v4;
              break;
            case 28:
              v10 = v37 - v38;
              v6 -= 2;
              ++v4;
              break;
            case 29:
              v10 = v37 % (unsigned int)v38;
              v6 -= 2;
              ++v4;
              break;
            case 30:
              v10 = v37 * v38;
              v6 -= 2;
              ++v4;
              break;
            case 26:
              v10 = v37 & v38;
              v6 -= 2;
              ++v4;
              break;
          }
          goto LABEL_7;
        case 23:
          if ( v6 <= 2 )
            goto LABEL_4;
          v39 = v50[v6 - 1];
          v40 = v50[v6 - 3];
          v50[v6 - 1] = v50[v6 - 2];
          v50[v6 - 2] = v40;
          v50[v6 - 3] = v39;
          ++v4;
          goto LABEL_9;
        case 22:
          if ( v6 <= 1 )
            goto LABEL_4;
          v41 = v50[v6 - 1];
          v50[v6 - 1] = v50[v6 - 2];
          v50[v6 - 2] = v41;
          ++v4;
          goto LABEL_9;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
          v10 = v8 - 48;
          ++v4;
          goto LABEL_7;
        case 47:
          v4 += *(_WORD *)(v4 + 1) + 3;
          goto LABEL_9;
      }
      break;
    }
  }
  return result;
}
// 40E670: using guessed type int var_11C[71];

//----- (0040EC78) --------------------------------------------------------
unsigned int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // edx@1
  int v3; // eax@5
  char *v4; // eax@13
  int v5; // esi@13
  int v6; // ecx@13
  char v7; // bl@14
  int v8; // eax@15
  int v9; // esi@15
  _DWORD *v10; // esi@16
  int v11; // edi@16
  _DWORD *v12; // eax@18
  unsigned int result; // eax@23
  int v14; // eax@24
  char *v15; // eax@27
  int v16; // ebp@27
  int v17; // ecx@27
  char v18; // bl@28
  signed int v19; // eax@31
  char *v20; // eax@34
  int v21; // ebp@34
  int v22; // ecx@34
  char v23; // bl@35
  char v24; // dl@40
  signed int v25; // eax@43
  char *v26; // ebx@44
  int *v27; // [sp+1Ch] [bp-C0h]@16
  _BYTE *v28; // [sp+20h] [bp-BCh]@16
  int v29; // [sp+24h] [bp-B8h]@1
  int v30; // [sp+28h] [bp-B4h]@15
  int v31; // [sp+2Ch] [bp-B0h]@1
  int v32; // [sp+3Ch] [bp-A0h]@10
  int v33[4]; // [sp+40h] [bp-9Ch]@1
  int *v34; // [sp+50h] [bp-8Ch]@8
  int v35; // [sp+A0h] [bp-3Ch]@1
  char v36[4]; // [sp+ACh] [bp-30h]@31
  char v37; // [sp+B0h] [bp-2Ch]@2

  v29 = a1;
  v31 = a2;
  qmemcpy(v33, (const void *)a1, 0x80u);
  v2 = v35;
  if ( (!(v35 & 0x40000000) || !v37) && !v34 )
  {
    if ( byte_55B94C != 4 )
      goto LABEL_7;
    v32 = *(_DWORD *)(a1 + 72);
    if ( v35 & 0x40000000 )
      v37 = 0;
    v34 = &v32;
  }
  if ( *(_BYTE *)(a1 + 99) & 0x40 )
    *(_BYTE *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v3 = *(_DWORD *)(v31 + 160);
  if ( v3 == 1 )
  {
    v25 = *(_DWORD *)(v31 + 152);
    if ( v25 <= 17 )
    {
      v26 = (char *)v33[v25];
      if ( v2 & 0x40000000 && v36[v25] )
        goto LABEL_46;
      if ( dwarf_reg_size_table[v25] == 4 )
      {
        v26 = *(char **)v26;
LABEL_46:
        v30 = (int)&v26[*(_DWORD *)(v31 + 148)];
        v8 = (int)&v26[*(_DWORD *)(v31 + 148)];
        v9 = v31;
        goto LABEL_16;
      }
    }
LABEL_7:
    abort();
  }
  if ( v3 != 2 )
    goto LABEL_7;
  v4 = *(char **)(v31 + 156);
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = *v4++;
    v5 |= (v7 & 0x7F) << v6;
    v6 += 7;
  }
  while ( v7 < 0 );
  v8 = execute_stack_op(v4, (unsigned int)&v4[v5], (int)v33, 0);
  v30 = v8;
  v9 = v31;
LABEL_16:
  *(_DWORD *)(v29 + 72) = v8;
  v10 = (_DWORD *)(v9 + 4);
  v28 = (_BYTE *)(v29 + 108);
  v27 = (int *)v29;
  v11 = 0;
  while ( 2 )
  {
    switch ( *v10 )
    {
      case 1:
        v12 = (_DWORD *)(*(v10 - 1) + v30);
        if ( *(_BYTE *)(v29 + 99) & 0x40 )
          *v28 = 0;
        goto LABEL_20;
      default:
        goto LABEL_21;
      case 4:
        v14 = *(v10 - 1) + v30;
        if ( dwarf_reg_size_table[v11] != 4 )
          goto LABEL_7;
        *v28 = 1;
        goto LABEL_26;
      case 3:
        v15 = (char *)*(v10 - 1);
        v16 = 0;
        v17 = 0;
        do
        {
          v18 = *v15++;
          v16 |= (v18 & 0x7F) << v17;
          v17 += 7;
        }
        while ( v18 < 0 );
        v14 = execute_stack_op(v15, (unsigned int)&v15[v16], (int)v33, v30);
        if ( *(_BYTE *)(v29 + 99) & 0x40 )
          goto LABEL_30;
        goto LABEL_26;
      case 2:
        v19 = *(v10 - 1);
        if ( v36[v19] )
        {
          if ( v19 > 17 )
            goto LABEL_7;
          v24 = dwarf_reg_size_table[v19];
          v12 = (_DWORD *)v33[v19];
          if ( !(BYTE3(v35) & 0x40) )
          {
            if ( v24 != 4 )
              goto LABEL_7;
            v12 = (_DWORD *)*v12;
          }
LABEL_37:
          if ( dwarf_reg_size_table[v11] != 4 )
            goto LABEL_7;
          *v28 = 1;
LABEL_20:
          *v27 = (int)v12;
        }
        else
        {
          v14 = v33[v19];
          if ( *(_BYTE *)(v29 + 99) & 0x40 )
LABEL_30:
            *v28 = 0;
LABEL_26:
          *v27 = v14;
        }
LABEL_21:
        ++v11;
        v10 += 2;
        ++v28;
        ++v27;
        if ( v11 != 18 )
          continue;
        if ( *(_BYTE *)(v31 + 187) )
        {
          result = *(_DWORD *)(v29 + 96) | 0x80000000;
          *(_DWORD *)(v29 + 96) = result;
        }
        else
        {
          result = *(_DWORD *)(v29 + 96) & 0x7FFFFFFF;
          *(_DWORD *)(v29 + 96) = result;
        }
        return result;
      case 5:
        v20 = (char *)*(v10 - 1);
        v21 = 0;
        v22 = 0;
        do
        {
          v23 = *v20++;
          v21 |= (v23 & 0x7F) << v22;
          v22 += 7;
        }
        while ( v23 < 0 );
        v12 = (_DWORD *)execute_stack_op(v20, (unsigned int)&v20[v21], (int)v33, v30);
        goto LABEL_37;
    }
  }
}
// 55B94C: using guessed type char byte_55B94C;
// 40EC78: using guessed type int var_9C[4];
// 40EC78: using guessed type char var_30[4];

//----- (0040EF60) --------------------------------------------------------
#error "41E0F0: positive sp value has been found (funcsize=723)"

//----- (0040F7E4) --------------------------------------------------------
char __usercall uw_frame_state_for@<al>(int a1@<eax>, void *a2@<edx>)
{
  int v2; // ebp@1
  void *v3; // esi@1
  int v4; // eax@1
  int v5; // eax@2
  unsigned int v6; // ecx@3
  char *v7; // ebx@3
  int v8; // edi@5
  int v9; // ecx@5
  char v10; // dl@6
  int v11; // edi@7
  unsigned int v12; // ecx@7
  char v13; // dl@8
  int v14; // edi@13
  int v15; // ecx@13
  char v16; // dl@14
  int v17; // edi@18
  char *v18; // eax@18
  char i; // dl@18
  char v20; // al@26
  unsigned __int8 v21; // al@27
  signed int v22; // ebx@30
  char result; // al@31
  _DWORD **v24; // ecx@35
  char v25; // al@35
  char v26; // bl@35
  unsigned __int8 v27; // al@36
  _DWORD **v28; // edx@44
  int v29; // ecx@46
  int v30; // edx@46
  char v31; // al@47
  int v32; // edi@63
  int v33; // ecx@63
  char v34; // dl@64
  char *v35; // ebx@72
  int v36; // edi@72
  int v37; // ecx@73
  char v38; // dl@74
  char v39; // dl@75
  unsigned __int8 v40; // dl@76
  _DWORD **v41; // edx@80
  int v42; // eax@87
  int v43; // edx@88
  char v44; // al@89
  char *v45; // [sp+10h] [bp-3Ch]@3
  int v46; // [sp+14h] [bp-38h]@3
  char *v47; // [sp+18h] [bp-34h]@2
  int v48; // [sp+1Ch] [bp-30h]@17
  int v49; // [sp+2Ch] [bp-20h]@45

  v2 = a1;
  v3 = a2;
  memset(a2, 0, 0xC0u);
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  v4 = *(_DWORD *)(a1 + 76);
  if ( !v4 )
    return 5;
  v5 = _Unwind_Find_FDE(v4 + (*(_DWORD *)(v2 + 96) >> 31) - 1, v2 + 84);
  v47 = (char *)v5;
  if ( v5 )
  {
    *((_DWORD *)v3 + 41) = *(_DWORD *)(v2 + 92);
    v46 = v5 + 4 - *(_DWORD *)(v5 + 4);
    v45 = (char *)(v46 + 9);
    v6 = v46 + strlen((const char *)(v46 + 9)) + 1;
    v7 = (char *)(v6 + 9);
    if ( *(_BYTE *)(v46 + 9) == 101 && *(_BYTE *)(v46 + 10) == 104 )
    {
      *((_DWORD *)v3 + 47) = *(_DWORD *)(v6 + 9);
      v7 = (char *)(v6 + 13);
      v45 = (char *)(v46 + 11);
    }
    if ( *(_BYTE *)(v46 + 8) > 3u )
    {
      if ( *v7 != 4 || v7[1] )
        return 3;
      v7 += 2;
    }
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = *v7++;
      v8 |= (v10 & 0x7F) << v9;
      v9 += 7;
    }
    while ( v10 < 0 );
    *((_DWORD *)v3 + 44) = v8;
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *v7++;
      v11 |= (v13 & 0x7F) << v12;
      v12 += 7;
    }
    while ( v13 < 0 );
    if ( v12 <= 0x1F && v13 & 0x40 )
      v11 |= -1 << v12;
    *((_DWORD *)v3 + 43) = v11;
    if ( *(_BYTE *)(v46 + 8) == 1 )
    {
      *((_DWORD *)v3 + 45) = (unsigned __int8)*v7++;
    }
    else
    {
      v14 = 0;
      v15 = 0;
      do
      {
        v16 = *v7++;
        v14 |= (v16 & 0x7F) << v15;
        v15 += 7;
      }
      while ( v16 < 0 );
      *((_DWORD *)v3 + 45) = v14;
    }
    *((_BYTE *)v3 + 185) = -1;
    if ( *v45 == 122 )
    {
      v32 = 0;
      v33 = 0;
      do
      {
        v34 = *v7++;
        v32 |= (v34 & 0x7F) << v33;
        v33 += 7;
      }
      while ( v34 < 0 );
      v48 = (int)&v7[v32];
      *((_BYTE *)v3 + 186) = 1;
      ++v45;
    }
    else
    {
      v48 = 0;
    }
    v17 = (int)(v45 + 1);
    v18 = v7;
    for ( i = *v45; i; i = *(_BYTE *)(v17 - 1) )
    {
      if ( i == 76 )
      {
        *((_BYTE *)v3 + 185) = *v18++;
        ++v17;
      }
      else
      {
        if ( i != 82 )
        {
          if ( i != 80 )
          {
            if ( i != 83 )
              goto LABEL_59;
            *((_BYTE *)v3 + 187) = 1;
            ++v17;
            continue;
          }
          v24 = (_DWORD **)(v18 + 1);
          v25 = *v18;
          v26 = v25;
          if ( v25 == -1 )
            goto LABEL_44;
          v27 = v25 & 0x70;
          if ( v27 == 32 )
          {
            v28 = *(_DWORD ***)(v2 + 84);
          }
          else
          {
            if ( v27 <= 0x20u )
            {
              if ( v27 && v27 != 16 )
                goto LABEL_41;
              goto LABEL_44;
            }
            if ( v27 == 64 )
            {
              v28 = *(_DWORD ***)(v2 + 92);
            }
            else
            {
              if ( v27 != 80 )
              {
                if ( v27 != 48 )
                  goto LABEL_41;
                v28 = *(_DWORD ***)(v2 + 88);
                goto LABEL_45;
              }
LABEL_44:
              v28 = 0;
            }
          }
LABEL_45:
          v18 = read_encoded_value_with_base(v26, v28, v24, (char **)&v49);
          *((_DWORD *)v3 + 42) = v49;
          ++v17;
          continue;
        }
        *((_BYTE *)v3 + 184) = *v18++;
        ++v17;
      }
    }
    if ( !v48 )
    {
      v48 = (int)v18;
LABEL_59:
      if ( !v48 )
        return 3;
    }
    execute_cfa_program(v2, v46 + *(_DWORD *)v46 + 4);
    v20 = *((_BYTE *)v3 + 184);
    if ( v20 == -1 )
    {
      v22 = 0;
    }
    else
    {
      v21 = v20 & 7;
      if ( v21 == 2 )
      {
        v22 = 4;
      }
      else
      {
        if ( v21 <= 2u )
        {
          if ( v21 )
            goto LABEL_41;
          goto LABEL_30;
        }
        if ( v21 == 3 )
        {
LABEL_30:
          v22 = 8;
          goto LABEL_72;
        }
        if ( v21 != 4 )
          goto LABEL_41;
        v22 = 16;
      }
    }
LABEL_72:
    v35 = &v47[v22 + 8];
    v36 = 0;
    if ( *((_BYTE *)v3 + 186) )
    {
      v37 = 0;
      do
      {
        v38 = *v35++;
        v36 |= (v38 & 0x7F) << v37;
        v37 += 7;
      }
      while ( v38 < 0 );
    }
    v39 = *((_BYTE *)v3 + 185);
    if ( v39 == -1 )
      goto LABEL_82;
    v40 = v39 & 0x70;
    if ( v40 == 32 )
    {
      v41 = *(_DWORD ***)(v2 + 84);
      goto LABEL_81;
    }
    if ( v40 > 0x20u )
    {
      if ( v40 == 64 )
      {
        v41 = *(_DWORD ***)(v2 + 92);
        goto LABEL_81;
      }
      if ( v40 == 80 )
        goto LABEL_80;
      if ( v40 == 48 )
      {
        v41 = *(_DWORD ***)(v2 + 88);
        goto LABEL_81;
      }
    }
    else if ( !v40 || v40 == 16 )
    {
LABEL_80:
      v41 = 0;
LABEL_81:
      read_encoded_value_with_base(*((_BYTE *)v3 + 185), v41, (_DWORD **)v35, (char **)&v49);
      *(_DWORD *)(v2 + 80) = v49;
LABEL_82:
      execute_cfa_program(v2, &v47[*(_DWORD *)v47 + 4]);
      return 0;
    }
LABEL_41:
    abort();
  }
  v29 = *(_DWORD *)(v2 + 72);
  v30 = *(_DWORD *)(v2 + 76);
  if ( *(_BYTE *)(v30 - 2) == -1 && *(_BYTE *)(v30 - 1) == -48 && *(_BYTE *)v30 == -125 && *(_BYTE *)(v30 + 1) == -8 )
    goto LABEL_87;
  v31 = *(_BYTE *)(v30 - 5);
  if ( v31 == -24 )
  {
    v44 = *(_BYTE *)v30;
    if ( *(_BYTE *)(v30 - 4) == 104 && v44 == -61 )
    {
LABEL_87:
      v42 = *(_DWORD *)(*(_DWORD *)v29 + 4);
LABEL_88:
      v43 = *(_DWORD *)(v42 + 196);
      *((_DWORD *)v3 + 40) = 1;
      *((_DWORD *)v3 + 38) = 4;
      *((_DWORD *)v3 + 37) = v43 - v29;
      *((_DWORD *)v3 + 1) = 1;
      *(_DWORD *)v3 = v42 + 176 - v43;
      *((_DWORD *)v3 + 7) = 1;
      *((_DWORD *)v3 + 6) = v42 + 164 - v43;
      *((_DWORD *)v3 + 3) = 1;
      *((_DWORD *)v3 + 2) = v42 + 172 - v43;
      *((_DWORD *)v3 + 5) = 1;
      *((_DWORD *)v3 + 4) = v42 + 168 - v43;
      *((_DWORD *)v3 + 13) = 1;
      *((_DWORD *)v3 + 12) = v42 + 160 - v43;
      *((_DWORD *)v3 + 15) = 1;
      *((_DWORD *)v3 + 14) = v42 + 156 - v43;
      *((_DWORD *)v3 + 11) = 1;
      *((_DWORD *)v3 + 10) = v42 + 180 - v43;
      *((_DWORD *)v3 + 17) = 1;
      *((_DWORD *)v3 + 16) = v42 + 184 - v43;
      *((_DWORD *)v3 + 45) = 8;
      *((_BYTE *)v3 + 187) = 1;
      return 0;
    }
    if ( v44 == -125 && *(_BYTE *)(v30 + 1) == -60 && *(_BYTE *)(v30 + 3) == -72 )
    {
      v42 = *(_DWORD *)(v29 + 56);
      goto LABEL_88;
    }
  }
  else if ( v31 == -117 && *(_BYTE *)(v30 - 4) == 77 && *(_BYTE *)v30 == 100 && *(_BYTE *)(v30 + 1) == -117 )
  {
    v42 = *(_DWORD *)(v29 + 8);
    goto LABEL_88;
  }
  if ( *(_BYTE *)(v30 - 1) != -125 || *(_BYTE *)v30 != 9 || *(_BYTE *)(v30 + 1) )
    return 5;
  result = 5;
  if ( *(_BYTE *)(v30 + 2) == 45 && !*(_BYTE *)(v30 + 3) && *(_BYTE *)(v30 + 4) == 16 && !*(_BYTE *)(v30 + 5) )
  {
    *((_DWORD *)v3 + 40) = 1;
    *((_DWORD *)v3 + 38) = 4;
    *((_DWORD *)v3 + 37) = 4;
    *((_DWORD *)v3 + 3) = 1;
    *((_DWORD *)v3 + 2) = -4;
    *((_DWORD *)v3 + 45) = 8;
    *((_DWORD *)v3 + 17) = 1;
    *((_DWORD *)v3 + 16) = 0;
    *((_BYTE *)v3 + 187) = 1;
    result = 0;
  }
  return result;
}
// 40EF60: using guessed type int __fastcall execute_cfa_program(_DWORD, _DWORD);

//----- (0040FE04) --------------------------------------------------------
unsigned int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // eax@1
  unsigned int result; // eax@13
  int v8; // [sp+1Ch] [bp-E0h]@11
  char v9; // [sp+20h] [bp-DCh]@1
  int v10; // [sp+B4h] [bp-48h]@13
  int v11; // [sp+B8h] [bp-44h]@13
  int v12; // [sp+C0h] [bp-3Ch]@13
  void *retaddr; // [sp+FCh] [bp+0h]@1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  memset((void *)a1, 0, 0x80u);
  *(_DWORD *)(a1 + 76) = retaddr;
  *(_DWORD *)(a1 + 96) = 0x40000000;
  LOBYTE(v6) = uw_frame_state_for(a1, &v9);
  if ( v6 )
    goto LABEL_5;
  if ( _CRT_MT )
  {
    if ( once_regsizes_34688 )
      goto LABEL_4;
    if ( !InterlockedIncrement(&Addend) )
    {
      dwarf_reg_size_table[0] = 4;
      byte_55B94A = 4;
      byte_55B949 = 4;
      byte_55B94B = 4;
      byte_55B94E = 4;
      byte_55B94F = 4;
      byte_55B94D = 4;
      byte_55B94C = 4;
      byte_55B953 = 12;
      byte_55B954 = 12;
      byte_55B955 = 12;
      byte_55B956 = 12;
      byte_55B957 = 12;
      byte_55B958 = 12;
      byte_55B951 = 4;
      byte_55B950 = 4;
      once_regsizes_34688 = 1;
      goto LABEL_4;
    }
    while ( !once_regsizes_34688 )
      Sleep(0);
    if ( byte_55B94C == 4 )
      goto LABEL_11;
LABEL_5:
    abort();
  }
  if ( !dwarf_reg_size_table[0] )
  {
    dwarf_reg_size_table[0] = 4;
    byte_55B94A = 4;
    byte_55B949 = 4;
    byte_55B94B = 4;
    byte_55B94E = 4;
    byte_55B94F = 4;
    byte_55B94D = 4;
    byte_55B94C = 4;
    byte_55B953 = 12;
    byte_55B954 = 12;
    byte_55B955 = 12;
    byte_55B956 = 12;
    byte_55B957 = 12;
    byte_55B958 = 12;
    byte_55B951 = 4;
    byte_55B950 = 4;
  }
LABEL_4:
  if ( byte_55B94C != 4 )
    goto LABEL_5;
LABEL_11:
  v8 = v4;
  if ( *(_BYTE *)(v3 + 99) & 0x40 )
    *(_BYTE *)(v3 + 112) = 0;
  *(_DWORD *)(v3 + 16) = &v8;
  v12 = 1;
  v11 = 4;
  v10 = 0;
  result = uw_update_context_1(v3, (int)&v9);
  *(_DWORD *)(v3 + 76) = v5;
  return result;
}
// 41700C: using guessed type int once_regsizes_34688;
// 55B920: using guessed type int _CRT_MT;
// 55B949: using guessed type char byte_55B949;
// 55B94A: using guessed type char byte_55B94A;
// 55B94B: using guessed type char byte_55B94B;
// 55B94C: using guessed type char byte_55B94C;
// 55B94D: using guessed type char byte_55B94D;
// 55B94E: using guessed type char byte_55B94E;
// 55B94F: using guessed type char byte_55B94F;
// 55B950: using guessed type char byte_55B950;
// 55B951: using guessed type char byte_55B951;
// 55B953: using guessed type char byte_55B953;
// 55B954: using guessed type char byte_55B954;
// 55B955: using guessed type char byte_55B955;
// 55B956: using guessed type char byte_55B956;
// 55B957: using guessed type char byte_55B957;
// 55B958: using guessed type char byte_55B958;

//----- (0040FFF0) --------------------------------------------------------
signed int __usercall _Unwind_ForcedUnwind_Phase2@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *v2; // esi@1
  int v3; // ebx@1
  int (__cdecl *v4)(signed int, signed int, _DWORD, _DWORD, _DWORD *, int, int); // edi@1
  int v5; // ebp@1
  int v6; // eax@2
  int v7; // eax@4
  signed int v8; // edx@4
  int v10; // eax@8
  _DWORD *v11; // ecx@12
  char v12; // [sp+30h] [bp-DCh]@2
  int v13[41]; // [sp+34h] [bp-D8h]@10
  int (__cdecl *v14)(signed int, signed int, _DWORD, _DWORD, _DWORD, int); // [sp+D8h] [bp-34h]@7
  int v15; // [sp+E4h] [bp-28h]@10

  v2 = (_DWORD *)a1;
  v3 = a2;
  v4 = *(int (__cdecl **)(signed int, signed int, _DWORD, _DWORD, _DWORD *, int, int))(a1 + 12);
  v5 = *(_DWORD *)(a1 + 16);
  while ( 1 )
  {
    LOBYTE(v6) = uw_frame_state_for(v3, &v12);
    if ( v6 )
      break;
    if ( v4(1, 10, *v2, v2[1], v2, v3, v5) )
      return 2;
    if ( v14 )
    {
      v10 = v14(1, 10, *v2, v2[1], v2, v3);
      v8 = v10;
      if ( v10 == 7 )
        return v8;
      if ( v10 != 8 )
        return 2;
    }
    uw_update_context_1(v3, (int)&v12);
    if ( v13[2 * v15] == 6 )
    {
      *(_DWORD *)(v3 + 76) = 0;
    }
    else
    {
      if ( v15 > 17 )
        goto LABEL_15;
      v11 = *(_DWORD **)(v3 + 4 * v15);
      if ( !(*(_BYTE *)(v3 + 99) & 0x40) || !*(_BYTE *)(v3 + v15 + 108) )
      {
        if ( dwarf_reg_size_table[v15] != 4 )
LABEL_15:
          abort();
        v11 = (_DWORD *)*v11;
      }
      *(_DWORD *)(v3 + 76) = v11;
    }
  }
  if ( v6 == 5 )
  {
    v7 = v4(1, 26, *v2, v2[1], v2, v3, v5);
    v8 = 5;
    if ( !v7 )
      return v8;
  }
  return 2;
}
// 40FFF0: using guessed type int var_D8[41];

//----- (00410144) --------------------------------------------------------
int __usercall _Unwind_RaiseException_Phase2@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // edi@2
  int result; // eax@4
  _DWORD *v7; // ecx@9
  char v8; // [sp+20h] [bp-DCh]@2
  int v9[41]; // [sp+24h] [bp-D8h]@7
  int (__cdecl *v10)(signed int, int, _DWORD, _DWORD, int, int); // [sp+C8h] [bp-34h]@3
  int v11; // [sp+D4h] [bp-28h]@7

  v2 = a1;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(v4) = uw_frame_state_for(v3, &v8);
    v5 = 4 * (*(_DWORD *)(v2 + 16) == *(_DWORD *)(v3 + 72) - (*(_DWORD *)(v3 + 96) >> 31));
    if ( v4 )
      return 2;
    if ( v10 )
    {
      result = v10(
                 1,
                 4 * (*(_DWORD *)(v2 + 16) == *(_DWORD *)(v3 + 72) - (*(_DWORD *)(v3 + 96) >> 31)) + 2,
                 *(_DWORD *)v2,
                 *(_DWORD *)(v2 + 4),
                 v2,
                 v3);
      if ( result == 7 )
        return result;
      if ( result != 8 )
        return 2;
    }
    if ( v5 )
      goto LABEL_12;
    uw_update_context_1(v3, (int)&v8);
    if ( v9[2 * v11] == 6 )
    {
      *(_DWORD *)(v3 + 76) = 0;
    }
    else
    {
      if ( v11 > 17 )
        goto LABEL_12;
      v7 = *(_DWORD **)(v3 + 4 * v11);
      if ( !(*(_BYTE *)(v3 + 99) & 0x40) || !*(_BYTE *)(v3 + v11 + 108) )
      {
        if ( dwarf_reg_size_table[v11] != 4 )
LABEL_12:
          abort();
        v7 = (_DWORD *)*v7;
      }
      *(_DWORD *)(v3 + 76) = v7;
    }
  }
}
// 410144: using guessed type int var_D8[41];

//----- (00410230) --------------------------------------------------------
int __cdecl _Unwind_GetGR(int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 17 )
    goto LABEL_4;
  result = *(_DWORD *)(a1 + 4 * a2);
  if ( !(*(_BYTE *)(a1 + 99) & 0x40) || !*(_BYTE *)(a1 + a2 + 108) )
  {
    if ( dwarf_reg_size_table[a2] == 4 )
      return *(_DWORD *)result;
LABEL_4:
    abort();
  }
  return result;
}

//----- (00410270) --------------------------------------------------------
int __cdecl _Unwind_GetCFA(int a1)
{
  return *(_DWORD *)(a1 + 72);
}

//----- (00410278) --------------------------------------------------------
_DWORD *__cdecl _Unwind_SetGR(int a1, signed int a2, int a3)
{
  _DWORD *result; // eax@1

  result = (_DWORD *)a2;
  if ( a2 > 17 )
    goto LABEL_10;
  if ( *(_BYTE *)(a1 + 99) & 0x40 && *(_BYTE *)(a1 + a2 + 108) )
  {
    *(_DWORD *)(a1 + 4 * a2) = a3;
    return result;
  }
  result = *(_DWORD **)(a1 + 4 * a2);
  if ( dwarf_reg_size_table[a2] != 4 )
LABEL_10:
    abort();
  *result = a3;
  return result;
}

//----- (004102C4) --------------------------------------------------------
int __cdecl _Unwind_GetIP(int a1)
{
  return *(_DWORD *)(a1 + 76);
}

//----- (004102CC) --------------------------------------------------------
int __cdecl _Unwind_GetIPInfo(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 96) >> 31;
  return *(_DWORD *)(a1 + 76);
}

//----- (004102E0) --------------------------------------------------------
int __cdecl _Unwind_SetIP(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 76) = a2;
  return result;
}

//----- (004102EC) --------------------------------------------------------
int __cdecl _Unwind_GetLanguageSpecificData(int a1)
{
  return *(_DWORD *)(a1 + 80);
}

//----- (004102F4) --------------------------------------------------------
int __cdecl _Unwind_GetRegionStart(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (004102FC) --------------------------------------------------------
int __cdecl _Unwind_FindEnclosingFunction(int a1)
{
  int result; // eax@2
  char v2; // [sp+14h] [bp-18h]@1
  int v3; // [sp+1Ch] [bp-10h]@2

  if ( _Unwind_Find_FDE(a1 - 1, (int)&v2) )
    result = v3;
  else
    result = 0;
  return result;
}

//----- (00410324) --------------------------------------------------------
int __cdecl _Unwind_GetDataRelBase(int a1)
{
  return *(_DWORD *)(a1 + 88);
}

//----- (0041032C) --------------------------------------------------------
int __cdecl _Unwind_GetTextRelBase(int a1)
{
  return *(_DWORD *)(a1 + 84);
}

//----- (00410334) --------------------------------------------------------
int __cdecl __frame_state_for(int a1, int a2)
{
  int v2; // eax@1
  int v3; // edx@3
  int v4; // ecx@6
  int result; // eax@8
  int v6; // [sp+0h] [bp-14Ch]@1
  int v7; // [sp+4Ch] [bp-100h]@1
  int v8; // [sp+60h] [bp-ECh]@1
  int v9; // [sp+68h] [bp-E4h]@8
  int v10; // [sp+80h] [bp-CCh]@1
  int v11[36]; // [sp+84h] [bp-C8h]@6
  int v12; // [sp+114h] [bp-38h]@8
  int v13; // [sp+118h] [bp-34h]@8
  int v14; // [sp+120h] [bp-2Ch]@2
  int v15; // [sp+134h] [bp-18h]@8
  int v16; // [sp+13Ch] [bp-10h]@8

  memset(&v6, 0, 0x80u);
  v8 = 0x40000000;
  v7 = a1 + 1;
  LOBYTE(v2) = uw_frame_state_for((int)&v6, &v10);
  if ( v2 || v14 == 2 )
  {
    result = 0;
  }
  else
  {
    v3 = 0;
    do
    {
      while ( 1 )
      {
        v4 = v11[2 * v3];
        *(_BYTE *)(a2 + v3 + 92) = v4;
        if ( (_BYTE)v4 == 1 || (_BYTE)v4 == 2 )
          break;
        *(_DWORD *)(a2 + 4 * v3++ + 16) = 0;
        if ( v3 == 18 )
          goto LABEL_8;
      }
      *(_DWORD *)(a2 + 4 * v3 + 16) = *(&v10 + 2 * v3);
      ++v3;
    }
    while ( v3 != 18 );
LABEL_8:
    *(_DWORD *)(a2 + 8) = v12;
    *(_WORD *)(a2 + 88) = v13;
    *(_WORD *)(a2 + 90) = v15;
    *(_DWORD *)(a2 + 12) = v9;
    *(_DWORD *)(a2 + 4) = v16;
    result = a2;
  }
  return result;
}
// 410334: using guessed type int var_C8[36];

//----- (00410408) --------------------------------------------------------
char __usercall __noreturn _Unwind_RaiseException@<al>(int a1@<ebp>)
{
  int v1; // ebx@1
  int v2; // eax@2
  int (__cdecl *v3)(signed int, signed int, _DWORD, _DWORD, int, int); // ecx@4
  int v4; // eax@5
  signed int v5; // eax@7
  _DWORD *v6; // ecx@9
  int v7; // ebx@19
  int v8; // esi@19
  int v9; // edx@19
  int v10; // ebx@19
  int v11; // esi@19
  int v12; // edi@19
  int v13; // ebp@19

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 480) = a1 - 472;
  uw_init_context_1(a1 - 472, a1 + 8, *(_DWORD *)(a1 + 4));
  *(_DWORD *)(a1 - 476) = a1 - 344;
  qmemcpy((void *)(a1 - 344), *(const void **)(a1 - 480), 0x80u);
  while ( 1 )
  {
    LOBYTE(v2) = uw_frame_state_for(a1 - 344, (void *)(a1 - 216));
    if ( v2 == 5 )
      return v2;
    if ( v2 )
      goto LABEL_16;
    v3 = *(int (__cdecl **)(signed int, signed int, _DWORD, _DWORD, int, int))(a1 - 48);
    if ( v3 )
    {
      v4 = v3(1, 1, *(_DWORD *)v1, *(_DWORD *)(v1 + 4), v1, a1 - 344);
      if ( v4 == 6 )
      {
        *(_DWORD *)(v1 + 12) = 0;
        *(_DWORD *)(v1 + 16) = *(_DWORD *)(a1 - 272) - (*(_DWORD *)(a1 - 248) >> 31);
        qmemcpy(*(void **)(a1 - 476), *(const void **)(a1 - 480), 0x80u);
        v2 = _Unwind_RaiseException_Phase2(v1, a1 - 344);
        if ( v2 == 7 )
        {
          v7 = uw_install_context_1(a1 - 472, a1 - 344);
          v8 = *(_DWORD *)(a1 - 268);
          _Unwind_DebugHook(*(_DWORD *)(a1 - 272), *(_DWORD *)(a1 - 268));
          *(_DWORD *)(a1 + 4 + v7) = v8;
          v2 = *(_DWORD *)(a1 - 20);
          v9 = *(_DWORD *)(a1 - 16);
          v10 = *(_DWORD *)(a1 - 12);
          v11 = *(_DWORD *)(a1 - 8);
          v12 = *(_DWORD *)(a1 - 4);
          v13 = *(_DWORD *)a1;
        }
        return v2;
      }
      if ( v4 != 8 )
      {
LABEL_16:
        LOBYTE(v2) = 3;
        return v2;
      }
    }
    uw_update_context_1(a1 - 344, a1 - 216);
    v5 = *(_DWORD *)(a1 - 36);
    if ( *(_DWORD *)(a1 - 212 + 8 * v5) == 6 )
    {
      *(_DWORD *)(a1 - 268) = 0;
    }
    else
    {
      if ( v5 > 17 )
        goto LABEL_12;
      v6 = *(_DWORD **)(a1 - 344 + 4 * v5);
      if ( !(*(_BYTE *)(a1 - 245) & 0x40) || !*(_BYTE *)(a1 - 236 + v5) )
      {
        if ( dwarf_reg_size_table[v5] != 4 )
LABEL_12:
          abort();
        v6 = (_DWORD *)*v6;
      }
      *(_DWORD *)(a1 - 268) = v6;
    }
  }
}
// 410404: using guessed type int __cdecl _Unwind_DebugHook(_DWORD, _DWORD);

//----- (004105BC) --------------------------------------------------------
signed int __usercall _Unwind_ForcedUnwind@<eax>(int a1@<ebp>)
{
  int v1; // edx@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  int v5; // edx@2
  int v6; // ebx@2
  int v7; // esi@2
  int v8; // edi@2
  int v9; // ebp@2

  uw_init_context_1(a1 - 280, a1 + 8, *(_DWORD *)(a1 + 4));
  qmemcpy((void *)(a1 - 152), (const void *)(a1 - 280), 0x80u);
  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v1 + 12) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v1 + 16) = *(_DWORD *)(a1 + 16);
  result = _Unwind_ForcedUnwind_Phase2(*(_DWORD *)(a1 + 8), a1 - 152);
  if ( result == 7 )
  {
    v3 = uw_install_context_1(a1 - 280, a1 - 152);
    v4 = *(_DWORD *)(a1 - 76);
    _Unwind_DebugHook(*(_DWORD *)(a1 - 80), *(_DWORD *)(a1 - 76));
    *(_DWORD *)(a1 + 4 + v3) = v4;
    result = *(_DWORD *)(a1 - 20);
    v5 = *(_DWORD *)(a1 - 16);
    v6 = *(_DWORD *)(a1 - 12);
    v7 = *(_DWORD *)(a1 - 8);
    v8 = *(_DWORD *)(a1 - 4);
    v9 = *(_DWORD *)a1;
  }
  return result;
}
// 410404: using guessed type int __cdecl _Unwind_DebugHook(_DWORD, _DWORD);

//----- (0041065C) --------------------------------------------------------
int __usercall __noreturn _Unwind_Resume@<eax>(int a1@<ebp>)
{
  int v1; // eax@1
  int v2; // edx@1
  signed int v3; // eax@2
  int v4; // ebx@6
  int v5; // esi@6
  int result; // eax@6
  int v7; // edx@6
  int v8; // ebx@6
  int v9; // esi@6
  int v10; // edi@6
  int v11; // ebp@6

  *(_DWORD *)(a1 - 284) = a1 - 280;
  uw_init_context_1(a1 - 280, a1 + 8, *(_DWORD *)(a1 + 4));
  qmemcpy((void *)(a1 - 152), *(const void **)(a1 - 284), 0x80u);
  v1 = *(_DWORD *)(a1 + 8);
  v2 = a1 - 152;
  if ( *(_DWORD *)(v1 + 12) )
    v3 = _Unwind_ForcedUnwind_Phase2(*(_DWORD *)(a1 + 8), v2);
  else
    v3 = _Unwind_RaiseException_Phase2(v1, v2);
  if ( v3 != 7 )
    abort();
  v4 = uw_install_context_1(a1 - 280, a1 - 152);
  v5 = *(_DWORD *)(a1 - 76);
  _Unwind_DebugHook(*(_DWORD *)(a1 - 80), *(_DWORD *)(a1 - 76));
  *(_DWORD *)(a1 + 4 + v4) = v5;
  result = *(_DWORD *)(a1 - 20);
  v7 = *(_DWORD *)(a1 - 16);
  v8 = *(_DWORD *)(a1 - 12);
  v9 = *(_DWORD *)(a1 - 8);
  v10 = *(_DWORD *)(a1 - 4);
  v11 = *(_DWORD *)a1;
  return result;
}
// 410404: using guessed type int __cdecl _Unwind_DebugHook(_DWORD, _DWORD);

//----- (004106FC) --------------------------------------------------------
int __usercall __noreturn _Unwind_Resume_or_Rethrow@<eax>(int a1@<ebp>)
{
  int v1; // ebx@5
  int v2; // esi@5
  int result; // eax@5
  int v4; // edx@5
  int v5; // ebx@5
  int v6; // esi@5
  int v7; // edi@5
  int v8; // ebp@5

  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) )
    _Unwind_RaiseException(a1);
  uw_init_context_1(a1 - 280, a1 + 8, *(_DWORD *)(a1 + 4));
  qmemcpy((void *)(a1 - 152), (const void *)(a1 - 280), 0x80u);
  if ( _Unwind_ForcedUnwind_Phase2(*(_DWORD *)(a1 + 8), a1 - 152) != 7 )
    abort();
  v1 = uw_install_context_1(a1 - 280, a1 - 152);
  v2 = *(_DWORD *)(a1 - 76);
  _Unwind_DebugHook(*(_DWORD *)(a1 - 80), *(_DWORD *)(a1 - 76));
  *(_DWORD *)(a1 + 4 + v1) = v2;
  result = *(_DWORD *)(a1 - 20);
  v4 = *(_DWORD *)(a1 - 16);
  v5 = *(_DWORD *)(a1 - 12);
  v6 = *(_DWORD *)(a1 - 8);
  v7 = *(_DWORD *)(a1 - 4);
  v8 = *(_DWORD *)a1;
  return result;
}
// 410404: using guessed type int __cdecl _Unwind_DebugHook(_DWORD, _DWORD);

//----- (004107A4) --------------------------------------------------------
int (__cdecl *__cdecl _Unwind_DeleteException(int a1))(signed int, int)
{
  int (__cdecl *result)(signed int, int); // eax@1

  result = *(int (__cdecl **)(signed int, int))(a1 + 8);
  if ( result )
    result = (int (__cdecl *)(signed int, int))result(1, a1);
  return result;
}

//----- (004107C4) --------------------------------------------------------
signed int __cdecl _Unwind_Backtrace(int (__cdecl *a1)(int *, int), int a2)
{
  signed int v2; // eax@2
  signed int v3; // ebx@2
  signed int result; // eax@5
  _DWORD *v5; // ecx@10
  int v6[19]; // [sp+10h] [bp-158h]@1
  _DWORD *v7; // [sp+5Ch] [bp-10Ch]@15
  char v8; // [sp+73h] [bp-F5h]@10
  char v9[20]; // [sp+7Ch] [bp-ECh]@11
  char v10; // [sp+90h] [bp-D8h]@2
  int v11[44]; // [sp+94h] [bp-D4h]@8
  int v12; // [sp+144h] [bp-24h]@8
  int retaddr; // [sp+16Ch] [bp+4h]@1

  uw_init_context_1((int)v6, (int)&a1, retaddr);
  while ( 1 )
  {
    LOBYTE(v2) = uw_frame_state_for((int)v6, &v10);
    v3 = v2;
    if ( v2 )
      break;
    if ( a1(v6, a2) )
      goto LABEL_6;
    uw_update_context_1((int)v6, (int)&v10);
    if ( v11[2 * v12] == 6 )
    {
      v7 = 0;
    }
    else
    {
      if ( v12 > 17 )
        goto LABEL_13;
      v5 = (_DWORD *)v6[v12];
      if ( !(v8 & 0x40) || !v9[v12] )
      {
        if ( dwarf_reg_size_table[v12] != 4 )
LABEL_13:
          abort();
        v5 = (_DWORD *)*v5;
      }
      v7 = v5;
    }
  }
  if ( v2 != 5 || a1(v6, a2) )
LABEL_6:
    result = 3;
  else
    result = v3;
  return result;
}
// 4107C4: using guessed type int var_158[19];
// 4107C4: using guessed type int var_D4[44];
// 4107C4: using guessed type char var_EC[20];

//----- (004108C4) --------------------------------------------------------
void __cdecl emutls_destroy(void *a1)
{
  int v1; // edi@1
  int v2; // ebx@1
  int v3; // eax@2

  v1 = *(_DWORD *)a1;
  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    do
    {
      v3 = *((_DWORD *)a1 + v2 + 1);
      if ( v3 )
        free(*(void **)(v3 - 4));
      ++v2;
    }
    while ( v2 != v1 );
  }
  free(a1);
}

//----- (00410900) --------------------------------------------------------
DWORD emutls_init()
{
  int v0; // eax@1
  DWORD result; // eax@2

  emutls_mutex = -1;
  hHandle = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  v0 = TlsAlloc();
  if ( v0 == -1 )
  {
    result = GetLastError();
  }
  else
  {
    emutls_key = v0;
    result = __mingwthr_key_dtor(v0, (int)emutls_destroy);
  }
  if ( result )
    abort();
  return result;
}

//----- (0041096C) --------------------------------------------------------
_DWORD *__cdecl __emutls_get_address(int a1)
{
  _DWORD *result; // eax@2
  unsigned int v2; // ebp@5
  DWORD v3; // ebx@6
  DWORD v4; // edi@6
  LPVOID v5; // ebx@6
  int v6; // edi@7
  int v7; // ebp@8
  _DWORD *v8; // eax@10
  int v9; // edx@21
  _DWORD *v10; // eax@23
  int v11; // [sp+1Ch] [bp-20h]@23

  if ( !_CRT_MT )
  {
    result = *(_DWORD **)(a1 + 8);
    if ( !result )
    {
      result = emutls_alloc(a1);
      *(_DWORD *)(a1 + 8) = result;
    }
    return result;
  }
  v2 = *(_DWORD *)(a1 + 8);
  if ( !v2 )
  {
    if ( once_33252 )
      goto LABEL_36;
    if ( InterlockedIncrement(&dword_417018) )
    {
      while ( !once_33252 )
        Sleep(0);
    }
    else
    {
      emutls_init();
      once_33252 = 1;
    }
    if ( _CRT_MT )
    {
LABEL_36:
      if ( InterlockedIncrement(&emutls_mutex) && WaitForSingleObject(hHandle, 0xFFFFFFFF) )
        InterlockedDecrement(&emutls_mutex);
    }
    v2 = *(_DWORD *)(a1 + 8);
    if ( !v2 )
    {
      v2 = emutls_size + 1;
      emutls_size = v2;
      *(_DWORD *)(a1 + 8) = v2;
    }
    if ( _CRT_MT && InterlockedDecrement(&emutls_mutex) >= 0 )
      ReleaseSemaphore(hHandle, 1, 0);
  }
  v3 = emutls_key;
  v4 = GetLastError();
  v5 = TlsGetValue(v3);
  SetLastError(v4);
  if ( !v5 )
  {
    v8 = calloc(v2 + 33, 4u);
    v5 = v8;
    if ( v8 )
    {
      *v8 = v2 + 32;
      goto LABEL_12;
    }
LABEL_33:
    abort();
  }
  v6 = *(_DWORD *)v5;
  if ( v2 > *(_DWORD *)v5 )
  {
    v9 = 2 * v6;
    if ( v2 > 2 * v6 )
      v9 = v2 + 32;
    v11 = v9;
    v10 = realloc(v5, 4 * v9 + 4);
    v5 = v10;
    if ( v10 )
    {
      *v10 = v11;
      memset(&v10[v6 + 1], 0, 4 * (v11 - v6));
LABEL_12:
      if ( !TlsSetValue(emutls_key, v5) )
        GetLastError();
      goto LABEL_8;
    }
    goto LABEL_33;
  }
LABEL_8:
  v7 = v2 - 1;
  result = (_DWORD *)*((_DWORD *)v5 + v7 + 1);
  if ( !result )
  {
    result = emutls_alloc(a1);
    *((_DWORD *)v5 + v7 + 1) = result;
  }
  return result;
}
// 417014: using guessed type int once_33252;
// 55B920: using guessed type int _CRT_MT;
// 55B964: using guessed type int emutls_size;

//----- (00410B80) --------------------------------------------------------
int __cdecl __emutls_register_common(int a1, unsigned int a2, unsigned int a3, int a4)
{
  int result; // eax@1
  unsigned int v5; // ecx@1

  result = a1;
  v5 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 < a2 )
  {
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 12) = 0;
    v5 = a2;
  }
  if ( *(_DWORD *)(a1 + 4) < a3 )
    *(_DWORD *)(a1 + 4) = a3;
  if ( a4 )
  {
    if ( a2 == v5 )
      *(_DWORD *)(a1 + 12) = a4;
  }
  return result;
}

//----- (00410BBC) --------------------------------------------------------
int __cdecl fde_unencoded_compare(int a1, int a2, int a3)
{
  unsigned int v3; // ecx@1
  int result; // eax@2

  v3 = *(_DWORD *)(a3 + 8);
  if ( *(_DWORD *)(a2 + 8) > v3 )
    result = 1;
  else
    result = -(*(_DWORD *)(a2 + 8) < v3);
  return result;
}

//----- (00410BD8) --------------------------------------------------------
int __usercall read_encoded_value_with_base_0@<eax>(char a1@<al>, int a2@<ecx>, _DWORD *a3)
{
  unsigned __int8 v3; // al@2
  int *v4; // eax@6
  int v5; // ebx@6
  int result; // eax@6

  if ( a1 != 80 )
  {
    v3 = a1 & 0xF;
    if ( v3 <= 0xCu && !v3 )
      JUMPOUT(*(_DWORD *)algn_410C06);
    abort();
  }
  v4 = (int *)((a2 + 3) & 0xFFFFFFFC);
  v5 = *v4;
  result = (int)(v4 + 1);
  *a3 = v5;
  return result;
}

//----- (00410CDC) --------------------------------------------------------
int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  int result; // eax@1
  int v5; // esi@2
  int v6; // ecx@2
  int v7; // ebx@3
  int *v8; // ebp@3
  int *v9; // esi@5
  int v10; // ST14_4@8
  int v11; // eax@8
  int v12; // eax@12
  int v13; // ecx@13
  int v14; // esi@13
  int v15; // ebx@13
  int *v16; // ebp@13
  int *v17; // esi@15
  int v18; // eax@16
  int v19; // ST14_4@18
  int v20; // eax@18
  signed int v21; // [sp+18h] [bp-34h]@1
  int j; // [sp+18h] [bp-34h]@11
  int v23; // [sp+1Ch] [bp-30h]@1
  int (__cdecl *v24)(int, int, int); // [sp+20h] [bp-2Ch]@1
  int v25; // [sp+24h] [bp-28h]@1
  int i; // [sp+28h] [bp-24h]@1
  int v27; // [sp+2Ch] [bp-20h]@1

  v23 = a1;
  v24 = a2;
  v25 = a3;
  v3 = a3 + 8;
  v21 = *(_DWORD *)(a3 + 4);
  v27 = 2 * ((unsigned int)v21 >> 1) - 1;
  result = ((unsigned int)v21 >> 1) - 1;
  for ( i = ((unsigned int)v21 >> 1) - 1; i >= 0; --i )
  {
    v5 = v27;
    v6 = i;
    if ( v27 < v21 )
    {
      v7 = v27 + 1;
      v8 = (int *)(v3 + 4 * v27);
      if ( v27 + 1 < v21 )
      {
        do
        {
          v10 = v6;
          v11 = v24(v23, *v8, *(_DWORD *)(v3 + 4 * v7));
          v6 = v10;
          if ( v11 >= 0 )
            break;
          v8 = (int *)(v3 + 4 * v7);
LABEL_5:
          v9 = (int *)(v3 + 4 * v6);
          result = v24(v23, *v9, *v8);
          if ( result >= 0 )
            goto LABEL_10;
          result = *v9;
          *v9 = *v8;
          *v8 = result;
          v5 = 2 * v7 + 1;
          if ( v5 >= v21 )
            goto LABEL_10;
          v6 = v7;
          v7 = 2 * v7 + 2;
          v8 = (int *)(v3 + 4 * v5);
        }
        while ( v5 + 1 < v21 );
      }
      v7 = v5;
      goto LABEL_5;
    }
LABEL_10:
    v27 -= 2;
  }
  for ( j = v21 - 1; j > 0; result = j )
  {
    v12 = *(_DWORD *)(v25 + 8);
    *(_DWORD *)(v25 + 8) = *(_DWORD *)(v25 + 4 * j + 8);
    *(_DWORD *)(v25 + 4 * j + 8) = v12;
    if ( j > 1 )
    {
      v13 = 0;
      v14 = 1;
      v15 = 2;
      v16 = (int *)(v3 + 4);
      if ( j > 2 )
      {
        do
        {
          v19 = v13;
          v20 = v24(v23, *v16, *(_DWORD *)(v3 + 4 * v15));
          v13 = v19;
          if ( v20 >= 0 )
            break;
          v16 = (int *)(v3 + 4 * v15);
LABEL_15:
          v17 = (int *)(v3 + 4 * v13);
          if ( v24(v23, *v17, *v16) >= 0 )
            goto LABEL_20;
          v18 = *v17;
          *v17 = *v16;
          *v16 = v18;
          v14 = 2 * v15 + 1;
          if ( v14 >= j )
            goto LABEL_20;
          v13 = v15;
          v15 = 2 * v15 + 2;
          v16 = (int *)(v3 + 4 * v14);
        }
        while ( v14 + 1 < j );
      }
      v15 = v14;
      goto LABEL_15;
    }
LABEL_20:
    --j;
  }
  return result;
}
// 410CDC: too many cbuild loops

//----- (00410E88) --------------------------------------------------------
HANDLE __gthread_mutex_init_function_constprop_9()
{
  HANDLE result; // eax@1

  object_mutex = -1;
  result = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  hSemaphore = result;
  return result;
}

//----- (00410EC8) --------------------------------------------------------
HANDLE init_object_mutex()
{
  HANDLE result; // eax@1

  object_mutex = -1;
  result = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  hSemaphore = result;
  return result;
}

//----- (00410F08) --------------------------------------------------------
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3)
{
  __int16 v3; // dx@1
  char v4; // al@1
  unsigned __int8 v5; // dl@2
  int result; // eax@9
  int v7; // esi@11
  int v8; // esi@12
  unsigned int v9; // [sp+18h] [bp-14h]@8
  unsigned int v10; // [sp+1Ch] [bp-10h]@8

  v3 = (unsigned __int16)*(_DWORD *)(a1 + 16) >> 3;
  v4 = v3;
  if ( (_BYTE)v3 != -1 )
  {
    v5 = v3 & 0x70;
    if ( v5 == 32 )
    {
      v7 = *(_DWORD *)(a1 + 4);
    }
    else if ( v5 <= 0x20u )
    {
      if ( v5 && v5 != 16 )
        abort();
    }
    else if ( v5 == 48 )
    {
      v8 = *(_DWORD *)(a1 + 8);
    }
    else if ( v5 != 80 )
    {
      abort();
    }
  }
  read_encoded_value_with_base_0(v4, a2 + 8, &v9);
  read_encoded_value_with_base_0((unsigned __int16)*(_DWORD *)(a1 + 16) >> 3, a3 + 8, &v10);
  if ( v9 > v10 )
    result = 1;
  else
    result = -(v9 < v10);
  return result;
}

//----- (00410FB0) --------------------------------------------------------
signed int __usercall get_cie_encoding@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // ecx@1
  int v3; // edi@1
  char *v4; // edx@1
  unsigned __int8 v5; // bl@1
  signed int result; // eax@3
  char v7; // al@5
  char v8; // cl@6
  char v9; // al@8
  _BYTE *v10; // ebx@9
  char v11; // al@10
  char v12; // al@11
  char v13; // [sp+1Ch] [bp-10h]@16

  v1 = a1;
  v2 = strlen((const char *)(a1 + 9)) + 1;
  v3 = a1 + v2;
  v4 = (char *)(a1 + v2 + 9);
  v5 = *(_BYTE *)(a1 + 8);
  if ( v5 > 3u )
  {
    result = 255;
    if ( *(_BYTE *)(v1 + v2 + 9) != 4 || *(_BYTE *)(v1 + v2 + 10) )
      return result;
    v4 = (char *)(v3 + 11);
  }
  if ( *(_BYTE *)(v1 + 9) == 122 )
  {
    do
      v7 = *v4++;
    while ( v7 < 0 );
    do
      v8 = *v4++;
    while ( v8 < 0 );
    if ( v5 == 1 )
    {
      ++v4;
    }
    else
    {
      do
        v9 = *v4++;
      while ( v9 < 0 );
    }
    v10 = (_BYTE *)(v1 + 10);
    do
      v11 = *v4++;
    while ( v11 < 0 );
    v12 = *(_BYTE *)(v1 + 10);
    if ( v12 != 82 )
    {
      do
      {
        while ( v12 == 80 )
        {
          v4 = (char *)read_encoded_value_with_base_0(*v4 & 0x7F, (int)(v4 + 1), &v13);
          v12 = *++v10;
          if ( *v10 == 82 )
            goto LABEL_17;
        }
        if ( v12 != 76 )
          goto LABEL_3;
        ++v4;
        v12 = *++v10;
      }
      while ( *v10 != 82 );
    }
LABEL_17:
    result = (unsigned __int8)*v4;
  }
  else
  {
LABEL_3:
    result = 0;
  }
  return result;
}

//----- (00411078) --------------------------------------------------------
signed int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, char *a2@<edx>)
{
  int v2; // edi@1
  char *v3; // ebx@1
  int v4; // eax@1
  char v5; // si@2
  int v6; // ebp@2
  int v7; // ecx@3
  signed int v8; // eax@5
  unsigned __int8 v9; // cl@7
  int v10; // ecx@10
  unsigned __int8 v11; // al@15
  int v12; // eax@18
  unsigned int v13; // edx@18
  int v15; // ST28_4@32
  int v16; // ST28_4@34
  int v17; // [sp+20h] [bp-3Ch]@5
  char v18; // [sp+27h] [bp-35h]@6
  int v19; // [sp+2Ch] [bp-30h]@2
  unsigned int v20; // [sp+3Ch] [bp-20h]@13

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)a2;
  if ( !*(_DWORD *)a2 )
    return 0;
  v5 = 0;
  v19 = 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = *((_DWORD *)v3 + 1);
    if ( !v7 )
      goto LABEL_23;
    if ( (char *)v6 != &v3[-v7 + 4] )
      break;
    v18 = v5;
    read_encoded_value_with_base_0(v5, (int)(v3 + 8), &v20);
LABEL_14:
    if ( v18 != -1 )
    {
      v11 = v5 & 7;
      if ( (v5 & 7) == 2 )
      {
        v13 = v20;
        v12 = (unsigned __int16)v20;
      }
      else
      {
        if ( v11 > 2u )
        {
          if ( v11 > 4u )
            goto LABEL_29;
        }
        else if ( v11 )
        {
          goto LABEL_29;
        }
        v12 = v20;
        v13 = v20;
      }
      if ( v12 )
      {
        ++v19;
        if ( v13 < *(_DWORD *)v2 )
          *(_DWORD *)v2 = v13;
      }
    }
    v4 = *(_DWORD *)v3;
LABEL_23:
    v3 += v4 + 4;
    v4 = *(_DWORD *)v3;
    if ( !*(_DWORD *)v3 )
      return v19;
  }
  v17 = (int)&v3[-v7 + 4];
  v8 = get_cie_encoding(v17);
  v5 = v8;
  if ( v8 != 255 )
  {
    v18 = v8;
    if ( (_BYTE)v8 != -1 )
    {
      v9 = v8 & 0x70;
      if ( (v8 & 0x70) == 32 )
      {
        v16 = *(_DWORD *)(v2 + 4);
      }
      else if ( v9 > 0x20u )
      {
        if ( v9 == 48 )
        {
          v15 = *(_DWORD *)(v2 + 8);
        }
        else if ( v9 != 80 )
        {
          goto LABEL_29;
        }
      }
      else if ( v9 && v9 != 16 )
      {
LABEL_29:
        abort();
      }
    }
    v10 = *(_DWORD *)(v2 + 16);
    if ( (*(_WORD *)(v2 + 16) & 0x7F8) == 2040 )
    {
      *(_WORD *)(v2 + 16) = 8 * (unsigned __int8)v8 | v10 & 0xF807;
      v6 = v17;
    }
    else if ( v8 == (unsigned __int8)((unsigned __int16)v10 >> 3) )
    {
      v6 = v17;
    }
    else
    {
      *(_BYTE *)(v2 + 16) |= 4u;
      v6 = v17;
    }
    read_encoded_value_with_base_0(v8, (int)(v3 + 8), &v20);
    goto LABEL_14;
  }
  return -1;
}

//----- (0041123C) --------------------------------------------------------
int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, char *a3@<ecx>)
{
  int v3; // edi@1
  char *v4; // ebx@1
  __int16 v5; // dx@1
  unsigned __int8 v6; // al@2
  int result; // eax@8
  signed int v8; // esi@9
  int v9; // edx@10
  int v10; // ebp@12
  signed int v11; // eax@13
  unsigned __int8 v12; // al@14
  int v13; // eax@20
  int v14; // edx@21
  unsigned __int8 v15; // al@26
  int v16; // eax@29
  int v17; // ST18_4@35
  int v18; // ST18_4@36
  int v19; // ST18_4@43
  int v20; // ST18_4@44
  int v21; // [sp+14h] [bp-38h]@9
  int *v22; // [sp+1Ch] [bp-30h]@1
  int v23; // [sp+2Ch] [bp-20h]@25

  v3 = a1;
  v22 = a2;
  v4 = a3;
  v5 = (unsigned __int16)*(_DWORD *)(a1 + 16) >> 3;
  if ( (_BYTE)v5 != -1 )
  {
    v6 = v5 & 0x70;
    if ( (v5 & 0x70) == 32 )
    {
      v18 = *(_DWORD *)(v3 + 4);
    }
    else if ( v6 <= 0x20u )
    {
      if ( v6 && v6 != 16 )
        abort();
    }
    else if ( v6 == 48 )
    {
      v17 = *(_DWORD *)(v3 + 8);
    }
    else if ( v6 != 80 )
    {
LABEL_6:
      abort();
    }
  }
  result = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 )
  {
    v8 = (unsigned __int8)v5;
    v21 = 0;
    while ( 1 )
    {
      v9 = *((_DWORD *)v4 + 1);
      if ( v9 )
        break;
LABEL_23:
      v4 += result + 4;
      result = *(_DWORD *)v4;
      if ( !*(_DWORD *)v4 )
        return result;
    }
    if ( *(_BYTE *)(v3 + 16) & 4 )
    {
      v10 = (int)&v4[-v9 + 4];
      if ( v21 != v10 )
      {
        v11 = get_cie_encoding((int)&v4[-v9 + 4]);
        v8 = v11;
        if ( (_BYTE)v11 != -1 )
        {
          v12 = v11 & 0x70;
          if ( v12 == 32 )
          {
            v20 = *(_DWORD *)(v3 + 4);
          }
          else if ( v12 > 0x20u )
          {
            if ( v12 == 48 )
            {
              v19 = *(_DWORD *)(v3 + 8);
            }
            else if ( v12 != 80 )
            {
              abort();
            }
          }
          else if ( v12 && v12 != 16 )
          {
            goto LABEL_6;
          }
        }
        v21 = v10;
      }
    }
    if ( v8 )
    {
      read_encoded_value_with_base_0(v8, (int)(v4 + 8), &v23);
      if ( (_BYTE)v8 == -1 )
        goto LABEL_22;
      v15 = v8 & 7;
      if ( (v8 & 7) == 2 )
      {
        v16 = (unsigned __int16)v23;
      }
      else
      {
        if ( v15 > 2u )
        {
          if ( v15 > 4u )
            goto LABEL_6;
        }
        else if ( v15 )
        {
          goto LABEL_6;
        }
        v16 = v23;
      }
      if ( !v16 )
        goto LABEL_22;
    }
    else if ( !*((_DWORD *)v4 + 2) )
    {
LABEL_22:
      result = *(_DWORD *)v4;
      goto LABEL_23;
    }
    v13 = *v22;
    if ( *v22 )
    {
      v14 = *(_DWORD *)(v13 + 4);
      *(_DWORD *)(v13 + 4 * v14 + 8) = v4;
      *(_DWORD *)(v13 + 4) = v14 + 1;
    }
    goto LABEL_22;
  }
  return result;
}

//----- (004113DC) --------------------------------------------------------
int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  int v4; // ebx@1
  __int16 v5; // ax@1
  signed int v6; // esi@1
  unsigned __int8 v7; // al@2
  int v8; // eax@8
  int v9; // edx@9
  int v10; // ebp@11
  signed int v11; // eax@12
  unsigned __int8 v12; // al@13
  int v13; // eax@18
  unsigned int v14; // edx@18
  int v16; // eax@24
  unsigned __int8 v17; // al@25
  int v18; // edx@28
  int v19; // ST20_4@36
  int v20; // ST20_4@37
  int v21; // edx@38
  int v22; // ST20_4@39
  int v23; // [sp+1Ch] [bp-40h]@8
  int v24; // [sp+24h] [bp-38h]@1
  int v25; // [sp+38h] [bp-24h]@18
  unsigned int v26; // [sp+3Ch] [bp-20h]@18

  v3 = a1;
  v4 = a2;
  v24 = a3;
  v5 = (unsigned __int16)*(_DWORD *)(a1 + 16) >> 3;
  v6 = (unsigned __int8)v5;
  if ( (_BYTE)v5 != -1 )
  {
    v7 = v5 & 0x70;
    if ( v7 == 32 )
    {
      v22 = *(_DWORD *)(v3 + 4);
    }
    else if ( v7 <= 0x20u )
    {
      if ( v7 && v7 != 16 )
        abort();
    }
    else if ( v7 == 48 )
    {
      v21 = *(_DWORD *)(v3 + 8);
    }
    else if ( v7 != 80 )
    {
LABEL_6:
      abort();
    }
  }
  v8 = *(_DWORD *)v4;
  v23 = 0;
  if ( *(_DWORD *)v4 )
  {
    while ( 1 )
    {
      v9 = *(_DWORD *)(v4 + 4);
      if ( v9 )
        break;
LABEL_21:
      v4 += v8 + 4;
      v8 = *(_DWORD *)v4;
      if ( !*(_DWORD *)v4 )
        return 0;
    }
    if ( *(_BYTE *)(v3 + 16) & 4 )
    {
      v10 = v4 + 4 - v9;
      if ( v23 != v10 )
      {
        v11 = get_cie_encoding(v4 + 4 - v9);
        v6 = v11;
        if ( (_BYTE)v11 != -1 )
        {
          v12 = v11 & 0x70;
          if ( v12 == 32 )
          {
            v19 = *(_DWORD *)(v3 + 4);
          }
          else if ( v12 > 0x20u )
          {
            if ( v12 == 48 )
            {
              v20 = *(_DWORD *)(v3 + 8);
            }
            else if ( v12 != 80 )
            {
              abort();
            }
          }
          else if ( v12 && v12 != 16 )
          {
            abort();
          }
        }
        v23 = v10;
      }
    }
    if ( v6 )
    {
      v16 = read_encoded_value_with_base_0(v6, v4 + 8, &v25);
      read_encoded_value_with_base_0(v6 & 0xF, v16, &v26);
      if ( (_BYTE)v6 == -1 )
        goto LABEL_20;
      v17 = v6 & 7;
      if ( (v6 & 7) == 2 )
      {
        v13 = v25;
        v18 = (unsigned __int16)v25;
      }
      else
      {
        if ( v17 > 2u )
        {
          if ( v17 > 4u )
            abort();
        }
        else if ( v17 )
        {
          goto LABEL_6;
        }
        v18 = v25;
        v13 = v25;
      }
      if ( !v18 )
        goto LABEL_20;
      v14 = v26;
    }
    else
    {
      v13 = *(_DWORD *)(v4 + 8);
      v25 = v13;
      v14 = *(_DWORD *)(v4 + 12);
      v26 = *(_DWORD *)(v4 + 12);
      if ( !v13 )
      {
LABEL_20:
        v8 = *(_DWORD *)v4;
        goto LABEL_21;
      }
    }
    if ( v24 - v13 < v14 )
      return v4;
    goto LABEL_20;
  }
  return 0;
}

//----- (004115B4) --------------------------------------------------------
int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  int v2; // edx@1
  char v3; // al@1
  int v4; // eax@3
  int v5; // ebp@4
  unsigned int v6; // esi@4
  unsigned int i; // eax@4
  unsigned int j; // edx@6
  unsigned int v9; // edx@9
  int v10; // ebx@9
  unsigned int v11; // ecx@9
  unsigned int v12; // esi@14
  char v13; // al@14
  char v14; // di@14
  unsigned __int8 v15; // dl@15
  int v16; // eax@19
  unsigned int v17; // ecx@21
  int result; // eax@24
  int v19; // ecx@25
  char **v20; // ebx@27
  char *v21; // edx@27
  signed int v22; // esi@28
  signed int v23; // eax@30
  int *v24; // esi@35
  int v25; // edx@35
  signed int v26; // eax@40
  _DWORD *v27; // eax@44
  int v28; // esi@44
  _DWORD *v29; // eax@45
  char **v30; // ebx@48
  char *v31; // ecx@48
  __int16 v32; // ax@63
  unsigned __int8 v33; // dl@64
  unsigned int v34; // edi@68
  unsigned int v35; // ebp@69
  unsigned int v36; // esi@73
  int v37; // eax@73
  int v38; // edx@75
  int v39; // edx@76
  int v40; // edi@79
  int *v41; // ebx@81
  int v42; // eax@81
  void *v43; // esi@81
  int v44; // ebp@81
  int v45; // eax@85
  int v46; // ebp@83
  int v47; // ebx@83
  void *v48; // eax@83
  int v49; // edx@90
  int v50; // eax@92
  int v51; // ecx@92
  int v52; // esi@94
  int v53; // edx@94
  int v54; // ebp@95
  int v55; // edi@96
  int v56; // ebx@99
  int v57; // eax@103
  int v58; // edx@106
  int v59; // ST28_4@109
  int v60; // [sp+18h] [bp-44h]@1
  char v61; // [sp+18h] [bp-44h]@69
  unsigned int v62; // [sp+1Ch] [bp-40h]@12
  int (__cdecl *v63)(int, int, int); // [sp+1Ch] [bp-40h]@54
  int v64; // [sp+1Ch] [bp-40h]@63
  int v65; // [sp+20h] [bp-3Ch]@12
  char v66; // [sp+20h] [bp-3Ch]@63
  int v67; // [sp+20h] [bp-3Ch]@81
  int v68; // [sp+20h] [bp-3Ch]@95
  unsigned int v69; // [sp+24h] [bp-38h]@1
  unsigned int v70; // [sp+28h] [bp-34h]@13
  int v71; // [sp+28h] [bp-34h]@25
  int v72; // [sp+28h] [bp-34h]@94
  void *v73; // [sp+2Ch] [bp-30h]@80
  _DWORD *v74; // [sp+2Ch] [bp-30h]@94
  unsigned int v75; // [sp+30h] [bp-2Ch]@19
  int v76; // [sp+34h] [bp-28h]@19
  _DWORD *v77; // [sp+38h] [bp-24h]@44
  _DWORD *v78; // [sp+3Ch] [bp-20h]@45

  v60 = a1;
  v69 = a2;
  v2 = a1;
  v3 = *(_BYTE *)(a1 + 16);
  if ( v3 & 1 )
  {
LABEL_2:
    if ( v3 & 4 )
    {
      v65 = *(_DWORD *)(v60 + 12);
      v62 = 0;
      if ( *(_DWORD *)(v65 + 4) )
      {
        v70 = *(_DWORD *)(v65 + 4);
        do
        {
          v12 = (v62 + v70) >> 1;
          v10 = *(_DWORD *)(v65 + 4 * v12 + 8);
          v13 = get_cie_encoding(v10 + 4 - *(_DWORD *)(v10 + 4));
          v14 = v13;
          if ( v13 != -1 )
          {
            v15 = v13 & 0x70;
            if ( (v13 & 0x70) == 32 )
            {
              v38 = *(_DWORD *)(v60 + 4);
            }
            else if ( v15 > 0x20u )
            {
              if ( v15 == 48 )
              {
                v39 = *(_DWORD *)(v60 + 8);
              }
              else if ( v15 != 80 )
              {
                goto LABEL_57;
              }
            }
            else if ( v15 && v15 != 16 )
            {
              goto LABEL_57;
            }
          }
          v16 = read_encoded_value_with_base_0(v13, v10 + 8, &v75);
          read_encoded_value_with_base_0(v14 & 0xF, v16, &v76);
          if ( v69 < v75 )
          {
            v70 = (v62 + v70) >> 1;
            v17 = v12;
          }
          else
          {
            if ( v69 < v76 + v75 )
              return v10;
            v62 = v12 + 1;
            v17 = v70;
          }
        }
        while ( v62 < v17 );
      }
      return 0;
    }
    v4 = *(_DWORD *)(v60 + 16);
    if ( !(v4 & 0x7F8) )
    {
      v5 = *(_DWORD *)(v60 + 12);
      v6 = *(_DWORD *)(v5 + 4);
      for ( i = 0; i < v6; i = v9 + 1 )
      {
        for ( j = v6 + i; ; j = i + v9 )
        {
          v9 = j >> 1;
          v10 = *(_DWORD *)(v5 + 4 * v9 + 8);
          v11 = *(_DWORD *)(v10 + 8);
          if ( v69 >= v11 )
            break;
          v6 = v9;
          if ( i >= v9 )
            return 0;
        }
        if ( v69 < *(_DWORD *)(v10 + 12) + v11 )
          return v10;
      }
      return 0;
    }
    v64 = *(_DWORD *)(v60 + 12);
    v32 = (unsigned __int16)v4 >> 3;
    v66 = v32;
    if ( (_BYTE)v32 == -1 )
    {
LABEL_68:
      v34 = *(_DWORD *)(v64 + 4);
      if ( v34 )
      {
        v61 = v32 & 0xF;
        v35 = 0;
        do
        {
          v36 = (v34 + v35) >> 1;
          v10 = *(_DWORD *)(v64 + 4 * v36 + 8);
          v37 = read_encoded_value_with_base_0(v66, v10 + 8, &v75);
          read_encoded_value_with_base_0(v61, v37, &v76);
          if ( v69 >= v75 )
          {
            if ( v69 < v76 + v75 )
              return v10;
            v35 = v36 + 1;
          }
          else
          {
            v34 = (v34 + v35) >> 1;
          }
        }
        while ( v35 < v34 );
      }
      return 0;
    }
    v33 = v32 & 0x70;
    if ( (v32 & 0x70) == 32 )
    {
      v58 = *(_DWORD *)(v60 + 4);
      goto LABEL_68;
    }
    if ( v33 > 0x20u )
    {
      if ( v33 == 48 )
      {
        v59 = *(_DWORD *)(v60 + 8);
        goto LABEL_68;
      }
      if ( v33 == 80 )
        goto LABEL_68;
    }
    else if ( !v33 || v33 == 16 )
    {
      goto LABEL_68;
    }
LABEL_57:
    abort();
  }
  v19 = *(_DWORD *)(v2 + 16);
  v71 = *(_DWORD *)(v2 + 16) >> 11;
  if ( v71 )
    goto LABEL_115;
  if ( v3 & 2 )
  {
    v20 = *(char ***)(v2 + 12);
    v21 = *v20;
    if ( !*v20 )
    {
      *(_DWORD *)(v60 + 16) = v19 & 0x7FF;
      goto LABEL_32;
    }
    v22 = 0;
    do
    {
      v23 = classify_object_over_fdes(v60, v21);
      if ( v23 == -1 )
        goto LABEL_31;
      v22 += v23;
      ++v20;
      v21 = *v20;
    }
    while ( *v20 );
    v71 = v22;
    v26 = v22;
  }
  else
  {
    v26 = classify_object_over_fdes(v60, *(char **)(v60 + 12));
    v71 = v26;
    if ( v26 == -1 )
    {
LABEL_31:
      *(_DWORD *)(v60 + 16) = 0;
      *(_WORD *)(v60 + 16) = 2040;
      *(_DWORD *)(v60 + 12) = &terminator_34344;
      goto LABEL_32;
    }
  }
  if ( v71 == (v26 & 0x1FFFFF) )
    *(_DWORD *)(v60 + 16) = (v71 << 11) | *(_DWORD *)(v60 + 16) & 0x7FF;
  else
    *(_DWORD *)(v60 + 16) &= 0x7FFu;
  if ( v71 )
  {
LABEL_115:
    v27 = malloc(4 * v71 + 8);
    v28 = (int)v27;
    v77 = v27;
    if ( !v27 )
      goto LABEL_32;
    v27[1] = 0;
    v29 = malloc(4 * v71 + 8);
    v78 = v29;
    if ( v29 )
      v29[1] = 0;
    if ( *(_BYTE *)(v60 + 16) & 2 )
    {
      v30 = *(char ***)(v60 + 12);
      v31 = *v30;
      if ( !*v30 )
        goto LABEL_51;
      do
      {
        add_fdes(v60, (int *)&v77, v31);
        ++v30;
        v31 = *v30;
      }
      while ( *v30 );
    }
    else
    {
      add_fdes(v60, (int *)&v77, *(char **)(v60 + 12));
    }
    v28 = (int)v77;
    if ( !v77 )
    {
LABEL_52:
      if ( *(_BYTE *)(v60 + 16) & 4 )
      {
        v63 = fde_mixed_encoding_compare;
      }
      else if ( *(_DWORD *)(v60 + 16) & 0x7F8 )
      {
        v63 = fde_single_encoding_compare;
      }
      else
      {
        v63 = fde_unencoded_compare;
      }
      v40 = (int)v78;
      if ( v78 )
      {
        v73 = *(void **)(v28 + 4);
        if ( v73 )
        {
          v41 = (int *)&marker_34238;
          v67 = v28 + 8;
          v42 = v28;
          v43 = 0;
          v44 = v42;
LABEL_82:
          while ( 1 )
          {
            *(_DWORD *)(v40 + 4 * (_DWORD)v43 + 8) = v41;
            v41 = (int *)(v44 + 4 * (_DWORD)v43 + 8);
            v43 = (char *)v43 + 1;
            if ( v43 == v73 )
              break;
            while ( (_UNKNOWN *)v41 != &marker_34238 )
            {
              if ( v63(v60, *(_DWORD *)(v44 + 4 * (_DWORD)v43 + 8), *v41) >= 0 )
                goto LABEL_82;
              v45 = ((signed int)v41 - v67) >> 2;
              v41 = *(int **)(v40 + 4 * v45 + 8);
              *(_DWORD *)(v40 + 4 * v45 + 8) = 0;
            }
            v41 = (int *)&marker_34238;
          }
          v28 = v44;
          v46 = 0;
          v47 = 0;
          v48 = 0;
          do
          {
            v49 = *(_DWORD *)(v28 + 4 * (_DWORD)v48 + 8);
            if ( *(_DWORD *)(v40 + 4 * (_DWORD)v48 + 8) )
              *(_DWORD *)(v28 + 4 * v47++ + 8) = v49;
            else
              *(_DWORD *)(v40 + 4 * v46++ + 8) = v49;
            v48 = (char *)v48 + 1;
          }
          while ( v48 != v73 );
          v50 = (int)v77;
          v51 = (int)v78;
        }
        else
        {
          v51 = (int)v78;
          v50 = v28;
          v46 = 0;
          v47 = 0;
        }
        *(_DWORD *)(v28 + 4) = v47;
        *(_DWORD *)(v40 + 4) = v46;
        if ( v71 != *(_DWORD *)(v50 + 4) + *(_DWORD *)(v51 + 4) )
          goto LABEL_57;
        frame_heapsort(v60, v63, v51);
        v74 = v78;
        v52 = (int)v77;
        v53 = v78[1];
        v72 = v53;
        if ( v53 )
        {
          v54 = v77[1];
          v68 = (int)&v77[v53];
          do
          {
            v55 = v74[--v72 + 2];
            if ( v54 )
            {
              while ( 1 )
              {
                v56 = v54 - 1;
                if ( v63(v60, *(_DWORD *)(v52 + 4 * (v54 - 1) + 8), v55) <= 0 )
                  break;
                *(_DWORD *)(v68 + 4 * v56 + 8) = *(_DWORD *)(v52 + 4 * v56 + 8);
                --v54;
                if ( !v56 )
                  goto LABEL_104;
              }
            }
            else
            {
LABEL_104:
              v54 = 0;
            }
            *(_DWORD *)(v52 + 4 * (v54 + v72) + 8) = v55;
            v68 -= 4;
          }
          while ( v72 );
          *(_DWORD *)(v52 + 4) += v74[1];
          v74 = v78;
        }
        free(v74);
      }
      else
      {
        frame_heapsort(v60, v63, v28);
      }
      v57 = (int)v77;
      *v77 = *(_DWORD *)(v60 + 12);
      *(_DWORD *)(v60 + 12) = v57;
      *(_BYTE *)(v60 + 16) |= 1u;
      goto LABEL_32;
    }
LABEL_51:
    if ( v71 != *(_DWORD *)(v28 + 4) )
      goto LABEL_57;
    goto LABEL_52;
  }
LABEL_32:
  if ( *(_DWORD *)v60 > v69 )
    return 0;
  v3 = *(_BYTE *)(v60 + 16);
  if ( v3 & 1 )
    goto LABEL_2;
  if ( !(v3 & 2) )
    return linear_search_fdes(v60, *(_DWORD *)(v60 + 12), v69);
  v24 = *(int **)(v60 + 12);
  v25 = *v24;
  if ( !*v24 )
    return 0;
  while ( 1 )
  {
    result = linear_search_fdes(v60, v25, v69);
    if ( result )
      break;
    ++v24;
    v25 = *v24;
    if ( !*v24 )
      return 0;
  }
  return result;
}

//----- (00411C0C) --------------------------------------------------------
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3)
{
  char v3; // al@1
  unsigned __int8 v4; // dl@2
  char v5; // al@8
  unsigned __int8 v6; // dl@9
  int result; // eax@13
  int v8; // edx@18
  int v9; // edx@19
  int v10; // edx@24
  int v11; // edx@25
  unsigned int v12; // [sp+18h] [bp-14h]@8
  unsigned int v13; // [sp+1Ch] [bp-10h]@12

  v3 = get_cie_encoding(a2 + 4 - *(_DWORD *)(a2 + 4));
  if ( v3 != -1 )
  {
    v4 = v3 & 0x70;
    if ( (v3 & 0x70) == 32 )
    {
      v9 = *(_DWORD *)(a1 + 4);
    }
    else if ( v4 <= 0x20u )
    {
      if ( v4 && v4 != 16 )
        abort();
    }
    else if ( v4 == 48 )
    {
      v8 = *(_DWORD *)(a1 + 8);
    }
    else if ( v4 != 80 )
    {
      goto LABEL_6;
    }
  }
  read_encoded_value_with_base_0(v3, a2 + 8, &v12);
  v5 = get_cie_encoding(a3 + 4 - *(_DWORD *)(a3 + 4));
  if ( v5 != -1 )
  {
    v6 = v5 & 0x70;
    if ( (v5 & 0x70) == 32 )
    {
      v11 = *(_DWORD *)(a1 + 4);
    }
    else if ( v6 > 0x20u )
    {
      if ( v6 == 48 )
      {
        v10 = *(_DWORD *)(a1 + 8);
      }
      else if ( v6 != 80 )
      {
        abort();
      }
    }
    else if ( v6 && v6 != 16 )
    {
LABEL_6:
      abort();
    }
  }
  read_encoded_value_with_base_0(v5, a3 + 8, &v13);
  if ( v12 > v13 )
    result = 1;
  else
    result = -(v12 < v13);
  return result;
}

//----- (00411D20) --------------------------------------------------------
int __cdecl __register_frame_info_bases(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = (int)a1;
  if ( !a1 || !*a1 )
    return result;
  *(_DWORD *)a2 = -1;
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = a4;
  *(_DWORD *)(a2 + 12) = a1;
  *(_DWORD *)(a2 + 16) = 0;
  *(_WORD *)(a2 + 16) = 2040;
  if ( !_CRT_MT )
    goto LABEL_13;
  if ( once_34123 )
    goto LABEL_6;
  if ( InterlockedIncrement(&dword_417020) )
  {
    while ( !once_34123 )
      Sleep(0);
    if ( _CRT_MT )
      goto LABEL_6;
LABEL_13:
    result = unseen_objects;
    *(_DWORD *)(a2 + 20) = unseen_objects;
    unseen_objects = a2;
    return result;
  }
  object_mutex = -1;
  hSemaphore = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  once_34123 = 1;
  if ( !_CRT_MT )
    goto LABEL_13;
LABEL_6:
  if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
    InterlockedDecrement(&object_mutex);
  *(_DWORD *)(a2 + 20) = unseen_objects;
  unseen_objects = a2;
  result = _CRT_MT;
  if ( _CRT_MT )
  {
    result = InterlockedDecrement(&object_mutex);
    if ( result >= 0 )
      result = ReleaseSemaphore(hSemaphore, 1, 0);
  }
  return result;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;

//----- (00411E9C) --------------------------------------------------------
int __cdecl __register_frame_info(_DWORD *a1, int a2)
{
  int result; // eax@1

  result = (int)a1;
  if ( !a1 || !*a1 )
    return result;
  *(_DWORD *)a2 = -1;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = a1;
  *(_DWORD *)(a2 + 16) = 0;
  *(_WORD *)(a2 + 16) = 2040;
  if ( !_CRT_MT )
    goto LABEL_13;
  if ( once_34123 )
    goto LABEL_6;
  if ( InterlockedIncrement(&dword_417020) )
  {
    while ( !once_34123 )
      Sleep(0);
    if ( _CRT_MT )
      goto LABEL_6;
LABEL_13:
    result = unseen_objects;
    *(_DWORD *)(a2 + 20) = unseen_objects;
    unseen_objects = a2;
    return result;
  }
  object_mutex = -1;
  hSemaphore = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  once_34123 = 1;
  if ( !_CRT_MT )
    goto LABEL_13;
LABEL_6:
  if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
    InterlockedDecrement(&object_mutex);
  result = unseen_objects;
  *(_DWORD *)(a2 + 20) = unseen_objects;
  unseen_objects = a2;
  if ( _CRT_MT )
  {
    result = InterlockedDecrement(&object_mutex);
    if ( result >= 0 )
      result = ReleaseSemaphore(hSemaphore, 1, 0);
  }
  return result;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;

//----- (0041201C) --------------------------------------------------------
int __cdecl __register_frame(int *a1)
{
  int result; // eax@1
  _DWORD *v2; // ebx@3

  result = *a1;
  if ( *a1 )
  {
    v2 = malloc(0x18u);
    *v2 = -1;
    v2[1] = 0;
    v2[2] = 0;
    v2[3] = a1;
    v2[4] = 0;
    *((_WORD *)v2 + 8) = 2040;
    if ( !_CRT_MT )
      goto LABEL_20;
    if ( once_34123 )
      goto LABEL_21;
    if ( InterlockedIncrement(&dword_417020) )
    {
      while ( !once_34123 )
        Sleep(0);
    }
    else
    {
      object_mutex = -1;
      hSemaphore = CreateSemaphoreA(0, 0, 0xFFFF, 0);
      once_34123 = 1;
    }
    if ( _CRT_MT )
    {
LABEL_21:
      if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
        InterlockedDecrement(&object_mutex);
      result = unseen_objects;
      v2[5] = unseen_objects;
      unseen_objects = (int)v2;
      if ( _CRT_MT )
      {
        result = InterlockedDecrement(&object_mutex);
        if ( result >= 0 )
          result = ReleaseSemaphore(hSemaphore, 1, 0);
      }
    }
    else
    {
LABEL_20:
      result = unseen_objects;
      v2[5] = unseen_objects;
      unseen_objects = (int)v2;
    }
  }
  return result;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;

//----- (004121A4) --------------------------------------------------------
int __cdecl __register_frame_info_table_bases(int a1, int a2, int a3, int a4)
{
  int result; // eax@4

  *(_DWORD *)a2 = -1;
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = a4;
  *(_DWORD *)(a2 + 12) = a1;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)(a2 + 16) = 2;
  *(_WORD *)(a2 + 16) |= 0x7F8u;
  if ( !_CRT_MT )
    goto LABEL_9;
  if ( once_34123 )
    goto LABEL_3;
  if ( InterlockedIncrement(&dword_417020) )
  {
    while ( !once_34123 )
      Sleep(0);
    if ( _CRT_MT )
      goto LABEL_3;
LABEL_9:
    result = unseen_objects;
    *(_DWORD *)(a2 + 20) = unseen_objects;
    unseen_objects = a2;
    return result;
  }
  __gthread_mutex_init_function_constprop_9();
  once_34123 = 1;
  if ( !_CRT_MT )
    goto LABEL_9;
LABEL_3:
  if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
    InterlockedDecrement(&object_mutex);
  result = unseen_objects;
  *(_DWORD *)(a2 + 20) = unseen_objects;
  unseen_objects = a2;
  if ( _CRT_MT )
  {
    result = InterlockedDecrement(&object_mutex);
    if ( result >= 0 )
      result = ReleaseSemaphore(hSemaphore, 1, 0);
  }
  return result;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;

//----- (004122F0) --------------------------------------------------------
int __cdecl __register_frame_info_table(int a1, int a2)
{
  int result; // eax@4

  *(_DWORD *)a2 = -1;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = a1;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)(a2 + 16) = 2;
  *(_WORD *)(a2 + 16) |= 0x7F8u;
  if ( !_CRT_MT )
    goto LABEL_9;
  if ( once_34123 )
    goto LABEL_3;
  if ( InterlockedIncrement(&dword_417020) )
  {
    while ( !once_34123 )
      Sleep(0);
    if ( _CRT_MT )
      goto LABEL_3;
LABEL_9:
    result = unseen_objects;
    *(_DWORD *)(a2 + 20) = unseen_objects;
    unseen_objects = a2;
    return result;
  }
  __gthread_mutex_init_function_constprop_9();
  once_34123 = 1;
  if ( !_CRT_MT )
    goto LABEL_9;
LABEL_3:
  if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
    InterlockedDecrement(&object_mutex);
  result = unseen_objects;
  *(_DWORD *)(a2 + 20) = unseen_objects;
  unseen_objects = a2;
  if ( _CRT_MT )
  {
    result = InterlockedDecrement(&object_mutex);
    if ( result >= 0 )
      result = ReleaseSemaphore(hSemaphore, 1, 0);
  }
  return result;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;

//----- (0041243C) --------------------------------------------------------
int __cdecl __register_frame_table(int a1)
{
  void *v1; // eax@1

  v1 = malloc(0x18u);
  return __register_frame_info_table_bases(a1, (int)v1, 0, 0);
}

//----- (00412470) --------------------------------------------------------
int __cdecl __deregister_frame_info_bases(_DWORD *a1)
{
  int v1; // eax@6
  int v3; // ebx@8
  int *v4; // eax@8

  if ( !a1 || !*a1 )
    return 0;
  if ( _CRT_MT )
  {
    if ( once_34123 )
      goto LABEL_38;
    if ( InterlockedIncrement(&dword_417020) )
    {
      while ( !once_34123 )
        Sleep(0);
    }
    else
    {
      __gthread_mutex_init_function_constprop_9();
      once_34123 = 1;
    }
    if ( _CRT_MT )
    {
LABEL_38:
      if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
        InterlockedDecrement(&object_mutex);
    }
  }
  v1 = unseen_objects;
  if ( unseen_objects )
  {
    if ( *(_DWORD **)(unseen_objects + 12) == a1 )
    {
      v3 = unseen_objects;
      v4 = &unseen_objects;
LABEL_18:
      *v4 = *(_DWORD *)(v3 + 20);
      goto LABEL_19;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(v1 + 20);
      if ( !v3 )
        break;
      if ( *(_DWORD **)(v3 + 12) == a1 )
      {
        v4 = (int *)(v1 + 20);
        goto LABEL_18;
      }
      v1 = *(_DWORD *)(v1 + 20);
    }
  }
  v3 = seen_objects;
  if ( seen_objects )
  {
    v4 = &seen_objects;
    do
    {
      if ( *(_BYTE *)(v3 + 16) & 1 )
      {
        if ( **(_DWORD ***)(v3 + 12) == a1 )
        {
          *v4 = *(_DWORD *)(v3 + 20);
          free(*(void **)(v3 + 12));
          break;
        }
      }
      else if ( *(_DWORD **)(v3 + 12) == a1 )
      {
        goto LABEL_18;
      }
      v4 = (int *)(v3 + 20);
      v3 = *(_DWORD *)(v3 + 20);
    }
    while ( v3 );
  }
LABEL_19:
  if ( _CRT_MT && InterlockedDecrement(&object_mutex) >= 0 )
    ReleaseSemaphore(hSemaphore, 1, 0);
  if ( !v3 )
    abort();
  return v3;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;
// 55B978: using guessed type int seen_objects;

//----- (00412634) --------------------------------------------------------
void __cdecl __deregister_frame(void *a1)
{
  void *v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    v1 = (void *)__deregister_frame_info_bases(a1);
    free(v1);
  }
}

//----- (0041265C) --------------------------------------------------------
int __cdecl _Unwind_Find_FDE(unsigned int a1, int a2)
{
  int v2; // ebp@4
  int v3; // esi@10
  int v4; // ecx@10
  int *v5; // edx@14
  __int16 v6; // dx@18
  char v7; // al@20
  unsigned __int8 v8; // dl@21
  int v10; // edx@45
  int v11; // edx@46
  int v12; // [sp+1Ch] [bp-20h]@27

  if ( _CRT_MT )
  {
    if ( once_34123 )
      goto LABEL_50;
    if ( InterlockedIncrement(&dword_417020) )
    {
      while ( !once_34123 )
        Sleep(0);
    }
    else
    {
      __gthread_mutex_init_function_constprop_9();
      once_34123 = 1;
    }
    if ( _CRT_MT )
    {
LABEL_50:
      if ( InterlockedIncrement(&object_mutex) && WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
        InterlockedDecrement(&object_mutex);
    }
  }
  v2 = seen_objects;
  if ( seen_objects )
  {
    if ( a1 < *(_DWORD *)seen_objects )
    {
      do
      {
        v2 = *(_DWORD *)(v2 + 20);
        if ( !v2 )
          goto LABEL_9;
      }
      while ( *(_DWORD *)v2 > a1 );
    }
    v3 = search_object(v2, a1);
    if ( v3 )
    {
      if ( !_CRT_MT )
        goto LABEL_17;
      goto LABEL_31;
    }
  }
LABEL_9:
  while ( 1 )
  {
    v2 = unseen_objects;
    if ( !unseen_objects )
      break;
    unseen_objects = *(_DWORD *)(unseen_objects + 20);
    v3 = search_object(v2, a1);
    v4 = seen_objects;
    if ( seen_objects && *(_DWORD *)v2 <= *(_DWORD *)seen_objects )
    {
      do
      {
        v5 = (int *)(v4 + 20);
        v4 = *(_DWORD *)(v4 + 20);
      }
      while ( v4 && *(_DWORD *)v4 >= *(_DWORD *)v2 );
      *(_DWORD *)(v2 + 20) = v4;
      *v5 = v2;
      if ( v3 )
        goto LABEL_16;
    }
    else
    {
      *(_DWORD *)(v2 + 20) = seen_objects;
      seen_objects = v2;
      if ( v3 )
        goto LABEL_16;
    }
  }
  v3 = 0;
LABEL_16:
  if ( _CRT_MT )
  {
LABEL_31:
    if ( InterlockedDecrement(&object_mutex) >= 0 )
      ReleaseSemaphore(hSemaphore, 1, 0);
  }
LABEL_17:
  if ( v3 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(v2 + 4);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v2 + 8);
    v6 = (unsigned __int16)*(_DWORD *)(v2 + 16) >> 3;
    if ( *(_BYTE *)(v2 + 16) & 4 )
      LOBYTE(v6) = get_cie_encoding(v3 + 4 - *(_DWORD *)(v3 + 4));
    v7 = v6;
    if ( (_BYTE)v6 != -1 )
    {
      v8 = v6 & 0x70;
      if ( v8 == 32 )
      {
        v11 = *(_DWORD *)(v2 + 4);
      }
      else if ( v8 <= 0x20u )
      {
        if ( v8 && v8 != 16 )
LABEL_25:
          abort();
      }
      else if ( v8 == 48 )
      {
        v10 = *(_DWORD *)(v2 + 8);
      }
      else if ( v8 != 80 )
      {
        goto LABEL_25;
      }
    }
    read_encoded_value_with_base_0(v7, v3 + 8, &v12);
    *(_DWORD *)(a2 + 8) = v12;
  }
  return v3;
}
// 41701C: using guessed type int once_34123;
// 55B920: using guessed type int _CRT_MT;
// 55B974: using guessed type int unseen_objects;
// 55B978: using guessed type int seen_objects;

//----- (004128C8) --------------------------------------------------------
signed int __cdecl __gthr_win32_once(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@4
  int v3; // ecx@5

  if ( a1 && a2 )
  {
    if ( !*(_DWORD *)a1 )
    {
      if ( InterlockedIncrement((LPLONG)(a1 + 4)) )
      {
        while ( !*(_DWORD *)a1 )
          Sleep(0);
      }
      else
      {
        a2(v3);
        *(_DWORD *)a1 = 1;
      }
    }
    result = 0;
  }
  else
  {
    result = 22;
  }
  return result;
}

//----- (00412930) --------------------------------------------------------
DWORD __cdecl __gthr_win32_key_create(int *a1, int a2)
{
  int v2; // eax@1
  DWORD result; // eax@2

  v2 = TlsAlloc();
  if ( v2 == -1 )
  {
    result = GetLastError();
  }
  else
  {
    *a1 = v2;
    result = __mingwthr_key_dtor(v2, a2);
  }
  return result;
}

//----- (00412960) --------------------------------------------------------
DWORD __cdecl __gthr_win32_key_delete(DWORD a1)
{
  DWORD result; // eax@2

  if ( TlsFree(a1) )
    result = 0;
  else
    result = GetLastError();
  return result;
}

//----- (00412984) --------------------------------------------------------
int __cdecl __gthr_win32_getspecific(DWORD a1)
{
  int (*v1)(void); // esi@1

  v1 = (int (*)(void))GetLastError();
  TlsGetValue(a1);
  SetLastError((DWORD)v1);
  return v1();
}

//----- (004129B4) --------------------------------------------------------
DWORD __cdecl __gthr_win32_setspecific(DWORD a1, LPVOID a2)
{
  DWORD result; // eax@2

  if ( TlsSetValue(a1, a2) )
    result = 0;
  else
    result = GetLastError();
  return result;
}

//----- (004129E0) --------------------------------------------------------
HANDLE __cdecl __gthr_win32_mutex_init_function(int a1)
{
  HANDLE result; // eax@1

  *(_DWORD *)a1 = -1;
  result = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (00412A20) --------------------------------------------------------
int __cdecl __gthr_win32_mutex_destroy(int a1)
{
  int (*v1)(void); // eax@1

  v1 = (int (*)(void))CloseHandle(*(HANDLE *)(a1 + 4));
  return v1();
}

//----- (00412A38) --------------------------------------------------------
int __cdecl __gthr_win32_mutex_lock(LPLONG a1)
{
  int result; // eax@2

  if ( InterlockedIncrement(a1) && WaitForSingleObject((HANDLE)a1[1], 0xFFFFFFFF) )
  {
    InterlockedDecrement(a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00412A84) --------------------------------------------------------
unsigned int __cdecl __gthr_win32_mutex_trylock(volatile signed __int32 *a1)
{
  return (unsigned int)~_InterlockedCompareExchange(a1, 0, -1) >> 31;
}

//----- (00412A9C) --------------------------------------------------------
int __cdecl __gthr_win32_mutex_unlock(LPLONG a1)
{
  int result; // eax@2

  if ( InterlockedDecrement(a1) < 0 )
    result = 0;
  else
    result = ReleaseSemaphore((HANDLE)a1[1], 1, 0) == 0;
  return result;
}

//----- (00412AE4) --------------------------------------------------------
HANDLE __cdecl __gthr_win32_recursive_mutex_init_function(int a1)
{
  HANDLE result; // eax@1

  *(_DWORD *)a1 = -1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  result = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (00412B30) --------------------------------------------------------
int __cdecl __gthr_win32_recursive_mutex_lock(LPLONG a1)
{
  DWORD v1; // esi@1
  int result; // eax@1

  v1 = GetCurrentThreadId();
  result = InterlockedIncrement(a1);
  if ( !result )
    goto LABEL_4;
  if ( a1[2] == v1 )
  {
    InterlockedDecrement(a1);
    ++a1[1];
    result = 0;
  }
  else
  {
    result = WaitForSingleObject((HANDLE)a1[3], 0xFFFFFFFF);
    if ( !result )
    {
LABEL_4:
      a1[1] = 1;
      a1[2] = v1;
      return result;
    }
    InterlockedDecrement(a1);
    result = 1;
  }
  return result;
}

//----- (00412BA4) --------------------------------------------------------
signed int __cdecl __gthr_win32_recursive_mutex_trylock(int a1)
{
  DWORD v1; // esi@1
  signed int result; // eax@3

  v1 = GetCurrentThreadId();
  if ( _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, -1) < 0 )
  {
    *(_DWORD *)(a1 + 4) = 1;
    *(_DWORD *)(a1 + 8) = v1;
    result = 0;
  }
  else if ( *(_DWORD *)(a1 + 8) == v1 )
  {
    ++*(_DWORD *)(a1 + 4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00412BEC) --------------------------------------------------------
int __cdecl __gthr_win32_recursive_mutex_unlock(LPLONG a1)
{
  bool v1; // zf@1
  int result; // eax@2

  v1 = a1[1]-- == 1;
  if ( v1 && (a1[2] = 0, InterlockedDecrement(a1) >= 0) )
    result = ReleaseSemaphore((HANDLE)a1[3], 1, 0) == 0;
  else
    result = 0;
  return result;
}

//----- (00412D30) --------------------------------------------------------
int moncontrol_part_0()
{
  int result; // eax@1

  result = profil(dword_417044, dword_417048, dword_417060, bss_0);
  _gmonparam = 0;
  return result;
}
// 417040: using guessed type int _gmonparam;

//----- (00412D70) --------------------------------------------------------
int __cdecl monstartup(int a1, int a2)
{
  unsigned int v2; // esi@1
  unsigned int v3; // esi@1
  unsigned int v4; // ebx@1
  signed int v5; // edx@1
  int v6; // ebp@2
  void *v7; // edi@3

  v2 = (a2 + 3) & 0xFFFFFFFC;
  dword_417064 = v2;
  v3 = v2 - (a1 & 0xFFFFFFFC);
  dword_417060 = a1 & 0xFFFFFFFC;
  v4 = v3 >> 1;
  dword_417068 = v3;
  v5 = 2 * v3 / 0x64;
  dword_417048 = v3 >> 1;
  dword_41706C = 2;
  dword_417050 = v3 >> 1;
  if ( v5 > 49 )
  {
    if ( v5 <= 65534 )
    {
      dword_41705C = 2 * v3 / 0x64;
      v6 = 12 * v5;
    }
    else
    {
      dword_41705C = 65534;
      v6 = 786408;
    }
  }
  else
  {
    dword_41705C = 50;
    v6 = 600;
  }
  dword_417058 = v6;
  v7 = malloc(v6 + 2 * v4);
  memset(v7, 0, v6 + 2 * v4);
  dword_417044 = (char *)v7 + v6;
  dword_417054 = (int)v7;
  dword_41704C = (int)v7 + v6 + v4;
  *((_WORD *)v7 + 4) = 0;
  if ( v3 > v4 )
    bss_0 = (signed int)((long double)(signed int)v4 / (long double)(signed int)v3 * 65536.0);
  else
    bss_0 = 0x10000;
  return moncontrol_part_0();
}
// 41704C: using guessed type int dword_41704C;
// 417050: using guessed type int dword_417050;
// 417054: using guessed type int dword_417054;
// 417058: using guessed type int dword_417058;
// 41705C: using guessed type int dword_41705C;
// 417064: using guessed type int dword_417064;
// 417068: using guessed type int dword_417068;
// 41706C: using guessed type int dword_41706C;

//----- (00412EC0) --------------------------------------------------------
int __cdecl moncontrol(int a1)
{
  int result; // eax@2

  if ( a1 )
  {
    result = moncontrol_part_0();
  }
  else
  {
    result = profil(0, 0, 0, 0);
    _gmonparam = 3;
  }
  return result;
}
// 417040: using guessed type int _gmonparam;

//----- (00412F10) --------------------------------------------------------
void __cdecl _mcleanup()
{
  int v0; // eax@3
  int v1; // esi@3
  int v2; // eax@5
  int v3; // edx@6
  int v4; // ebx@6
  int v5; // ebp@7
  int v6; // edx@7
  int v7; // eax@7
  int v8; // [sp+18h] [bp-54h]@4
  unsigned int v9; // [sp+1Ch] [bp-50h]@4
  int v10; // [sp+24h] [bp-48h]@7
  int v11; // [sp+28h] [bp-44h]@7
  int v12; // [sp+2Ch] [bp-40h]@7
  int v13; // [sp+30h] [bp-3Ch]@4
  int v14; // [sp+34h] [bp-38h]@4
  size_t v15; // [sp+38h] [bp-34h]@4
  int v16; // [sp+3Ch] [bp-30h]@4
  int v17; // [sp+40h] [bp-2Ch]@4

  if ( _gmonparam == 2 )
    write(2, "_mcleanup: tos overflow\n", 0x19u);
  moncontrol(0);
  v0 = open("gmon.out", 33537, 438);
  v1 = v0;
  if ( v0 < 0 )
  {
    perror("gmon.out");
  }
  else
  {
    v16 = 333945;
    v13 = dword_417060;
    v17 = 100;
    v14 = dword_417064;
    v15 = dword_417048 + 32;
    write(v0, &v13, 0x20u);
    write(v1, dword_417044, dword_417048);
    v8 = 0;
    v9 = (unsigned int)dword_417050 >> 1;
    if ( (unsigned int)dword_417050 >> 1 )
    {
      do
      {
        v2 = *(_WORD *)(dword_41704C + 2 * v8);
        if ( (_WORD)v2 )
        {
          v3 = dword_417054;
          v4 = dword_417060 + v8 * 2 * dword_41706C;
          do
          {
            v5 = 12 * v2;
            v6 = 12 * v2 + v3;
            v7 = *(_DWORD *)v6;
            v10 = v4;
            v11 = v7;
            v12 = *(_DWORD *)(v6 + 4);
            write(v1, &v10, 0xCu);
            v3 = dword_417054;
            v2 = *(_WORD *)(dword_417054 + v5 + 8);
          }
          while ( *(_WORD *)(dword_417054 + v5 + 8) );
        }
        ++v8;
      }
      while ( v9 != v8 );
    }
    close(v1);
  }
}
// 417040: using guessed type int _gmonparam;
// 41704C: using guessed type int dword_41704C;
// 417050: using guessed type int dword_417050;
// 417054: using guessed type int dword_417054;
// 417064: using guessed type int dword_417064;
// 41706C: using guessed type int dword_41706C;

//----- (00413090) --------------------------------------------------------
void __spoils<ecx> mcount()
{
  unsigned int v0; // eax@2
  unsigned __int16 *v1; // edi@4
  int v2; // eax@5
  int v3; // esi@6
  int v4; // ebx@6
  unsigned __int16 v5; // dx@9
  int v6; // eax@10
  __int16 v7; // cx@11
  int v8; // eax@14
  unsigned __int16 v9; // dx@14
  bool v10; // sf@14
  unsigned __int8 v11; // of@14
  int v12; // eax@15
  unsigned __int16 v13; // ax@18
  int v14; // edx@19
  unsigned __int16 v15; // cx@19
  int vars0; // [sp+Ch] [bp+0h]@0
  void *retaddr; // [sp+10h] [bp+4h]@6

  if ( !_gmonparam )
  {
    v0 = *(_DWORD *)(vars0 + 4) - dword_417060;
    _gmonparam = 1;
    if ( v0 > dword_417068 )
    {
LABEL_12:
      _gmonparam = 0;
      return;
    }
    if ( dword_41706C == 2 )
      v1 = (unsigned __int16 *)(dword_41704C + 2 * (v0 >> 2));
    else
      v1 = (unsigned __int16 *)(dword_41704C + 2 * (v0 / (2 * dword_41706C)));
    v2 = *v1;
    if ( (_WORD)v2 )
    {
      v3 = dword_417054;
      v4 = dword_417054 + 12 * v2;
      if ( retaddr == *(void **)v4 )
      {
        ++*(_DWORD *)(v4 + 4);
        goto LABEL_12;
      }
      while ( 1 )
      {
        v5 = *(_WORD *)(v4 + 8);
        if ( !v5 )
          break;
        v6 = dword_417054 + 12 * v5;
        if ( retaddr == *(void **)v6 )
        {
          v7 = *(_WORD *)(v6 + 8);
          ++*(_DWORD *)(v6 + 4);
          *(_WORD *)(v4 + 8) = v7;
          *(_WORD *)(v6 + 8) = *v1;
          *v1 = v5;
          goto LABEL_12;
        }
        v4 = dword_417054 + 12 * v5;
      }
      v13 = *(_WORD *)(dword_417054 + 8) + 1;
      v11 = __OFSUB__(v13, dword_41705C);
      v10 = v13 - dword_41705C < 0;
      *(_WORD *)(dword_417054 + 8) = v13;
      if ( v10 ^ v11 )
      {
        v14 = v3 + 12 * v13;
        *(_DWORD *)v14 = retaddr;
        v15 = *v1;
        *(_DWORD *)(v14 + 4) = 1;
        *(_WORD *)(v14 + 8) = v15;
        *v1 = v13;
        goto LABEL_12;
      }
    }
    else
    {
      v8 = dword_417054;
      v9 = *(_WORD *)(dword_417054 + 8) + 1;
      v11 = __OFSUB__(v9, dword_41705C);
      v10 = v9 - dword_41705C < 0;
      *(_WORD *)(dword_417054 + 8) = v9;
      if ( v10 ^ v11 )
      {
        *v1 = v9;
        v12 = v8 + 12 * v9;
        *(_DWORD *)v12 = retaddr;
        *(_DWORD *)(v12 + 4) = 1;
        *(_WORD *)(v12 + 8) = 0;
        goto LABEL_12;
      }
    }
    _gmonparam = 2;
  }
}
// 417040: using guessed type int _gmonparam;
// 41704C: using guessed type int dword_41704C;
// 417054: using guessed type int dword_417054;
// 41705C: using guessed type int dword_41705C;
// 417068: using guessed type int dword_417068;
// 41706C: using guessed type int dword_41706C;

//----- (004131F0) --------------------------------------------------------
DWORD __usercall get_thrpc@<eax>(void *a1@<eax>)
{
  DWORD v1; // ebx@1
  void *v2; // esi@1
  unsigned int v3; // eax@2
  CONTEXT Context; // [sp+14h] [bp-2D8h]@2

  v1 = -1;
  v2 = a1;
  if ( SuspendThread(a1) != -1 )
  {
    Context.ContextFlags = 65539;
    v3 = GetThreadContext(v2, &Context);
    v1 = Context.Eip | -(v3 < 1);
    ResumeThread(v2);
  }
  return v1;
}

//----- (00413270) --------------------------------------------------------
void __stdcall __noreturn profthr_func(LPVOID lpThreadParameter)
{
  DWORD v1; // edx@1
  int v2; // eax@1
  _WORD *v3; // eax@3

  while ( 1 )
  {
    v1 = get_thrpc(*(void **)lpThreadParameter);
    v2 = *((_DWORD *)lpThreadParameter + 3);
    if ( v1 >= v2 && v1 < *((_DWORD *)lpThreadParameter + 4) )
    {
      v3 = (_WORD *)(*((_DWORD *)lpThreadParameter + 2)
                   + 2 * (*((_DWORD *)lpThreadParameter + 5) * (unsigned __int64)((v1 - v2) >> 1) >> 16));
      ++*v3;
    }
    Sleep(0xAu);
  }
}

//----- (004132C0) --------------------------------------------------------
int __cdecl profile_ctl(LPHANDLE a1, void *a2, size_t a3, int a4, int a5)
{
  HANDLE v5; // eax@2
  int result; // eax@6
  LPHANDLE v7; // edx@8
  signed int v8; // ecx@8
  unsigned int v9; // eax@12
  HANDLE *v10; // edx@14
  unsigned __int64 ST00_8_18; // ST00_8@18
  HANDLE v12; // edi@18
  HANDLE v13; // esi@18
  HANDLE v14; // eax@18
  HANDLE v15; // eax@19
  DWORD ThreadId; // [sp+2Ch] [bp-10h]@19

  if ( (unsigned int)a5 > 0x10000 )
  {
    *(_DWORD *)_errno() = 22;
    result = -1;
  }
  else
  {
    v5 = a1[1];
    if ( v5 )
    {
      TerminateThread(v5, 0);
      CloseHandle(a1[1]);
    }
    if ( *a1 )
      CloseHandle(*a1);
    result = 0;
    if ( a5 )
    {
      memset(a2, 0, a3);
      v7 = a1;
      v8 = 24;
      if ( (unsigned __int8)a1 & 1 )
      {
        *(_BYTE *)a1 = 0;
        v7 = (LPHANDLE)((char *)a1 + 1);
        LOBYTE(v8) = 23;
      }
      if ( (unsigned __int8)v7 & 2 )
      {
        *(_WORD *)v7 = 0;
        v8 -= 2;
        v7 = (LPHANDLE)((char *)v7 + 2);
      }
      v9 = 0;
      do
      {
        v7[v9 / 4] = 0;
        v9 += 4;
      }
      while ( v9 < (v8 & 0xFFFFFFFC) );
      v10 = &v7[v9 / 4];
      if ( v8 & 2 )
      {
        *(_WORD *)v10 = 0;
        v10 = (HANDLE *)((char *)v10 + 2);
      }
      if ( v8 & 1 )
        *(_BYTE *)v10 = 0;
      dword_55B994 = (int)a2;
      dword_55B998 = a4;
      LODWORD(ST00_8_18) = a3 >> 1 << 16;
      HIDWORD(ST00_8_18) = a3 / 0x20000;
      dword_55B9A0 = a5;
      dword_55B99C = a4 + 2 * (ST00_8_18 / (unsigned int)a5);
      v12 = GetCurrentProcess();
      v13 = GetCurrentThread();
      v14 = GetCurrentProcess();
      if ( DuplicateHandle(v14, v13, v12, a1, 0, 0, 2u) )
      {
        v15 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)profthr_func, a1, 0, &ThreadId);
        a1[1] = v15;
        SetThreadPriority(v15, 15);
        if ( a1[1] )
        {
          result = 0;
        }
        else
        {
          CloseHandle(*a1);
          *a1 = 0;
          *(_DWORD *)_errno() = 11;
          result = -1;
        }
      }
      else
      {
        *(_DWORD *)_errno() = 3;
        result = -1;
      }
    }
  }
  return result;
}
// 4137A4: using guessed type int _errno(void);
// 55B994: using guessed type int dword_55B994;
// 55B998: using guessed type int dword_55B998;
// 55B99C: using guessed type int dword_55B99C;
// 55B9A0: using guessed type int dword_55B9A0;

//----- (00413500) --------------------------------------------------------
int __cdecl profil(void *a1, size_t a2, int a3, int a4)
{
  return profile_ctl(&prof, a1, a2, a3, a4);
}

//----- (00413660) --------------------------------------------------------
signed int __cdecl __mingwthr_key_dtor(int a1, int a2)
{
  signed int result; // eax@2

  if ( a2 )
    result = ___w64_mingwthr_add_key_dtor(a1, a2);
  else
    result = 0;
  return result;
}

//----- (004137AC) --------------------------------------------------------
char *__usercall parse_lsda_header@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  _BYTE *v4; // edi@1
  int v5; // eax@2
  char v6; // dl@3
  char *v7; // ecx@3
  char v8; // di@4
  unsigned __int8 v9; // dl@4
  char *v10; // ST18_4@9
  _DWORD **v11; // edx@9
  int v12; // eax@10
  char v13; // dl@11
  char *v14; // eax@11
  int v15; // edi@12
  int v16; // ecx@12
  char v17; // bl@13
  int v18; // ecx@14
  char *result; // eax@15
  int v20; // edi@15
  int v21; // ecx@15
  char v22; // bl@16
  char *v23; // ST18_4@23
  char *v24; // ST18_4@26
  int v25; // [sp+1Ch] [bp-20h]@1

  v3 = a1;
  v4 = a2;
  v25 = a3;
  if ( a1 )
    v5 = _Unwind_GetRegionStart(a1);
  else
    v5 = 0;
  *(_DWORD *)v25 = v5;
  v6 = *v4;
  v7 = v4 + 1;
  if ( *v4 == -1 )
  {
    *(_DWORD *)(v25 + 4) = v5;
    v12 = v25;
    goto LABEL_11;
  }
  v8 = *v4;
  v9 = v6 & 0x70;
  if ( v9 == 32 )
  {
    v23 = v7;
    v11 = (_DWORD **)_Unwind_GetTextRelBase(v3);
    v7 = v23;
    goto LABEL_24;
  }
  if ( v9 <= 0x20u )
  {
    if ( v9 && v9 != 16 )
LABEL_22:
      abort();
LABEL_25:
    v11 = 0;
    goto LABEL_24;
  }
  if ( v9 == 64 )
  {
    v24 = v7;
    v11 = (_DWORD **)_Unwind_GetRegionStart(v3);
    v7 = v24;
    goto LABEL_24;
  }
  if ( v9 == 80 )
    goto LABEL_25;
  if ( v9 != 48 )
    goto LABEL_22;
  v10 = v7;
  v11 = (_DWORD **)_Unwind_GetDataRelBase(v3);
  v7 = v10;
LABEL_24:
  v7 = read_encoded_value_with_base(v8, v11, (_DWORD **)v7, v25 + 4);
  v12 = v25;
LABEL_11:
  v13 = *v7;
  *(_BYTE *)(v12 + 20) = *v7;
  v14 = v7 + 1;
  if ( v13 == -1 )
  {
    v18 = v25;
    *(_DWORD *)(v25 + 12) = 0;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    do
    {
      v17 = *v14++;
      v15 |= (v17 & 0x7F) << v16;
      v16 += 7;
    }
    while ( v17 < 0 );
    v18 = v25;
    *(_DWORD *)(v25 + 12) = &v14[v15];
  }
  *(_BYTE *)(v18 + 21) = *v14;
  result = v14 + 1;
  v20 = 0;
  v21 = 0;
  do
  {
    v22 = *result++;
    v20 |= (v22 & 0x7F) << v21;
    v21 += 7;
  }
  while ( v22 < 0 );
  *(_DWORD *)(v25 + 16) = &result[v20];
  return result;
}

//----- (004138FC) --------------------------------------------------------
char __usercall check_exception_spec@<al>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)
{
  int v4; // edi@1
  int v5; // ebp@1
  char *v6; // esi@1
  int v7; // ebx@2
  int v8; // ecx@2
  char v9; // dl@3
  char v10; // dl@5
  char v11; // al@5
  unsigned __int8 v12; // dl@6
  int v13; // ebx@9
  int v14; // ebx@10
  int *v16; // [sp+1Ch] [bp-30h]@1
  unsigned __int8 v17[4]; // [sp+28h] [bp-24h]@10
  int *v18; // [sp+2Ch] [bp-20h]@10

  v4 = a1;
  v5 = a2;
  v16 = a3;
  v6 = (char *)(*(_DWORD *)(a1 + 12) + ~a4);
  while ( 1 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *v6++;
      v7 |= (v9 & 0x7F) << v8;
      v8 += 7;
    }
    while ( v9 < 0 );
    if ( !v7 )
      return 0;
    v10 = *(_BYTE *)(v4 + 20);
    v11 = v10;
    if ( v10 == -1 )
    {
      v13 = 0;
    }
    else
    {
      v12 = v10 & 7;
      if ( v12 == 2 )
      {
        v13 = -2 * v7;
      }
      else
      {
        if ( v12 > 2u )
        {
          if ( v12 != 3 )
          {
            if ( v12 != 4 )
LABEL_16:
              abort();
            v13 = -8 * v7;
            goto LABEL_10;
          }
        }
        else if ( v12 )
        {
          goto LABEL_16;
        }
        v13 = -4 * v7;
      }
    }
LABEL_10:
    read_encoded_value_with_base(v11, *(_DWORD ***)(v4 + 8), (_DWORD **)(v13 + *(_DWORD *)(v4 + 12)), (int)v17);
    v14 = *(_DWORD *)v17;
    v18 = v16;
    if ( (unsigned __int8)(*(int (__fastcall **)(int))(*(_DWORD *)v5 + 8))(v5) )
      v18 = (int *)*v18;
    if ( (unsigned __int8)(*(int (__fastcall **)(int, int *, int, int *))(*(_DWORD *)v14 + 16))(
                            v14,
                            (int *)&v18,
                            v5,
                            (int *)&v18) )
      return 1;
  }
}

//----- (004139F8) --------------------------------------------------------
void __usercall __gxx_exception_cleanup(int ebp0@<ebp>, void *a1, int a2)
{
  void (*v3)(void); // eax@2

  if ( (unsigned int)a1 > 1 )
    __cxxabiv1::__terminate(*(void (**)(void))(a2 - 36));
  v3 = *(void (**)(void))(a2 - 44);
  if ( v3 )
    v3();
  __cxa_free_exception(ebp0, (void *)(a2 + 32));
}

//----- (00413A30) --------------------------------------------------------
char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, _DWORD **a2@<edx>, _DWORD **a3@<ecx>, int a4)
{
  _DWORD **v4; // ebp@1
  unsigned __int8 v5; // al@2
  char *v6; // ebx@5
  char *result; // eax@5
  unsigned int v8; // ecx@13
  _DWORD **v9; // edi@13
  char v10; // dl@14
  _DWORD **v11; // esi@15
  char v12; // di@15
  char *v13; // edi@18
  int v14; // ecx@18
  _DWORD **v15; // esi@18
  char v16; // dl@19
  _DWORD *v17; // eax@23
  int v18; // ebx@23
  char v19; // [sp+Fh] [bp-1Dh]@1

  v4 = a3;
  v19 = a1;
  if ( a1 == 80 )
  {
    v17 = (_DWORD *)(((unsigned int)a3 + 3) & 0xFFFFFFFC);
    v18 = *v17;
    result = (char *)(v17 + 1);
    *(_DWORD *)a4 = v18;
  }
  else
  {
    v5 = a1 & 0xF;
    if ( v5 > 0xCu )
LABEL_3:
      abort();
    switch ( v5 )
    {
      default:
        goto LABEL_3;
      case 0u:
      case 3u:
      case 0xBu:
        v6 = (char *)*a3;
        result = (char *)(a3 + 1);
        break;
      case 4u:
      case 0xCu:
        v6 = (char *)*a3;
        result = (char *)(a3 + 2);
        break;
      case 9u:
        result = (char *)a3;
        v6 = 0;
        v8 = 0;
        v9 = a2;
        do
        {
          v10 = *result++;
          v6 = (char *)(((v10 & 0x7F) << v8) | (unsigned int)v6);
          v8 += 7;
        }
        while ( v10 < 0 );
        v11 = v9;
        v12 = v10;
        a2 = v11;
        if ( v8 <= 0x1F && v12 & 0x40 )
          v6 = (char *)((-1 << v8) | (unsigned int)v6);
        break;
      case 1u:
        result = (char *)a3;
        v13 = 0;
        v14 = 0;
        v15 = a2;
        do
        {
          v16 = *result++;
          v13 = (char *)(((v16 & 0x7F) << v14) | (unsigned int)v13);
          v14 += 7;
        }
        while ( v16 < 0 );
        a2 = v15;
        v6 = v13;
        break;
      case 0xAu:
        v6 = (char *)*(_WORD *)a3;
        result = (char *)a3 + 2;
        break;
      case 2u:
        v6 = (char *)*(_WORD *)a3;
        result = (char *)a3 + 2;
        break;
    }
    if ( v6 )
    {
      if ( (v19 & 0x70) == 16 )
        a2 = v4;
      v6 = &v6[(_DWORD)a2];
      if ( v19 < 0 )
        v6 = *(char **)v6;
    }
    *(_DWORD *)a4 = v6;
  }
  return result;
}

//----- (00413B34) --------------------------------------------------------
void __cdecl __noreturn __cxxabiv1::__terminate(void (*a1)(void))
{
  a1();
  abort();
}

//----- (00413B4C) --------------------------------------------------------
void __cdecl __noreturn __cxxabiv1::__unexpected(void (*a1)(void))
{
  a1();
  std::terminate();
}

//----- (00413B58) --------------------------------------------------------
// jumptable 0040F04A case 206
void __fastcall __cxxabiv1::__forced_unwind::~__forced_unwind(void *a1)
{
  *(_DWORD *)a1 = &off_41E260;
  operator delete(a1);
}
// 41E260: using guessed type _DWORD (__cdecl *off_41E260)(__cxxabiv1::__forced_unwind *__hidden this);

//----- (00413B70) --------------------------------------------------------
// jumptable 0040F04A case 205
void __fastcall __cxxabiv1::__forced_unwind::~__forced_unwind(_DWORD *a1)
{
  *a1 = &off_41E260;
}
// 41E260: using guessed type _DWORD (__cdecl *off_41E260)(__cxxabiv1::__forced_unwind *__hidden this);

//----- (00413B78) --------------------------------------------------------
// jumptable 0040F04A case 216
void __fastcall __cxxabiv1::__class_type_info::~__class_type_info(_DWORD *a1)
{
  void *v1; // ebx@1

  v1 = a1;
  *a1 = &loc_41E288;
  std::type_info::~type_info(a1);
  operator delete(v1);
}

//----- (00413B98) --------------------------------------------------------
// jumptable 0040F04A case 215
void __fastcall __cxxabiv1::__class_type_info::~__class_type_info(_DWORD *a1)
{
  *a1 = &loc_41E288;
  std::type_info::~type_info(a1);
}

//----- (00413BA4) --------------------------------------------------------
// jumptable 0040F04A case 232
void __fastcall __cxxabiv1::__foreign_exception::~__foreign_exception(void *a1)
{
  *(_DWORD *)a1 = &off_41E2C8;
  operator delete(a1);
}
// 41E2C8: using guessed type _DWORD (__cdecl *off_41E2C8)(__cxxabiv1::__foreign_exception *__hidden this);

//----- (00413BBC) --------------------------------------------------------
// jumptable 0040F04A case 231
void __fastcall __cxxabiv1::__foreign_exception::~__foreign_exception(_DWORD *a1)
{
  *a1 = &off_41E2C8;
}
// 41E2C8: using guessed type _DWORD (__cdecl *off_41E2C8)(__cxxabiv1::__foreign_exception *__hidden this);

//----- (00413BC4) --------------------------------------------------------
// jumptable 0040F04A case 240
void __fastcall __cxxabiv1::__si_class_type_info::~__si_class_type_info(_DWORD *a1)
{
  void *v1; // ebx@1

  v1 = a1;
  *a1 = &loc_41E2E8;
  __cxxabiv1::__class_type_info::~__class_type_info(a1);
  operator delete(v1);
}

//----- (00413BE4) --------------------------------------------------------
// jumptable 0040F04A case 239
void __fastcall __cxxabiv1::__si_class_type_info::~__si_class_type_info(_DWORD *a1)
{
  *a1 = &loc_41E2E8;
  __cxxabiv1::__class_type_info::~__class_type_info(a1);
}

//----- (00413BF0) --------------------------------------------------------
void __fastcall __gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error(_DWORD *a1)
{
  void *v1; // ebx@1

  v1 = a1;
  *a1 = &off_41E328;
  std::exception::~exception(a1);
  operator delete(v1);
}
// 41E328: using guessed type _DWORD (__cdecl *off_41E328)(__gnu_cxx::__concurrence_lock_error *__hidden this);

//----- (00413C10) --------------------------------------------------------
// jumptable 0040F04A case 255
void __fastcall __gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error(_DWORD *a1)
{
  *a1 = &off_41E328;
  std::exception::~exception(a1);
}
// 41E328: using guessed type _DWORD (__cdecl *off_41E328)(__gnu_cxx::__concurrence_lock_error *__hidden this);

//----- (00413C1C) --------------------------------------------------------
void __fastcall __gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error(_DWORD *a1)
{
  void *v1; // ebx@1

  v1 = a1;
  *a1 = &off_41E340;
  std::exception::~exception(a1);
  operator delete(v1);
}
// 41E340: using guessed type _DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this);

//----- (00413C3C) --------------------------------------------------------
void __fastcall __gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error(_DWORD *a1)
{
  *a1 = &off_41E340;
  std::exception::~exception(a1);
}
// 41E340: using guessed type _DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this);

//----- (00413C48) --------------------------------------------------------
void __noreturn __gnu_cxx::__verbose_terminate_handler(void)
{
  int v0; // eax@2
  const char *v1; // ebx@3
  const char *v2; // ebp@3
  FILE *v3; // [sp+4h] [bp-38h]@3
  int v4; // [sp+1Ch] [bp-20h]@3

  if ( !__gnu_cxx::__verbose_terminate_handler(void)::terminating )
  {
    __gnu_cxx::__verbose_terminate_handler(void)::terminating = 1;
    v0 = __cxa_current_exception_type();
    if ( v0 )
    {
      v1 = (const char *)((**(_BYTE **)(v0 + 4) == 42) + *(_DWORD *)(v0 + 4));
      v4 = -1;
      v2 = (const char *)__cxa_demangle((int)v1, 0, 0, (int)&v4);
      fwrite("terminate called after throwing an instance of '", 1u, 0x30u, &__iob[2]);
      v3 = &__iob[2];
      if ( v4 )
        fputs(v1, v3);
      else
        fputs(v2, v3);
      fwrite("'\n", 1u, 2u, &__iob[2]);
      if ( !v4 )
        free((void *)v2);
      __cxa_rethrow((int)v2);
    }
    fwrite("terminate called without an active exception\n", 1u, 0x2Du, &__iob[2]);
    abort();
  }
  fwrite("terminate called recursively\n", 1u, 0x1Du, &__iob[2]);
  abort();
}
// 41BAB0: using guessed type char __gnu_cxx::__verbose_terminate_handler(void)::terminating;

//----- (00413DEC) --------------------------------------------------------
void __usercall __noreturn __gnu_cxx::__throw_concurrence_lock_error(int a1@<ebp>)
{
  char *v1; // eax@1

  v1 = __cxa_allocate_exception(a1, 4);
  *(_DWORD *)v1 = &off_41E328;
  __cxa_throw(a1, (int)v1, (int)&loc_41E06F + 1, (int)__gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error);
}
// 41E328: using guessed type _DWORD (__cdecl *off_41E328)(__gnu_cxx::__concurrence_lock_error *__hidden this);

//----- (00413E1C) --------------------------------------------------------
// jumptable 0040F04A cases 219,243
char __userpurge __cxxabiv1::__class_type_info::__do_catch@<al>(int a1@<edx>, int a2@<ecx>, __cxxabiv1::__class_type_info *this, const std::type_info *a4, void **a5, unsigned int a6)
{
  int v6; // esi@1
  char result; // al@3

  v6 = a2;
  if ( std::type_info::operator==(a2, a1, (int)this) )
  {
    result = 1;
  }
  else if ( (unsigned int)a5 <= 3 )
  {
    result = (*(int (__fastcall **)(__cxxabiv1::__class_type_info *, const std::type_info *, int))(*(_DWORD *)this + 20))(
               this,
               a4,
               v6);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00413E74) --------------------------------------------------------
// jumptable 0040F04A case 221
char __fastcall __cxxabiv1::__class_type_info::__do_upcast(int a1, int a2, int a3, int a4, int a5)
{
  char result; // al@2

  if ( std::type_info::operator==(a1, a2, a3) )
  {
    *(_DWORD *)a5 = a4;
    *(_DWORD *)(a5 + 12) = 8;
    *(_DWORD *)(a5 + 4) = 6;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00413EB8) --------------------------------------------------------
// jumptable 0040F04A cases 220,244
char __userpurge __cxxabiv1::__class_type_info::__do_upcast@<al>(int a1@<ecx>, __cxxabiv1::__class_type_info *this, const __cxxabiv1::__class_type_info *a3, void **a4)
{
  char result; // al@2
  int v5; // [sp+10h] [bp-1Ch]@1
  int v6; // [sp+14h] [bp-18h]@1
  int v7; // [sp+18h] [bp-14h]@1
  int v8; // [sp+1Ch] [bp-10h]@1

  v5 = 0;
  v6 = 0;
  v7 = 16;
  v8 = 0;
  (*(void (__stdcall **)(__cxxabiv1::__class_type_info *, _DWORD, int *))(*(_DWORD *)a1 + 24))(this, *(_DWORD *)a3, &v5);
  if ( (v6 & 6) == 6 )
  {
    *(_DWORD *)a3 = v5;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00413F24) --------------------------------------------------------
// jumptable 0040F04A case 222
int __fastcall __cxxabiv1::__class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // esi@1

  v9 = a1;
  if ( a6 == a8 && std::type_info::operator==(a1, a2, a7) )
  {
    *(_DWORD *)(a9 + 8) = a4;
  }
  else if ( std::type_info::operator==(v9, a2, a5) )
  {
    *(_DWORD *)a9 = a6;
    *(_DWORD *)(a9 + 4) = a4;
    *(_DWORD *)(a9 + 12) = 1;
  }
  return 0;
}

//----- (00413F88) --------------------------------------------------------
// jumptable 0040F04A case 223
int __stdcall __cxxabiv1::__class_type_info::__do_find_public_src(__cxxabiv1::__class_type_info *this, int a2, const void *a3, const __cxxabiv1::__class_type_info *a4, const void *a5)
{
  return 5 * (a4 == (const __cxxabiv1::__class_type_info *)a2) + 1;
}

//----- (00413FA0) --------------------------------------------------------
// jumptable 0040F04A case 245
char __fastcall __cxxabiv1::__si_class_type_info::__do_upcast(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  char result; // al@2

  v5 = a1;
  if ( __cxxabiv1::__class_type_info::__do_upcast(a1, a2, a3, a4, a5) )
    result = 1;
  else
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(v5 + 8) + 24))(a3, a4, a5);
  return result;
}

//----- (00413FF8) --------------------------------------------------------
// jumptable 0040F04A case 246
int __fastcall __cxxabiv1::__si_class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v10; // [sp+10h] [bp-2Ch]@1

  v10 = a1;
  if ( std::type_info::operator==(a1, a8, a5) )
  {
    *(_DWORD *)a9 = a6;
    *(_DWORD *)(a9 + 4) = a4;
    if ( a3 < 0 )
    {
      if ( a3 == -2 )
        *(_DWORD *)(a9 + 12) = 1;
    }
    else
    {
      *(_DWORD *)(a9 + 12) = 5 * (a8 == a3 + a6) + 1;
    }
    return 0;
  }
  if ( a6 == a8 && std::type_info::operator==(v10, a7, a7) )
  {
    *(_DWORD *)(a9 + 8) = a4;
    return 0;
  }
  return (*(int (__stdcall **)(int, int, int, int, int, int, int))(**(_DWORD **)(v10 + 8) + 28))(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9);
}

//----- (004140D8) --------------------------------------------------------
// jumptable 0040F04A case 247
int __userpurge __cxxabiv1::__si_class_type_info::__do_find_public_src@<eax>(int a1@<ecx>, __cxxabiv1::__si_class_type_info *this, int a3, const void *a4, const __cxxabiv1::__class_type_info *a5, const void *a6)
{
  int v6; // edx@1
  int result; // eax@2
  int v8; // ST1C_4@3
  char v9; // al@3

  v6 = a1;
  if ( a5 == (const __cxxabiv1::__class_type_info *)a3
    && (v8 = a1, v9 = std::type_info::operator==(a1, a1, (int)a4), v6 = v8, v9) )
  {
    result = 6;
  }
  else
  {
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(v6 + 8) + 32))(this, a3, a4, a5);
  }
  return result;
}

//----- (0041413C) --------------------------------------------------------
const char *__gnu_cxx::__concurrence_lock_error::what()
{
  return "__gnu_cxx::__concurrence_lock_error";
}

//----- (00414144) --------------------------------------------------------
const char *__gnu_cxx::__concurrence_unlock_error::what()
{
  return "__gnu_cxx::__concurrence_unlock_error";
}

//----- (0041414C) --------------------------------------------------------
const char *std::bad_exception::what()
{
  return "std::bad_exception";
}

//----- (00414154) --------------------------------------------------------
const char *std::exception::what()
{
  return "std::exception";
}

//----- (0041415C) --------------------------------------------------------
char __userpurge std::type_info::__do_catch@<al>(int a1@<ecx>, std::type_info *this, const std::type_info *a3, void **a4, unsigned int a5)
{
  const char *v5; // edx@2
  int v6; // eax@3

  if ( (std::type_info *)a1 != this )
  {
    v5 = *(const char **)(a1 + 4);
    if ( *v5 == 42 )
      return 0;
    v6 = *((_DWORD *)this + 1);
    if ( *(_BYTE *)v6 == 42 )
    {
      if ( strcmp(v5, (const char *)(v6 + 1)) )
        return 0;
    }
    else if ( strcmp(v5, (const char *)v6) )
    {
      return 0;
    }
  }
  return 1;
}

//----- (004141AC) --------------------------------------------------------
int __stdcall std::type_info::__do_upcast(std::type_info *this, const __cxxabiv1::__class_type_info *a2, void **a3)
{
  return 0;
}

//----- (004141B4) --------------------------------------------------------
// jumptable 0040F04A cases 217,241
int std::type_info::__is_pointer_p()
{
  return 0;
}

//----- (004141B8) --------------------------------------------------------
// jumptable 0040F04A cases 218,242
int std::type_info::__is_function_p()
{
  return 0;
}

//----- (004141BC) --------------------------------------------------------
char __fastcall std::type_info::operator==(int a1, int a2, int a3)
{
  const char *v3; // edx@2
  int v4; // eax@3

  if ( a3 != a1 )
  {
    v3 = *(const char **)(a1 + 4);
    if ( *v3 == 42 )
      return 0;
    v4 = *(_DWORD *)(a3 + 4);
    if ( *(_BYTE *)v4 == 42 )
    {
      if ( strcmp(v3, (const char *)(v4 + 1)) )
        return 0;
    }
    else if ( strcmp(v3, (const char *)v4) )
    {
      return 0;
    }
  }
  return 1;
}

//----- (0041420C) --------------------------------------------------------
edge *__cdecl std::_Iter_base<edge *,false>::_S_base(edge *__it)
{
  mcount();
  return __it;
}

//----- (0041421C) --------------------------------------------------------
void __cdecl std::__iter_swap<true>::iter_swap<edge *,edge *>(edge *__a, edge *__b)
{
  mcount();
  std::swap<edge>(__a, __b);
}

//----- (0041423C) --------------------------------------------------------
void __fastcall std::bad_exception::~bad_exception(void *a1)
{
  *(_DWORD *)a1 = &off_41E370;
  operator delete(a1);
}
// 41E370: using guessed type int (*off_41E370)();

//----- (00414254) --------------------------------------------------------
void __fastcall std::bad_exception::~bad_exception(_DWORD *a1)
{
  *a1 = &off_41E370;
}
// 41E370: using guessed type int (*off_41E370)();

//----- (0041425C) --------------------------------------------------------
edge *__cdecl std::__copy_move_backward<false,true,std::random_access_iterator_tag>::__copy_move_b<edge>(const edge *__first, const edge *__last, edge *__result)
{
  mcount();
  if ( -1431655765 * (((char *)__last - (char *)__first) >> 2) )
    memmove(
      (char *)__result - 4 * (((char *)__last - (char *)__first) >> 2),
      __first,
      4 * (((char *)__last - (char *)__first) >> 2));
  return (edge *)((char *)__result - 4 * (((char *)__last - (char *)__first) >> 2));
}

//----- (004142F4) --------------------------------------------------------
void __fastcall std::exception::~exception(void *a1)
{
  *(_DWORD *)a1 = &off_41E370;
  operator delete(a1);
}
// 41E370: using guessed type int (*off_41E370)();

//----- (0041430C) --------------------------------------------------------
void __fastcall std::exception::~exception(_DWORD *a1)
{
  *a1 = &off_41E370;
}
// 41E370: using guessed type int (*off_41E370)();

//----- (00414314) --------------------------------------------------------
void __fastcall std::type_info::~type_info(void *a1)
{
  *(_DWORD *)a1 = &off_41E388;
  operator delete(a1);
}
// 41E388: using guessed type _DWORD (__cdecl *off_41E388)(std::type_info *__hidden this);

//----- (0041432C) --------------------------------------------------------
void __fastcall std::type_info::~type_info(_DWORD *a1)
{
  *a1 = &off_41E388;
}
// 41E388: using guessed type _DWORD (__cdecl *off_41E388)(std::type_info *__hidden this);

//----- (00414334) --------------------------------------------------------
void __cdecl std::__pop_heap<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, edge *__result, int (*__comp)(const edge *, const edge *))
{
  std::__pop_heap<edge*,int (*)(const edge&,const edge&)>::_ValueType v4; // [sp+Ch] [bp-4Ch]@1
  std::__pop_heap<edge*,int (*)(const edge&,const edge&)>::_ValueType __value; // [sp+34h] [bp-24h]@1

  mcount();
  qmemcpy(&__value, __result, sizeof(__value));
  qmemcpy(__result, __first, sizeof(edge));
  qmemcpy(&v4, &__value, sizeof(v4));
  std::__adjust_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(
    __first,
    0,
    -1431655765 * (((char *)__last - (char *)__first) >> 2),
    v4,
    __comp);
}

//----- (004143EC) --------------------------------------------------------
void __noreturn std::unexpected(void)
{
  __cxxabiv1::__unexpected(__cxxabiv1::__unexpected_handler);
}

//----- (004143FC) --------------------------------------------------------
void __cdecl std::__push_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(edge *__first, int __holeIndex, int __topIndex, edge __value, int (*__comp)(const edge *, const edge *))
{
  char v5; // al@5
  int __parent; // [sp+1Ch] [bp-1Ch]@1

  mcount();
  for ( __parent = (__holeIndex - 1) / 2; ; __parent = (__parent - 1) / 2 )
  {
    v5 = __holeIndex > __topIndex && __comp(&__first[__parent], &__value) ? 1 : 0;
    if ( !v5 )
      break;
    qmemcpy(&__first[__holeIndex], &__first[__parent], sizeof(edge));
    __holeIndex = __parent;
  }
  qmemcpy(&__first[__holeIndex], &__value, sizeof(edge));
}

//----- (004144D4) --------------------------------------------------------
std::_Iter_base<edge*,false>::iterator_type __cdecl std::__miter_base<edge *>(edge *__it)
{
  mcount();
  return std::_Iter_base<edge *,false>::_S_base(__it);
}

//----- (004144EC) --------------------------------------------------------
std::_Iter_base<edge*,false>::iterator_type __cdecl std::__niter_base<edge *>(edge *__it)
{
  mcount();
  return std::_Iter_base<edge *,false>::_S_base(__it);
}

//----- (00414504) --------------------------------------------------------
void __cdecl std::partial_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__middle, edge *__last, int (*__comp)(const edge *, const edge *))
{
  mcount();
  std::__heap_select<edge *,int (*)(edge const&,edge const&)>(__first, __middle, __last, __comp);
  std::sort_heap<edge *,int (*)(edge const&,edge const&)>(__first, __middle, __comp);
}

//----- (0041454C) --------------------------------------------------------
void __cdecl std::__adjust_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(edge *__first, int __holeIndex, int __len, edge __value, int (*__comp)(const edge *, const edge *))
{
  edge v5; // [sp+Ch] [bp-3Ch]@9
  const int __topIndex; // [sp+28h] [bp-20h]@1
  int __secondChild; // [sp+2Ch] [bp-1Ch]@1

  mcount();
  __topIndex = __holeIndex;
  for ( __secondChild = __holeIndex; (__len - 1) / 2 > __secondChild; __holeIndex = __secondChild )
  {
    __secondChild = 2 * (__secondChild + 1);
    if ( __comp(&__first[__secondChild], &__first[__secondChild - 1]) != 0 )
      --__secondChild;
    qmemcpy(&__first[__holeIndex], &__first[__secondChild], sizeof(edge));
  }
  if ( !(__len & 1) && (__len - 2) / 2 == __secondChild )
  {
    __secondChild = 2 * (__secondChild + 1);
    qmemcpy(&__first[__holeIndex], &__first[__secondChild - 1], sizeof(edge));
    __holeIndex = __secondChild - 1;
  }
  qmemcpy(&v5, &__value, sizeof(v5));
  std::__push_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(__first, __holeIndex, __topIndex, v5, __comp);
}

//----- (004146B4) --------------------------------------------------------
void __cdecl std::__heap_select<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__middle, edge *__last, int (*__comp)(const edge *, const edge *))
{
  edge *__i; // [sp+1Ch] [bp-Ch]@1

  mcount();
  std::make_heap<edge *,int (*)(edge const&,edge const&)>(__first, __middle, __comp);
  for ( __i = __middle; __i < __last; ++__i )
  {
    if ( __comp(__i, __first) != 0 )
      std::__pop_heap<edge *,int (*)(edge const&,edge const&)>(__first, __middle, __i, __comp);
  }
}

//----- (00414730) --------------------------------------------------------
edge *__cdecl std::copy_backward<edge *,edge *>(edge *__first, edge *__last, edge *__result)
{
  edge *v3; // ebx@1
  edge *v4; // eax@1

  mcount();
  v3 = std::__miter_base<edge *>(__last);
  v4 = std::__miter_base<edge *>(__first);
  return std::__copy_move_backward_a2<false,edge *,edge *>(v4, v3, __result);
}

//----- (00414770) --------------------------------------------------------
void (*__cdecl std::set_terminate(void (*a1)(void)))(void)
{
  void (*result)(void); // eax@1

  result = __cxxabiv1::__terminate_handler;
  __cxxabiv1::__terminate_handler = a1;
  return result;
}

//----- (00414780) --------------------------------------------------------
void (*__cdecl std::set_unexpected(void (*a1)(void)))(void)
{
  void (*result)(void); // eax@1

  result = __cxxabiv1::__unexpected_handler;
  __cxxabiv1::__unexpected_handler = a1;
  return result;
}

//----- (00414790) --------------------------------------------------------
void __cdecl std::__insertion_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  std::iterator_traits<edge*>::value_type __val; // [sp+10h] [bp-28h]@4
  edge *__i; // [sp+1Ch] [bp-1Ch]@2

  mcount();
  if ( __first != __last )
  {
    for ( __i = __first + 1; __i != __last; ++__i )
    {
      if ( __comp(__i, __first) != 0 )
      {
        qmemcpy(&__val, __i, sizeof(__val));
        std::copy_backward<edge *,edge *>(__first, __i, __i + 1);
        qmemcpy(__first, &__val, sizeof(edge));
      }
      else
      {
        std::__unguarded_linear_insert<edge *,int (*)(edge const&,edge const&)>(__i, __comp);
      }
    }
  }
}

//----- (00414854) --------------------------------------------------------
void __cdecl std::__introsort_loop<edge *,int,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int __depth_limit, int (*__comp)(const edge *, const edge *))
{
  edge *__cut; // ST1C_4@4

  mcount();
  while ( (char *)__last - (char *)__first > 203 )
  {
    if ( !__depth_limit )
    {
      std::partial_sort<edge *,int (*)(edge const&,edge const&)>(__first, __last, __last, __comp);
      return;
    }
    --__depth_limit;
    __cut = std::__unguarded_partition_pivot<edge *,int (*)(edge const&,edge const&)>(__first, __last, __comp);
    std::__introsort_loop<edge *,int,int (*)(edge const&,edge const&)>(__cut, __last, __depth_limit, __comp);
    __last = __cut;
  }
}

//----- (004148EC) --------------------------------------------------------
bool std::uncaught_exception(void)
{
  return __cxa_get_globals()[1] != 0;
}

//----- (00414900) --------------------------------------------------------
void __cdecl std::__move_median_first<edge *,int (*)(edge const&,edge const&)>(edge *__a, edge *__b, edge *__c, int (*__comp)(const edge *, const edge *))
{
  mcount();
  if ( __comp(__a, __b) != 0 )
  {
    if ( __comp(__b, __c) != 0 )
    {
      std::iter_swap<edge *,edge *>(__a, __b);
    }
    else if ( __comp(__a, __c) != 0 )
    {
      std::iter_swap<edge *,edge *>(__a, __c);
    }
  }
  else if ( __comp(__a, __c) == 0 )
  {
    if ( __comp(__b, __c) != 0 )
      std::iter_swap<edge *,edge *>(__a, __c);
    else
      std::iter_swap<edge *,edge *>(__a, __b);
  }
}

//----- (004149E8) --------------------------------------------------------
edge *__cdecl std::__unguarded_partition<edge *,edge,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, const edge *const __pivot, int (*__comp)(const edge *, const edge *))
{
  mcount();
  while ( 1 )
  {
    while ( __comp(__first, __pivot) != 0 )
      ++__first;
    for ( --__last; __comp(__pivot, __last) != 0; --__last )
      ;
    if ( __first >= __last )
      break;
    std::iter_swap<edge *,edge *>(__first, __last);
    ++__first;
  }
  return __first;
}

//----- (00414A64) --------------------------------------------------------
edge *__cdecl std::__copy_move_backward_a<false,edge *,edge *>(edge *__first, edge *__last, edge *__result)
{
  mcount();
  return std::__copy_move_backward<false,true,std::random_access_iterator_tag>::__copy_move_b<edge>(
           __first,
           __last,
           __result);
}

//----- (00414A90) --------------------------------------------------------
void __cdecl std::__final_insertion_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  mcount();
  if ( (char *)__last - (char *)__first <= 203 )
  {
    std::__insertion_sort<edge *,int (*)(edge const&,edge const&)>(__first, __last, __comp);
  }
  else
  {
    std::__insertion_sort<edge *,int (*)(edge const&,edge const&)>(__first, __first + 16, __comp);
    std::__unguarded_insertion_sort<edge *,int (*)(edge const&,edge const&)>(__first + 16, __last, __comp);
  }
}

//----- (00414B0C) --------------------------------------------------------
edge *__cdecl std::__copy_move_backward_a2<false,edge *,edge *>(edge *__first, edge *__last, edge *__result)
{
  edge *v3; // esi@1
  edge *v4; // ebx@1
  edge *v5; // eax@1

  mcount();
  v3 = std::__niter_base<edge *>(__result);
  v4 = std::__niter_base<edge *>(__last);
  v5 = std::__niter_base<edge *>(__first);
  return std::__copy_move_backward_a<false,edge *,edge *>(v5, v4, v3);
}

//----- (00414B58) --------------------------------------------------------
void __cdecl std::__unguarded_linear_insert<edge *,int (*)(edge const&,edge const&)>(edge *__last, int (*__comp)(const edge *, const edge *))
{
  std::iterator_traits<edge*>::value_type *v2; // edx@1
  std::iterator_traits<edge*>::value_type __val; // [sp+10h] [bp-28h]@1
  edge *__next; // [sp+1Ch] [bp-1Ch]@1

  mcount();
  v2 = &__val;
  qmemcpy(&__val, __last, sizeof(__val));
  __next = __last - 1;
  while ( ((int (__fastcall *)(_DWORD, _DWORD))__comp)(0, v2) != 0 )
  {
    v2 = __last;
    qmemcpy(__last, __next, sizeof(edge));
    __last = __next;
    --__next;
  }
  qmemcpy(__last, &__val, sizeof(edge));
}

//----- (00414BE8) --------------------------------------------------------
void __cdecl std::__unguarded_insertion_sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  edge *__i; // [sp+1Ch] [bp-Ch]@1

  mcount();
  for ( __i = __first; __i != __last; ++__i )
    std::__unguarded_linear_insert<edge *,int (*)(edge const&,edge const&)>(__i, __comp);
}

//----- (00414C20) --------------------------------------------------------
edge *__cdecl std::__unguarded_partition_pivot<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  mcount();
  std::__move_median_first<edge *,int (*)(edge const&,edge const&)>(
    __first,
    &__first[-1431655765 * (((char *)__last - (char *)__first) >> 2) / 2],
    __last - 1,
    __comp);
  return std::__unguarded_partition<edge *,edge,int (*)(edge const&,edge const&)>(__first + 1, __last, __first, __comp);
}

//----- (00414CC8) --------------------------------------------------------
int __usercall std::__lg@<eax>(int a1@<eax>, int __n)
{
  mcount();
  _BitScanReverse((unsigned int *)&a1, __n);
  return 31 - (a1 ^ 0x1F);
}

//----- (00414CE8) --------------------------------------------------------
void __cdecl std::sort<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  int v3; // eax@2

  mcount();
  if ( __first != __last )
  {
    v3 = std::__lg(
           -1431655765 * (((char *)__last - (char *)__first) >> 2),
           -1431655765 * (((char *)__last - (char *)__first) >> 2));
    std::__introsort_loop<edge *,int,int (*)(edge const&,edge const&)>(__first, __last, 2 * v3, __comp);
    std::__final_insertion_sort<edge *,int (*)(edge const&,edge const&)>(__first, __last, __comp);
  }
}

//----- (00414D74) --------------------------------------------------------
void __cdecl std::swap<edge>(edge *const __a, edge *const __b)
{
  edge __tmp; // [sp+4h] [bp-18h]@1

  mcount();
  qmemcpy(&__tmp, __a, sizeof(__tmp));
  qmemcpy(__a, __b, sizeof(edge));
  qmemcpy(__b, &__tmp, sizeof(edge));
}

//----- (00414DCC) --------------------------------------------------------
void __cdecl std::iter_swap<edge *,edge *>(edge *__a, edge *__b)
{
  mcount();
  std::__iter_swap<true>::iter_swap<edge *,edge *>(__a, __b);
}

//----- (00414DEC) --------------------------------------------------------
void __cdecl std::make_heap<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  std::make_heap<edge*,int (*)(const edge&,const edge&)>::_ValueType v3; // [sp+Ch] [bp-4Ch]@3
  std::make_heap<edge*,int (*)(const edge&,const edge&)>::_ValueType __value; // [sp+2Ch] [bp-2Ch]@3
  const std::make_heap<edge*,int (*)(const edge&,const edge&)>::_DistanceType __len; // [sp+38h] [bp-20h]@2
  std::make_heap<edge*,int (*)(const edge&,const edge&)>::_DistanceType __parent; // [sp+3Ch] [bp-1Ch]@2

  mcount();
  if ( (char *)__last - (char *)__first > 23 )
  {
    __len = -1431655765 * (((char *)__last - (char *)__first) >> 2);
    for ( __parent = (-1431655765 * (((char *)__last - (char *)__first) >> 2) - 2) / 2; ; --__parent )
    {
      qmemcpy(&__value, &__first[__parent], sizeof(__value));
      qmemcpy(&v3, &__value, sizeof(v3));
      std::__adjust_heap<edge *,int,edge,int (*)(edge const&,edge const&)>(__first, __parent, __len, v3, __comp);
      if ( !__parent )
        break;
    }
  }
}

//----- (00414ED0) --------------------------------------------------------
void __cdecl std::sort_heap<edge *,int (*)(edge const&,edge const&)>(edge *__first, edge *__last, int (*__comp)(const edge *, const edge *))
{
  mcount();
  while ( (char *)__last - (char *)__first > 23 )
  {
    --__last;
    std::__pop_heap<edge *,int (*)(edge const&,edge const&)>(__first, __last, __last, __comp);
  }
}

//----- (00414F1C) --------------------------------------------------------
void __noreturn std::terminate(void)
{
  __cxxabiv1::__terminate(__cxxabiv1::__terminate_handler);
}

//----- (00414F2C) --------------------------------------------------------
void __cdecl operator delete(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (00414F40) --------------------------------------------------------
char *__usercall __cxa_allocate_dependent_exception@<eax>(int a1@<ebp>)
{
  char *v1; // ebx@1
  _DWORD *v2; // eax@2
  unsigned int v4; // eax@4
  int v5; // ecx@4
  char *v6; // eax@9

  v1 = (char *)malloc(0x50u);
  if ( !v1 )
  {
    if ( _CRT_MT && __gthr_win32_mutex_lock(&`anonymous namespace'::emergency_mutex) )
      __gnu_cxx::__throw_concurrence_lock_error(a1);
    v4 = dependents_used;
    v5 = 0;
    while ( v4 & 1 )
    {
      v4 >>= 1;
      if ( ++v5 == 32 )
        std::terminate();
    }
    dependents_used |= 1 << v5;
    v1 = (char *)&dependents_buffer + 80 * v5;
    if ( _CRT_MT && __gthr_win32_mutex_unlock(&`anonymous namespace'::emergency_mutex) )
    {
      v6 = __cxa_allocate_exception(a1, 4);
      *(_DWORD *)v6 = &off_41E340;
      __cxa_throw(
        a1,
        (int)v6,
        (int)&off_41E07C,
        (int)__gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error);
    }
  }
  v2 = __cxa_get_globals();
  ++v2[1];
  memset(v1, 0, 0x50u);
  return v1;
}
// 417084: using guessed type _DWORD dependents_used;
// 41E07C: using guessed type void *off_41E07C;
// 41E340: using guessed type _DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this);
// 55B920: using guessed type int _CRT_MT;

//----- (00415030) --------------------------------------------------------
char *__usercall __cxa_allocate_exception@<eax>(int a1@<ebp>, int a2)
{
  char *v2; // ebx@1
  _DWORD *v3; // eax@2
  unsigned int v5; // eax@5
  int v6; // ecx@5
  _DWORD *v7; // eax@10

  v2 = (char *)malloc(a2 + 96);
  if ( !v2 )
  {
    if ( _CRT_MT && __gthr_win32_mutex_lock(&`anonymous namespace'::emergency_mutex) )
      __gnu_cxx::__throw_concurrence_lock_error(a1);
    if ( (unsigned int)(a2 + 96) > 0x200 )
LABEL_12:
      std::terminate();
    v5 = data_1;
    v6 = 0;
    while ( v5 & 1 )
    {
      v5 >>= 1;
      if ( ++v6 == 32 )
        goto LABEL_12;
    }
    data_1 |= 1 << v6;
    v2 = (char *)&emergency_buffer + 512 * v6;
    if ( _CRT_MT && __gthr_win32_mutex_unlock(&`anonymous namespace'::emergency_mutex) )
    {
      v7 = (_DWORD *)__cxa_allocate_exception(a1, 4);
      *v7 = &off_41E340;
      __cxa_throw(
        a1,
        (int)v7,
        (int)&off_41E07C,
        (int)__gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error);
    }
  }
  v3 = __cxa_get_globals();
  ++v3[1];
  memset(v2, 0, 0x60u);
  return v2 + 96;
}
// 417080: using guessed type int data_1;
// 41E07C: using guessed type void *off_41E07C;
// 41E340: using guessed type _DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this);
// 55B920: using guessed type int _CRT_MT;

//----- (00415128) --------------------------------------------------------
int __cdecl __cxa_begin_catch(_QWORD *a1)
{
  int *v1; // eax@1
  int v2; // edx@1
  int v3; // edi@1
  int result; // eax@3
  int v5; // ecx@4
  int v6; // ebx@5

  v1 = __cxa_get_globals();
  v2 = *v1;
  v3 = (int)(a1 - 6);
  if ( (unsigned __int64)(*a1 - 5138137972254386944LL) <= 1 )
  {
    v5 = *((_DWORD *)a1 - 7);
    if ( v5 < 0 )
      v6 = 1 - v5;
    else
      v6 = v5 + 1;
    *((_DWORD *)a1 - 7) = v6;
    --v1[1];
    if ( v3 != v2 )
    {
      *((_DWORD *)a1 - 8) = v2;
      *v1 = v3;
    }
    result = *((_DWORD *)a1 - 2);
  }
  else
  {
    if ( v2 )
      std::terminate();
    *v1 = v3;
    result = 0;
  }
  return result;
}

//----- (00415190) --------------------------------------------------------
void __cdecl __noreturn __cxa_call_terminate(void (**a1)(void))
{
  if ( a1 )
  {
    __cxa_begin_catch(a1);
    if ( (unsigned __int64)(*(_QWORD *)a1 - 5138137972254386944LL) <= 1 )
      __cxxabiv1::__terminate(*(a1 - 9));
  }
  std::terminate();
}

//----- (004151D4) --------------------------------------------------------
void __cdecl __noreturn __cxa_call_unexpected(_QWORD *a1)
{
  int v1; // ebp@2
  int v2; // esi@2
  int v3; // edi@2
  int v4; // ST20_4@2

  __cxa_begin_catch(a1);
  v1 = *((_DWORD *)a1 - 4);
  v2 = *((_DWORD *)a1 - 6);
  v3 = *((_DWORD *)a1 - 9);
  v4 = *((_DWORD *)a1 - 3);
  __cxxabiv1::__unexpected(*((void (**)(void))a1 - 10));
}

//----- (004152A0) --------------------------------------------------------
int __cxa_current_exception_type()
{
  int v0; // eax@1
  int result; // eax@4

  v0 = *__cxa_get_globals();
  if ( v0 )
  {
    if ( *(_BYTE *)(v0 + 48) & 1 )
      v0 = *(_DWORD *)v0 - 80;
    result = *(_DWORD *)v0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004152C8) --------------------------------------------------------
void __noreturn __cxa_deleted_virtual()
{
  write(2, "deleted virtual method called\n", 0x1Eu);
  std::terminate();
}

//----- (004152EC) --------------------------------------------------------
int *__cxa_end_catch()
{
  int *result; // eax@1
  int v1; // edx@1
  signed __int64 v2; // rcx@2
  int v3; // ecx@6
  int v4; // ecx@7

  result = __cxa_get_globals_fast();
  v1 = *result;
  if ( *result )
  {
    v2 = *(_QWORD *)(v1 + 48) - 5138137972254386944LL;
    if ( HIDWORD(v2) || (unsigned int)v2 > 1 )
    {
      *result = 0;
      result = (int *)_Unwind_DeleteException(v1 + 48);
    }
    else
    {
      v3 = *(_DWORD *)(v1 + 20);
      if ( v3 < 0 )
      {
        v4 = v3 + 1;
        if ( !v4 )
          *result = *(_DWORD *)(v1 + 16);
        goto LABEL_9;
      }
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 == -1 )
          std::terminate();
LABEL_9:
        *(_DWORD *)(v1 + 20) = v4;
        return result;
      }
      *result = *(_DWORD *)(v1 + 16);
      result = (int *)_Unwind_DeleteException(v1 + 48);
    }
  }
  return result;
}

//----- (00415368) --------------------------------------------------------
void __usercall __cxa_free_dependent_exception(int a1@<ebp>, void *a2)
{
  unsigned int v2; // ebx@4
  int v3; // eax@5
  int v4; // eax@8
  char *v5; // eax@10

  if ( a2 >= &dependents_buffer && a2 < &__cxxabiv1::__terminate_handler )
  {
    v2 = ((_BYTE *)a2 - (_BYTE *)&dependents_buffer) / 0x50u;
    if ( _CRT_MT )
    {
      if ( __gthr_win32_mutex_lock(&`anonymous namespace'::emergency_mutex) )
        __gnu_cxx::__throw_concurrence_lock_error(a1);
      v4 = __ROL4__(-2, v2);
      dependents_used &= v4;
      if ( _CRT_MT && __gthr_win32_mutex_unlock(&`anonymous namespace'::emergency_mutex) )
      {
        v5 = __cxa_allocate_exception(a1, 4);
        *(_DWORD *)v5 = &off_41E340;
        __cxa_throw(
          a1,
          (int)v5,
          (int)&off_41E07C,
          (int)__gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error);
      }
    }
    else
    {
      v3 = __ROL4__(-2, v2);
      dependents_used &= v3;
    }
  }
  else
  {
    free(a2);
  }
}
// 417084: using guessed type _DWORD dependents_used;
// 41E07C: using guessed type void *off_41E07C;
// 41E340: using guessed type _DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this);
// 55B920: using guessed type int _CRT_MT;

//----- (00415438) --------------------------------------------------------
void __usercall __cxa_free_exception(int ebp0@<ebp>, void *a1)
{
  unsigned int v2; // ebx@4
  int v3; // eax@5
  int v4; // eax@8
  char *v5; // eax@10

  if ( a1 >= &emergency_buffer && a1 < &dependents_buffer )
  {
    v2 = (unsigned int)((_BYTE *)a1 - (_BYTE *)&emergency_buffer) >> 9;
    if ( _CRT_MT )
    {
      if ( __gthr_win32_mutex_lock(&`anonymous namespace'::emergency_mutex) )
        __gnu_cxx::__throw_concurrence_lock_error(ebp0);
      v4 = __ROL4__(-2, v2);
      data_1 &= v4;
      if ( _CRT_MT && __gthr_win32_mutex_unlock(&`anonymous namespace'::emergency_mutex) )
      {
        v5 = __cxa_allocate_exception(ebp0, 4);
        *(_DWORD *)v5 = &off_41E340;
        __cxa_throw(
          ebp0,
          (int)v5,
          (int)&off_41E07C,
          (int)__gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error);
      }
    }
    else
    {
      v3 = __ROL4__(-2, v2);
      data_1 &= v3;
    }
  }
  else
  {
    free((char *)a1 - 96);
  }
}
// 417080: using guessed type int data_1;
// 41E07C: using guessed type void *off_41E07C;
// 41E340: using guessed type _DWORD (__cdecl *off_41E340)(__gnu_cxx::__concurrence_unlock_error *__hidden this);
// 55B920: using guessed type int _CRT_MT;

//----- (00415504) --------------------------------------------------------
int __cdecl __cxa_get_exception_ptr(int a1)
{
  return *(_DWORD *)(a1 - 8);
}

//----- (0041550C) --------------------------------------------------------
_DWORD *__cxa_get_globals()
{
  return __emutls_get_address((int)&__emutls_v__ZZN12_GLOBAL__N_110get_globalEvE6global);
}

//----- (00415520) --------------------------------------------------------
_DWORD *__cxa_get_globals_fast()
{
  return __emutls_get_address((int)&__emutls_v__ZZN12_GLOBAL__N_110get_globalEvE6global);
}

//----- (00415534) --------------------------------------------------------
// jumptable 0040F04A cases 207,233
void __noreturn __cxa_pure_virtual()
{
  write(2, "pure virtual method called\n", 0x1Bu);
  std::terminate();
}

//----- (00415558) --------------------------------------------------------
void __usercall __noreturn __cxa_rethrow(int a1@<ebp>)
{
  int *v1; // eax@1
  int v2; // edx@1
  signed __int64 v3; // rcx@2

  v1 = __cxa_get_globals();
  v2 = *v1;
  ++v1[1];
  if ( v2 )
  {
    v3 = *(_QWORD *)(v2 + 48) - 5138137972254386944LL;
    if ( HIDWORD(v3) || (unsigned int)v3 > 1 )
      *v1 = 0;
    else
      *(_DWORD *)(v2 + 20) = -*(_DWORD *)(v2 + 20);
    _Unwind_Resume_or_Rethrow(a1);
  }
  std::terminate();
}

//----- (004155AC) --------------------------------------------------------
void __usercall __noreturn __cxa_throw(int a1@<ebp>, int a2, int a3, int a4)
{
  *(_DWORD *)(a2 - 96) = 1;
  *(_DWORD *)(a2 - 80) = a3;
  *(_DWORD *)(a2 - 76) = a4;
  *(_DWORD *)(a2 - 72) = __cxxabiv1::__unexpected_handler;
  *(_DWORD *)(a2 - 68) = __cxxabiv1::__terminate_handler;
  *(_DWORD *)(a2 - 32) = 1126902528;
  *(_DWORD *)(a2 - 28) = 1196315971;
  *(_DWORD *)(a2 - 24) = __gxx_exception_cleanup;
  _Unwind_RaiseException(a1);
}

//----- (00415608) --------------------------------------------------------
signed int __cdecl __gxx_personality_v0(int a1, int a2, __int64 a3, void (**a4)(void), int a5)
{
  signed int result; // eax@2
  void (*v6)(void); // eax@7
  char *v7; // ebx@8
  unsigned __int8 v8; // al@9
  _DWORD **v9; // eax@12
  int v10; // eax@13
  unsigned int v11; // esi@13
  char v12; // bp@14
  unsigned __int8 v13; // al@15
  int v14; // ebx@21
  _DWORD **v15; // edx@24
  char *v16; // eax@25
  char *v17; // ecx@25
  char v18; // bl@25
  unsigned __int8 v19; // dl@26
  _DWORD **v20; // edx@29
  char *v21; // eax@30
  char *v22; // ecx@30
  char v23; // bl@30
  unsigned __int8 v24; // dl@31
  _DWORD **v25; // edx@34
  int v26; // ebp@35
  int v27; // ecx@35
  char v28; // dl@36
  signed int v29; // eax@38
  char *v30; // ST1C_4@52
  char *v31; // ST1C_4@56
  char *v32; // ST1C_4@65
  char *v33; // ST1C_4@66
  char *v34; // ST1C_4@87
  char *v35; // ST1C_4@88
  char v36; // dl@90
  unsigned __int8 v37; // al@91
  _DWORD **v38; // eax@95
  unsigned __int8 v39; // dl@97
  int v40; // eax@101
  _BYTE *v41; // ebx@111
  int v42; // ebp@112
  unsigned int v43; // ecx@112
  char v44; // dl@113
  char *v45; // eax@113
  int v46; // esi@117
  unsigned int v47; // ecx@117
  _BYTE *v48; // edi@117
  char v49; // bl@118
  char v50; // al@119
  _BYTE *v51; // ebx@119
  unsigned __int8 v52; // dl@125
  int v53; // edx@128
  int v54; // edi@129
  char *v55; // edx@142
  int v56; // ecx@142
  int v57; // esi@142
  char v58; // bl@143
  int v59; // eax@144
  char v60; // al@144
  void (*v61)(void); // [sp+20h] [bp-6Ch]@7
  int v62; // [sp+24h] [bp-68h]@21
  int v63; // [sp+28h] [bp-64h]@38
  int *v64; // [sp+2Ch] [bp-60h]@38
  char *v65; // [sp+30h] [bp-5Ch]@110
  char v66; // [sp+36h] [bp-56h]@4
  char v67; // [sp+37h] [bp-55h]@111
  int v68; // [sp+38h] [bp-54h]@142
  unsigned int v69; // [sp+44h] [bp-48h]@1
  unsigned __int8 v70[4]; // [sp+48h] [bp-44h]@25
  unsigned __int8 v71[4]; // [sp+4Ch] [bp-40h]@30
  unsigned __int8 v72[4]; // [sp+50h] [bp-3Ch]@35
  int *v73; // [sp+54h] [bp-38h]@131
  int v74; // [sp+58h] [bp-34h]@8
  int v75; // [sp+5Ch] [bp-30h]@70
  _DWORD **v76; // [sp+60h] [bp-2Ch]@13
  int v77; // [sp+64h] [bp-28h]@129
  unsigned int v78; // [sp+68h] [bp-24h]@13
  char v79; // [sp+6Ch] [bp-20h]@8
  char v80; // [sp+6Dh] [bp-1Fh]@14

  v69 = 0;
  if ( a1 != 1 )
    return 3;
  v66 = 1;
  if ( (unsigned __int64)(a3 - 5138137972254386944LL) <= 1 )
    v66 = 0;
  if ( a2 == 6 && !v66 )
  {
    v14 = (int)*(a4 - 6);
    v61 = *(a4 - 4);
    v62 = (int)*(a4 - 3);
    if ( v62 )
      goto LABEL_22;
    goto LABEL_78;
  }
  v6 = (void (*)(void))_Unwind_GetLanguageSpecificData(a5);
  v61 = v6;
  if ( !v6 )
    return 8;
  v7 = parse_lsda_header(a5, v6, (int)&v74);
  if ( v79 == -1 )
    goto LABEL_12;
  v8 = v79 & 0x70;
  if ( (v79 & 0x70) == 32 )
  {
    v9 = (_DWORD **)_Unwind_GetTextRelBase(a5);
  }
  else
  {
    if ( v8 <= 0x20u )
    {
      if ( v8 && v8 != 16 )
        goto LABEL_19;
LABEL_12:
      v9 = 0;
      goto LABEL_13;
    }
    if ( v8 != 64 )
    {
      if ( v8 != 80 )
      {
        if ( v8 != 48 )
          goto LABEL_19;
        v9 = (_DWORD **)_Unwind_GetDataRelBase(a5);
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    v9 = (_DWORD **)_Unwind_GetRegionStart(a5);
  }
LABEL_13:
  v76 = v9;
  v10 = _Unwind_GetIPInfo(a5, &v69);
  v11 = v10 - (v69 < 1);
  if ( (unsigned int)v7 >= v78 )
  {
LABEL_38:
    v64 = 0;
    v14 = 0;
    v62 = 0;
    v63 = 0;
    v29 = 1;
    goto LABEL_39;
  }
  while ( 1 )
  {
    v12 = v80;
    if ( v80 == -1 )
      goto LABEL_24;
    v13 = v80 & 0x70;
    if ( (v80 & 0x70) == 32 )
    {
      v15 = (_DWORD **)_Unwind_GetTextRelBase(0);
    }
    else
    {
      if ( v13 <= 0x20u )
      {
        if ( v13 && v13 != 16 )
          goto LABEL_19;
LABEL_24:
        v15 = 0;
        goto LABEL_25;
      }
      if ( v13 == 64 )
      {
        v15 = (_DWORD **)_Unwind_GetRegionStart(0);
      }
      else
      {
        if ( v13 == 80 )
          goto LABEL_24;
        if ( v13 != 48 )
          goto LABEL_19;
        v15 = (_DWORD **)_Unwind_GetDataRelBase(0);
      }
    }
LABEL_25:
    v16 = read_encoded_value_with_base(v12, v15, (_DWORD **)v7, (int)v70);
    v17 = v16;
    v18 = v80;
    if ( v80 == -1 )
      goto LABEL_29;
    v19 = v80 & 0x70;
    if ( (v80 & 0x70) == 32 )
    {
      v32 = v16;
      v20 = (_DWORD **)_Unwind_GetTextRelBase(0);
      v17 = v32;
    }
    else
    {
      if ( v19 <= 0x20u )
      {
        if ( v19 && v19 != 16 )
          goto LABEL_19;
LABEL_29:
        v20 = 0;
        goto LABEL_30;
      }
      if ( v19 == 64 )
      {
        v33 = v16;
        v20 = (_DWORD **)_Unwind_GetRegionStart(0);
        v17 = v33;
      }
      else
      {
        if ( v19 == 80 )
          goto LABEL_29;
        if ( v19 != 48 )
          goto LABEL_19;
        v30 = v16;
        v20 = (_DWORD **)_Unwind_GetDataRelBase(0);
        v17 = v30;
      }
    }
LABEL_30:
    v21 = read_encoded_value_with_base(v18, v20, (_DWORD **)v17, (int)v71);
    v22 = v21;
    v23 = v80;
    if ( v80 == -1 )
      goto LABEL_34;
    v24 = v80 & 0x70;
    if ( (v80 & 0x70) == 32 )
    {
      v34 = v21;
      v25 = (_DWORD **)_Unwind_GetTextRelBase(0);
      v22 = v34;
      goto LABEL_35;
    }
    if ( v24 <= 0x20u )
    {
      if ( v24 && v24 != 16 )
        goto LABEL_19;
LABEL_34:
      v25 = 0;
      goto LABEL_35;
    }
    if ( v24 == 64 )
    {
      v35 = v21;
      v25 = (_DWORD **)_Unwind_GetRegionStart(0);
      v22 = v35;
      goto LABEL_35;
    }
    if ( v24 == 80 )
      goto LABEL_34;
    if ( v24 != 48 )
      goto LABEL_19;
    v31 = v21;
    v25 = (_DWORD **)_Unwind_GetDataRelBase(0);
    v22 = v31;
LABEL_35:
    v7 = read_encoded_value_with_base(v23, v25, (_DWORD **)v22, (int)v72);
    v26 = 0;
    v27 = 0;
    do
    {
      v28 = *v7++;
      v26 |= (v28 & 0x7F) << v27;
      v27 += 7;
    }
    while ( v28 < 0 );
    if ( v11 < v74 + *(_DWORD *)v70 )
      goto LABEL_38;
    if ( v11 < *(_DWORD *)v71 + v74 + *(_DWORD *)v70 )
      break;
    if ( (unsigned int)v7 >= v78 )
      goto LABEL_38;
  }
  if ( *(_DWORD *)v72 )
    v62 = v75 + *(_DWORD *)v72;
  else
    v62 = 0;
  if ( !v26 )
  {
    if ( v62 )
      goto LABEL_73;
    return 8;
  }
  v63 = v78 + v26 - 1;
  if ( !v62 )
    return 8;
  if ( v78 + v26 == 1 )
  {
LABEL_73:
    if ( a2 & 1 )
      return 8;
    v14 = 0;
    v29 = 2;
LABEL_75:
    if ( a2 & 8 || v66 )
    {
      if ( v29 == 1 )
        std::terminate();
      if ( v14 < 0 )
        std::unexpected();
      goto LABEL_23;
    }
    if ( v29 != 1 )
    {
LABEL_22:
      if ( v14 >= 0 )
      {
LABEL_23:
        _Unwind_SetGR(a5, 0, (int)a4);
        _Unwind_SetGR(a5, 2, v14);
        _Unwind_SetIP(a5, v62);
        return 7;
      }
      parse_lsda_header(a5, v61, (int)&v74);
      v36 = v79;
      if ( v79 != -1 )
      {
        v37 = v79 & 0x70;
        if ( (v79 & 0x70) == 32 )
        {
          v38 = (_DWORD **)_Unwind_GetTextRelBase(a5);
          v36 = v79;
          goto LABEL_96;
        }
        if ( v37 > 0x20u )
        {
          if ( v37 == 64 )
          {
            v38 = (_DWORD **)_Unwind_GetRegionStart(a5);
            v36 = v79;
            goto LABEL_96;
          }
          if ( v37 != 80 )
          {
            if ( v37 != 48 )
              goto LABEL_19;
            v38 = (_DWORD **)_Unwind_GetDataRelBase(a5);
            v36 = v79;
            goto LABEL_96;
          }
        }
        else if ( v37 && v37 != 16 )
        {
          goto LABEL_19;
        }
      }
      v38 = 0;
LABEL_96:
      v76 = v38;
      if ( v36 == -1 )
      {
LABEL_101:
        v40 = 0;
LABEL_102:
        *(a4 - 3) = (void (*)(void))v40;
        goto LABEL_23;
      }
      v39 = v36 & 0x70;
      if ( v39 == 32 )
      {
        v40 = _Unwind_GetTextRelBase(a5);
        goto LABEL_102;
      }
      if ( v39 > 0x20u )
      {
        if ( v39 == 64 )
        {
          v40 = _Unwind_GetRegionStart(a5);
          goto LABEL_102;
        }
        if ( v39 == 80 )
          goto LABEL_101;
        if ( v39 == 48 )
        {
          v40 = _Unwind_GetDataRelBase(a5);
          goto LABEL_102;
        }
      }
      else if ( !v39 || v39 == 16 )
      {
        goto LABEL_101;
      }
LABEL_19:
      abort();
    }
LABEL_78:
    __cxa_call_terminate(a4);
  }
  if ( a2 & 8 )
  {
    v64 = 0;
    v65 = (char *)&loc_41E048;
  }
  else if ( v66 )
  {
    v64 = 0;
    v65 = (char *)&loc_41E057 + 5;
  }
  else
  {
    v64 = (int *)(a4 + 8);
    if ( *(_BYTE *)a4 & 1 )
      v64 = (int *)*(a4 - 12);
    v65 = (char *)*(v64 - 20);
  }
  v67 = 0;
  v41 = (_BYTE *)(v78 + v26 - 1);
  while ( 2 )
  {
    v42 = 0;
    v43 = 0;
    do
    {
      v44 = *v41;
      v45 = v41 + 1;
      v42 |= (*v41 & 0x7F) << v43;
      v43 += 7;
      ++v41;
    }
    while ( v44 < 0 );
    if ( v43 <= 0x1F && v44 & 0x40 )
      v42 |= -(1 << v43);
    v46 = 0;
    v47 = 0;
    v48 = v41;
    do
    {
      v49 = *v45++;
      v46 |= (v49 & 0x7F) << v47;
      v47 += 7;
    }
    while ( v49 < 0 );
    v50 = v49;
    v51 = v48;
    if ( v47 <= 0x1F && v50 & 0x40 )
      v46 |= -(1 << v47);
    if ( !v42 )
    {
      v67 = 1;
      goto LABEL_137;
    }
    if ( v42 <= 0 )
    {
      if ( !v65 || a2 & 8 || v66 )
      {
        v55 = (char *)(v77 + ~v42);
        v56 = 0;
        v68 = v46;
        v57 = 0;
        do
        {
          v58 = *v55++;
          v57 |= (v58 & 0x7F) << v56;
          v56 += 7;
        }
        while ( v58 < 0 );
        v59 = v57;
        v51 = v48;
        v46 = v68;
        v60 = v59 == 0;
      }
      else
      {
        v60 = check_exception_spec((int)&v74, (int)v65, v64, v42) ^ 1;
      }
      if ( v60 )
        goto LABEL_135;
      goto LABEL_137;
    }
    if ( v79 == -1 )
    {
      v53 = 0;
    }
    else
    {
      v52 = v79 & 7;
      if ( (v79 & 7) == 2 )
      {
        v53 = -2 * v42;
      }
      else if ( v52 > 2u )
      {
        if ( v52 == 3 )
          goto LABEL_128;
        if ( v52 != 4 )
          goto LABEL_19;
        v53 = -8 * v42;
      }
      else
      {
        if ( v52 )
          goto LABEL_19;
LABEL_128:
        v53 = -4 * v42;
      }
    }
    read_encoded_value_with_base(v79, v76, (_DWORD **)(v53 + v77), (int)v72);
    v54 = *(_DWORD *)v72;
    if ( !*(_DWORD *)v72 )
      goto LABEL_135;
    if ( !v65 )
      goto LABEL_137;
    v73 = v64;
    if ( (unsigned __int8)(*(int (__fastcall **)(char *))(*(_DWORD *)v65 + 8))(v65) )
      v73 = (int *)*v73;
    if ( !(unsigned __int8)(*(int (__fastcall **)(int, char *, char *, int *))(*(_DWORD *)v54 + 16))(
                             v54,
                             v65,
                             v65,
                             (int *)&v73) )
    {
LABEL_137:
      if ( !v46 )
      {
        if ( v67 )
          goto LABEL_73;
        return 8;
      }
      v63 = (int)&v51[v46];
      v41 = &v51[v46];
      continue;
    }
    break;
  }
  v64 = v73;
LABEL_135:
  v14 = v42;
  v29 = 3;
LABEL_39:
  if ( !(a2 & 1) )
    goto LABEL_75;
  if ( v66 )
  {
    result = 6;
  }
  else
  {
    *(a4 - 6) = (void (*)(void))v14;
    *(a4 - 5) = (void (*)(void))v63;
    *(a4 - 4) = v61;
    *(a4 - 2) = (void (*)(void))v64;
    *(a4 - 3) = (void (*)(void))v62;
    result = 6;
  }
  return result;
}

//----- (00415F14) --------------------------------------------------------
void __cdecl __tcf_0()
{
  if ( _CRT_MT )
    __gthr_win32_mutex_destroy((int)&`anonymous namespace'::emergency_mutex);
}
// 55B920: using guessed type int _CRT_MT;

//----- (00415F40) --------------------------------------------------------
int _monstartup()
{
  int result; // eax@1
  bool v1; // zf@1

  result = called_1791;
  v1 = called_1791++ == 0;
  if ( v1 )
  {
    monstartup((int)__gcc_register_frame, (int)dword_416048);
    result = atexit(_mcleanup);
  }
  return result;
}
// 416048: using guessed type int dword_416048[16];
// 423008: using guessed type int called_1791;

//----- (00415F80) --------------------------------------------------------
int _GLOBAL__sub_I___cxa_allocate_exception()
{
  if ( _CRT_MT )
    __gthr_win32_mutex_init_function((int)&`anonymous namespace'::emergency_mutex);
  return atexit(__tcf_0);
}
// 55B920: using guessed type int _CRT_MT;

//----- (00415FA8) --------------------------------------------------------
_DWORD *__usercall emutls_alloc@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // eax@1
  _DWORD *v4; // eax@2
  _DWORD *v5; // edx@4
  void *v6; // eax@5
  const void *v7; // esi@7
  unsigned int v8; // ecx@7

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)a1;
  if ( v2 > 4 )
  {
    v6 = malloc(v2 + v3 + 3);
    if ( !v6 )
LABEL_3:
      abort();
    v5 = (_DWORD *)(-v2 & ((unsigned int)v6 + v2 + 3));
    *(v5 - 1) = v6;
  }
  else
  {
    v4 = malloc(v3 + 4);
    if ( !v4 )
      goto LABEL_3;
    *v4 = v4;
    v5 = v4 + 1;
  }
  v7 = *(const void **)(v1 + 12);
  v8 = *(_DWORD *)v1;
  if ( v7 )
    qmemcpy(v5, v7, v8);
  else
    memset(v5, 0, v8);
  return v5;
}

//----- (00416010) --------------------------------------------------------
int register_frame_ctor()
{
  __gcc_register_frame();
  return atexit(__gcc_deregister_frame);
}

#error "There were 1 decompilation failure(s) on 238 function(s)"
